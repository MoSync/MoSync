/* Copyright (C) 2009 Mobile Sorcery AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

/** \file maapi.h
* \brief Syscall declarations. These system calls and low-level
* functions provide access to the basic features of a device. They are
* implemented by the MoSync runtimes in code native to the device.
*


* With these syscalls it should be possible to do most things, although,
* there may still be some functionality missing. If you
* would like a specific function added, please send us a
* <a href="mailto:info@mobilesorcery.com">mail</a>.

* In future versions of MoSync an extension API will be provided
* that will allow you to create your own custom syscalls.


* Some Caveats:
*

* The Runtime expects alignment rules to be followed.
* Writing or reading to unaligned memory will cause a MoSync Panic.

* Some functions may also cause a panic if they are passed incorrect parameters.
* A complete reference of these panics can be found <a href="../panics.html">here</a>.

* The codepage for functions that use strings is platform-dependent beyond 7-bit ASCII.
* Most use Latin-1, but you should still be wary.


* Additional notes:


* There are different types of handles: Connection, Store and Resource.
* They are all represented as positive signed integers.
* When a handle is passed to a function, it must have the proper type.

* Each MoSync program has a Resource array. It is acccessed and manipulated by certain
*  syscalls, but it cannot be accessed directly.
* Each resource (aka Object) is represented by a
* handle. There are different types of resources, for example
* Image, Binary data, Sound or Placeholder. A placeholder object is not a real object, but
* just a handle which you can use to construct new objects dynamically.
* Resources can also be defined at compile time, by using MoSync's resource compiler.
* Placeholders can either be defined at compile time using a resource compiler directive
* or created dynamically at runtime using maCreatePlaceholder().
* See the tutorials, examples and the resource compiler reference documentation for more
* information.

* There is an event queue which contains keypad events and results from asynchronous operations.
* Use maWait() and maGetEvent() to handle it.

* MoSync socket/Bluetooth/HTTP connections are asynchronous. Read all about it \link connApiOverview here\endlink.
*/

interface MAAPI {

	typedef char* MAString;
	typedef wchar* MAWString;
	typedef void* MAAddress;
	typedef int MAHandle;
	typedef int MAExtent;
	typedef unsigned char byte;
	typedef unsigned long ulong;
	typedef long long longlong;

	/// Returns the height of an MAExtent.
#define EXTENT_Y(e) ((short)(e))

	/// Returns the width of an MAExtent.
#define EXTENT_X(e) ((short)((e) >> 16))

	/// Creates an MAExtent.
#define EXTENT(x, y) ((MAExtent)((((int)(x)) << 16) | ((y) & 0xFFFF)))

	// These three functions are at the top,
	// to ensure their numeric identifiers do not change in the future.

	/**
	* Compares the runtime's interface version with yours,
	* using a hash of the interface's contents.
	*
	* If the versions do not match, a MoSync Panic is generated.
	*
	* This function returns the runtime's hash. However, if there is
	* a version mismatch, syscall and IOCTL numbers may differ between the runtime and
	* your version of the header files, causing a different function than this to be called.
	*
	* The hash appears as a 32-bit random number, so it is very unlikely that the return
	* value from any other function is the same as the runtime's hash.
	*
	* Therefore, you should always compare the return value from this function to your hash
	* and exit your program, preferably using maPanic(), if they don't match.
	*
	* \param hash Your hash. Pass #MAIDL_HASH.
	* \returns The runtime's hash.
	*/
	int maCheckInterfaceVersion(in int hash);

	/**
	* Shuts down the system. This function does not return.
	* \param result Passed to the operating system, where applicable. Ignored otherwise.
	*/
	noreturn maExit(in int result);

	/**
	* Displays a message to the user, then shuts down the system.
	* This function does not return.
	* \param result Passed to the operating system, where applicable. Ignored otherwise.
	* \param message The message should be short, not more than 40 characters,
	* to ensure its visibility on all screen sizes.
	* \see MAPanicReport
	*/
	noreturn maPanic(in int result, in MAString message);


	/**
	* Sets \a size bytes, starting at \a dst, to the specified value, interpreted as an unsigned char.
	* \returns \a dst.
	*/
	MAAddress memset(out MAAddress dst, in int val, in ulong size);

	/**
	* Copies the values of \a size bytes from the location pointed by \a src directly to the memory
	* block pointed by \a dst.
	*
	* The underlying type of the objects pointed by both the source and destination pointers are
	* irrelevant for this function; The result is a binary copy of the data.
	*
	* The function does not check for any terminating null character in source - it always copies
	* exactly \a size bytes.
	*
	* To avoid overflows, the size of the arrays pointed by both the destination and source
	* parameters, shall be at least \a size bytes, and should not overlap (for overlapping memory
	* blocks, memmove() is a safe approach).
	* \returns \a dst.
	*/
	MAAddress memcpy(out MAAddress dst, in MAAddress src, in ulong size);

	/**
	* Compares the C string \a str1 to the C string \a str2.
	*
	* This function starts comparing the first character of each string.
	* If they are equal to each other, it continues with the following pairs until the
	* characters differ or until a terminanting null-character is reached.
	*
	* \returns An integral value indicating the relationship between the strings:
	* A zero value indicates that both strings are equal.
	* A value greater than zero indicates that the first character that does not match
	* has a greater value in \a str1 than in \a str2. A value less than zero indicates the opposite.
	*/
	int strcmp(in MAString str1, in MAString str2);

	/**
	* Copies the C string pointed by \a src into the array pointed by \a dst,
	* including the terminating null character.
	*
	* To avoid overflows, the size of the array pointed by \a dst shall be long
	* enough to contain the same C string as \a src (including the terminating null
	* character), and should not overlap in memory with \a src.
	* \returns \a dst.
	*/
	MAString strcpy(out NCString dst, in NCString src);

	/**
	* Returns \a a + \a b.
	*/
	double __adddf3(in double a, in double b);
	/**
	* Returns \a a - \a b.
	*/
	double __subdf3(in double a, in double b);
	/**
	* Returns \a a * \a b.
	*/
	double __muldf3(in double a, in double b);
	/**
	* Returns \a a / \a b.
	* If \a b == 0, a <a href="../panics.html">MoSync Panic</a> is thrown.
	*/
	double __divdf3(in double a, in double b);
	/**
	* Returns -\a a.
	*/
	double __negdf2(in double a);
	/**
	* Returns the integer part of \a a.
	*/
	int __fixdfsi(in double a);
	/**
	* Returns the unsigned integer part of \a a. Negative values become zero.
	*/
	uint __fixunsdfsi(in double a);
	/**
	* Returns the double representation of \a a.
	*/
	double __floatsidf(in int a);
	/**
	* Returns the double representation of \a a.
	*/
	double __extendsfdf2(in float a);
	/**
	* Returns \>0 if \a a \> \a b, 0 if \a a == \a b and \<0 if \a a \< \a b.
	* If either argument is Not a Number, the result is undefined.
	*/
	int dcmp(in double a, in double b);


	/**
	* Returns \a a + \a b.
	*/
	float __addsf3(in float a, in float b);
	/**
	* Returns \a a - \a b.
	*/
	float __subsf3(in float a, in float b);
	/**
	* Returns \a a * \a b.
	*/
	float __mulsf3(in float a, in float b);
	/**
	* Returns \a a / \a b.
	* If \a b == 0, a <a href="../panics.html">MoSync Panic</a> is thrown.
	*/
	float __divsf3(in float a, in float b);
	/**
	* Returns -\a a.
	*/
	float __negsf2(in float a);
	/**
	* Returns the integer part of \a a.
	*/
	int __fixsfsi(in float a);
	/**
	* Returns the unsigned integer part of \a a. Negative values become zero.
	*/
	uint __fixunssfsi(in float a);
	/**
	* Returns the float representation of \a a.
	*/
	float __floatsisf(in int a);
	/**
	* Returns the float representation of \a a.
	*/
	float __truncdfsf2(in double a);
	/**
	* Returns \>0 if \a a \> \a b, 0 if \a a == \a b and \<0 if \a a \< \a b.
	* If either argument is Not a Number, the result is undefined.
	*/
	int fcmp(in float a, in float b);

	/**
	* Returns the sine of \a x.
	* \param x An angle in radians.
	*/
	double sin(in double x);
	/**
	* Returns the cosine of \a x.
	* \param x An angle in radians.
	*/
	double cos(in double x);
	/**
	* Returns the tangent of \a x.
	* \param x An angle in radians.
	*/
	double tan(in double x);
	/**
	* Returns the square root of \a x.
	*/
	double sqrt(in double x);

	/**
	 * \brief A structure representing a two-dimensional point, with coordinates 'x' and 'y'.
	 */
	struct MAPoint2d {
		int x;
		int y;
	}

	/**
	 * \brief A structure representing a rectangle.
	 *
	 * The x and y coordinate of the top-left corner are defined by 'left' and 'top'.
	 * The dimensions of the rectangle are defined by 'width' and 'height'.
	 */
	struct MARect {
		int left;
		int top;
		int width;
		int height;
	}

	/**
	* Sets the color used by drawing functions. Returns previous color. Initial color is 0 (black).
	* \param rgb A color in RGB8 format (0xRRGGBB). The top byte is ignored.
	*/
	int maSetColor(in int rgb);

	/**
	* Sets the clipping rectangle for the current draw target.
	* The screen and every drawable image each maintains a clipping rectangle.
	* Drawing operations have no effect outside the clipping rectangle.
	* The default clipping rectangle covers the entire draw target, so that
	* clipping occurs at the draw target's edges.
	*/
	void maSetClipRect(in int left, in int top, in int width, in int height);

	/**
	* Returns the clipping rectangle for the current draw target.
	*/
	void maGetClipRect(out MARect out);

	/**
	* Draws a single pixel using the current color.
	* \see maSetColor()
	*/
	void maPlot(in int posX, in int posY);
	/**
	* Draws a line using the current color.
	* \see maSetColor()
	*/
	void maLine(in int startX, in int startY, in int endX, in int endY);
	/**
	* Draws a filled rectangle using the current color.
	* Width and height must be greater than zero.
	* \see maSetColor()
	*/
	void maFillRect(in int left, in int top, in int width, in int height);
	/**
	* Draws a filled triangle strip using the current color.
	* \param points A pointer to an array of \a count MAPoint2d:s representing the
	* vertices of the strip.
	* \param count The count of vertices in the strip. Must be at least 3.
	* \see maSetColor()
	*/
	void maFillTriangleStrip(in MAPoint2d points, in int count);
	/**
	* Draws a filled triangle fan using the current color.
	* \param points A pointer to an array of \a count MAPoint2d:s representing the
	* vertices of the fan.
	* \param count The count of vertices in the fan. Must be at least 3.
	* \see maSetColor()
	*/
	void maFillTriangleFan(in MAPoint2d points, in int count);

	/**
	* Returns the size in pixels of Latin-1 text as it would appear on-screen.
	*/
	MAExtent maGetTextSize(in MAString str);

	/**
	* Returns the size in pixels of Unicode text as it would appear on-screen.
	*/
	MAExtent maGetTextSizeW(in MAWString str);

	/**
	* Draws Latin-1 text using the current color.
	* The coordinates are the top-left corner of the text's bounding box.
	* \see maSetColor()
	*/
	void maDrawText(in int left, in int top, in MAString str);

	/**
	* Draws Unicode text using the current color.
	* The coordinates are the top-left corner of the text's bounding box.
	* \see maSetColor()
	*/
	void maDrawTextW(in int left, in int top, in MAWString str);

	/**
	* Copies the back buffer to the physical screen.
	*/
	void maUpdateScreen();

	/**
	* Normally, a phone's backlight turns itself off after
	* a few seconds of the user not pressing any keys.
	* To avoid this behaviour, call this function periodically.
	* As the timeout period is different for every device, and sometimes even user-configurable,
	* it's recommended that you call this function at least once every 500 milliseconds
	* to ensure that the light stays on at all times.
	*/
	void maResetBacklight();

	/**
	* Returns the screen size.
	*/
	MAExtent maGetScrSize();

	/**
	* Draws an image.
	* It it placed on the draw target with the top left corner according to the parameters.
	*/
	void maDrawImage(in MAHandle image, in int left, in int top);

	/**
	* Draws an image.
	* The source is an array of ints that represent pixels in ARGB format.
	* \param dstPoint The top-left point on the draw target.
	* \param src The address to the source image.
	* \param srcRect The portion of the source image to be drawn.
	* \param scanlength The width, in pixels, of the image represented by the source array.
	*/
	void maDrawRGB(in MAPoint2d dstPoint, in MAAddress src, in MARect srcRect, in int scanlength);

	// The JavaMe runtime requires that these constans have these values. Do not change.
	constset int TRANS_ {
		/// The image is copied unchanged.
		NONE = 0;
		/// The image is rotated clockwise by 90 degrees.
		ROT90 = 5;
		/// The image is rotated clockwise by 180 degrees.
		ROT180 = 3;
		/// The image is rotated clockwise by 270 degrees.
		ROT270 = 6;
		/// The image is reflected about its vertical center.
		MIRROR = 2;
		/// The image is reflected about its vertical center, then rotated clockwise by 90 degrees.
		MIRROR_ROT90 = 7;
		/// The image is reflected about its vertical center, then rotated clockwise by 180 degrees.
		MIRROR_ROT180 = 1;
		/// The image is reflected about its vertical center, then rotated clockwise by 270 degrees.
		MIRROR_ROT270 = 4;
	}

	/**
	* Draws a portion of an image using a transformation.
	* \param image The source image.
	* \param srcRect The portion of the source image to be drawn.
	* Must not exceed the bounds of the source image.
	* \param dstPoint The top-left point on the draw target.
	* \param transformMode One of the \link #TRANS_NONE TRANS \endlink constants.
	* \see maDrawImage
	*/
	void maDrawImageRegion(in MAHandle image, in MARect srcRect, in MAPoint2d dstPoint,
		in int transformMode);

	/**
	* Returns the size of an image.
	*/
	MAExtent maGetImageSize(in MAHandle image);

	/**
	* Copies an image into an array of ints that represent pixels in ARGB format.
	* The destination rectangle is defined as { 0,0, \a srcRect.width, \a srcRect.height }.
	* Parts of the destination array that are outside the destination rectangle are not modified.
	* If \a srcRect is outside the bounds of the source image,
	* or if \a srcRect.width is greater than \a scanlength, a MoSync Panic is thrown.
	* \param image The handle to the source image.
	* \param dst The address of the destination array.
	* \param scanlength The width of the image, in pixels, represented by the destination array.
	* \param srcRect The portion of the source image to be copied.
	*/
	void maGetImageData(in MAHandle image, out MAAddress dst, in MARect srcRect, in int scanlength);

	/**
	* Sets the current draw target.
	* The handle must be a drawable image or #HANDLE_SCREEN, which represents the back buffer.
	* The initial draw target is the back buffer.
	* If an image is set as draw target, its object handle goes into flux, which prevents
	* its destruction or use as a source in maDrawImage. When a different draw target is set,
	* the image's handle is restored. Returns the the previously set draw target.
	* \see maCreateDrawableImage()
	*/
	//Graphics.copyArea could be used to allow an image to be drawn to itself.
	MAHandle maSetDrawTarget(in MAHandle image);

	constset int HANDLE_ {
		/// This handle refers to the back buffer, which is initially black.
		SCREEN = 0;

		LOCAL = 0;
	}

	/**
	 * Finds the label resource with the specified \a name and returns its index.
	 * If it is not found, -1 is returned.
	 */
	int maFindLabel(in MAString name);

	// TODO: Should we change RES_OK to be zero? Many
	constset int RES_ {
		OUT_OF_MEMORY = -1;
		BAD_INPUT = -2;
		OK = 1;
	}

	/**
	* Creates an image object using encoded data from a data object.
	* All platforms support the PNG format. Some platforms may also support JPEG and/or GIF.
	* \param placeholder The placeholder for the image object that is to be created.
	* \param data The data object that holds the encoded data.
	* \param offset The offset in the data object where the encoded data begins.
	* \param size The size in bytes of the encoded data.
	* \returns #RES_OK if succeded and #RES_OUT_OF_MEMORY or #RES_BAD_INPUT if failed.
	*/
	int maCreateImageFromData(in MAHandle placeholder, in MAHandle data, in int offset, in int size);

	/**
	* Creates an image object using raw ARGB data.
	* \param placeholder The placeholder for the image object that is to be created.
	* \param src Address of the raw data. 4 bytes per pixel, format 0xAARRGGBB.
	* \param size The size in pixels of the image, constructed using the EXTENT() macro.
	* \param alpha Non-zero if the resulting image should have an alpha channel, zero otherwise.
	* \returns #RES_OK if succeded and #RES_OUT_OF_MEMORY if failed.
	*/
	int maCreateImageRaw(in MAHandle placeholder, in MAAddress src, in MAExtent size, in int alpha);

	/**
	* Creates a drawable image of the specified size. A drawable image has no alpha channel,
	* which is to say, no transparency.
	* Its initial contents are undefined, so you should draw onto the entire surface to
	* be sure what will happen when you draw this image onto something else.
	* \param placeholder The resource handle of the new image.
	* \param width Width, in pixels, of the new image. Must be \> 0.
	* \param height Height, in pixels, of the new image. Must be \> 0.
	* \see maSetDrawTarget()
	* \returns #RES_OK if succeded and #RES_OUT_OF_MEMORY if failed.
	*/
	int maCreateDrawableImage(in MAHandle placeholder, in int width, in int height);

	/**
	* Creates a data object of the specified \a size, in bytes. Its initial contents are undefined.
	* \returns #RES_OK if succeded and #RES_OUT_OF_MEMORY if failed.
	*/
	int maCreateData(in MAHandle placeholder, in int size);

	/**
	*	Creates a new placeholder and returns the handle to it.
	*/
	MAHandle maCreatePlaceholder();

	/**
	* Destroys an object of any type. The handle becomes a placeholder.
	*/
	void maDestroyObject(in MAHandle handle);

	/**
	* Returns the size, in bytes, of a data object.
	*/
	int maGetDataSize(in MAHandle data);
	/**
	* Reads \a size bytes from a data object, starting at \a offset,
	* into memory pointed to by \a dst.
	* \warning Do not attempt to read zero bytes or out of bounds;
	* it is not supported and will result in a MoSync Panic.
	*/
	void maReadData(in MAHandle data, out MAAddress dst, in int offset, in int size);
	/**
	* Writes \a size bytes to a data object, starting at \a offset,
	* from memory pointed to by \a src.
	*/
	void maWriteData(in MAHandle data, in MAAddress src, in int offset, in int size);

	/**
	* \brief Parameters for the maCopyData() function.
	*/
	struct MACopyData {
		MAHandle dst;
		int dstOffset;
		MAHandle src;
		int srcOffset;
		int size;
	}
	/**
	* Copies \a size bytes from data object \a src to \a dst, at the specified offsets.
	*/
	void maCopyData(in MACopyData params);

	constset int MAS_ {
		CREATE_IF_NECESSARY = 1;
		//SHARED 2
		//SHARED_WRITE 4
	}

	constset int STERR_ {
		/// Generic error.
		GENERIC = -2;
		/// The storage medium is full.
		FULL = -3;
		/// The store does not exist.
		NONEXISTENT = -5;
	}

	/**
	* Opens a permanent data store, optionally creates one if it doesn't exist already.
	*
	* Returns a Store MAHandle on success.
	* Returns #STERR_NONEXISTENT if !(flags & #MAS_CREATE_IF_NECESSARY) and the store does not exist.
	* Returns another \link #STERR_GENERIC STERR \endlink code if the store could not be opened
	* for another reason.
	*
	* \param name The name of the store. A store name must have from 1 to 32 characters,
	* and must not contain any of the following characters: "/\\:;?*'
	* \param flags A combination of \link #MAS_CREATE_IF_NECESSARY MAS \endlink flags, or zero.
	*/
	MAHandle maOpenStore(in MAString name, in int flags);
	/**
	* Writes the contents of a data object to a store. Destroys any data previously in the store.
	* Returns \> 0 on success, #STERR_FULL if the storage system is full,
	* or another \link #STERR_GENERIC STERR \endlink code if the write failed for another reason.
	* \param store The store to write to.
	* \param data The data object to read from.
	*/
	int maWriteStore(in MAHandle store, in MAHandle data);
	/**
	* Creates a data object and copies the contents of a store to it.
	* Use maGetDataSize to get the size of the data.
	* \param store The store to read from.
	* \param placeholder The placeholder handle where a data object will be created.
	* \returns RES_OK if succeded and RES_OUT_OF_MEMORY if failed.
	*/
	int maReadStore(in MAHandle store, in MAHandle placeholder);
	/**
	* Closes a store. Also deletes that store if \a _delete is non-zero.
	*/
	void maCloseStore(in MAHandle store, in int _delete);

	constset int CONNERR_ {
		/// Generic error.
		GENERIC = -2;
		/// The maximum number of open connections allowed has been reached.
		MAX = -3;
		/// DNS resolution error.
		DNS = -4;
		/// Internal error. Please report any occurrences.
		INTERNAL = -5;

		/** \brief The connection was closed by the remote peer.
		*
		* Happens when HTTP servers finish sending data.
		*/
		CLOSED = -6;

		/// You attempted to write to a read-only connection.
		READONLY = -7;
		/// The OS does not trust you enough to let you open this connection.
		FORBIDDEN = -8;
		/// No operation has been started yet.
		UNINITIALIZED = -9;
		/// The Content-Length header could not be found.
		CONLEN = -10;
		/// You supplied a malformed URL.
		URL = -11;
		/// The protocol is not available.
		/// If a Bluetooth function returns this, the Bluetooth chip is turned off.
		UNAVAILABLE = -12;
		/// You canceled the operation.
		CANCELED = -13;
		/// The server gave an invalid response.
		PROTOCOL = -14;
		/// The network connection could not be established.
		NETWORK = -15;
		/// The requested header could not be found.
		NOHEADER = -16;
		/// The requested object could not be found.
		NOTFOUND = -17;
		/// An error occurred during SSL negotiation.
		SSL = -18;

		/**
		* If you wish to share the CONNERR codespace,
		* use values below this for your own error codes.
		*/
		USER = -1000000;
	}
	constset int CONNOP_ {
		READ = 1;
		WRITE = 2;
		CONNECT = 7;	//READ | WRITE | 4
		FINISH = 11;	//READ | WRITE | 8
		ACCEPT = 16;
	}
	constset int CONN_ {
		/// The maximum number of open connections allowed.
		MAX = 32;
	}

	/**
	* Asynchronously opens a connection using the specified URL.
	* A URL takes the following form:
	* <tt>\<protocol\>://\<address\>[:\<port\>]\<parameters\></tt>\n
	* The following protocols are supported:
	*
	* <tt>socket</tt>, which is TCP. It has no parameters.
	*
	* <tt>ssl</tt>, which is an encrypted TCP connection. It has no parameters.
	*
	* <tt>http</tt>, which is HTTP/1.0 GET. When using HTTP, you need not specify the port;
	* it defaults to port 80.
	*
	* Its parameters is the document path (for example, "/index.html").
	* You must specify a path, or this function will fail with #CONNERR_URL.
	* The minimal path ("/") is acceptable.
	*
	* Writing to a http connection is not allowed.
	*
	* <tt>https</tt>, which is an encrypted HTTP GET. It has the same parameters as <tt>http</tt>.
	*
	* <tt>btspp</tt>, which is Bluetooth Serial Port. It has no parameters.
	*\n
	*\n
	* For the <tt>socket</tt> and <tt>http</tt> protocols, \a \<address\> can be either a decimal,
	* dot-delimited (.) IPv4 address or a standard Domain Name,
	* while \a \<port\> is a decimal number from 1 to 65535.
	*
	* In the <tt>socket</tt> protocol, certain ports are protected on certain platforms and
	* cannot be used, most notably port 80 on Java ME. In this case, use http instead.
	*
	* On a few devices, using ports numbered below 1024 may cause system crashes.
	* Therefore, it is advisable to use ports above 1024 if you can choose.
	*
	* On some J2ME devices, connections to port 443 (except from https) is not
	* allowed and might cause a system exception.
	*
	* For the <tt>btspp</tt> protocol, \a \<address\> is 12 hexadecimal digits and
	* \<port\> is a decimal number from 1 to 30.
	*
	* Example TCP url: <tt>socket://www.example.com:23</tt>
	*
	* Example SSL url: <tt>ssl://www.example.com:22</tt>
	*
	* Example HTTP url: <tt>http://www.example.com/directory/document.html</tt>
	*
	* Example HTTPS url: <tt>https://www.example.com/directory/document.html</tt>
	*
	* Example Bluetooth url: <tt>btspp://001dbe15e455:9</tt>
	*
	* You can also use MAUtil::BluetoothConnection to connect via Bluetooth service uuid.
	*
	* To find useful Bluetooth addresses, use the Bluetooth discovery API.
	* See maBtStartDeviceDiscovery().
	*
	*
	* The result of the operation will be delivered in a CONN event, with
	* MAConnEventData::opType set to #CONNOP_CONNECT.
	*
	* The success value is \> 0. For the <tt>http</tt> protocol,
	* the success value is the HTTP response code.
	*
	*
	* When you're done with the connection, maConnClose() must be called to free
	* the resources associated with the handle. This must be done even if
	* the connect operation failed.
	*
	* There is a limit of #CONN_MAX open connection handles at any time, so if you keep
	* opening connections without closing them, you'll eventually receive the
	* #CONNERR_MAX error code instead of new connection handles.
	*
	* Alternatively, this function can be called with one of these url types to
	* create a Server Connection:\n
	* <tt>socket://[:\<port\>]</tt>, for TCP.\n
	* <tt>btspp://localhost:\<uuid\>[;name=\<YourServiceName\>]</tt>, for Bluetooth.\n
	* \<uuid\> is a 32-digit hexadecimal number. It will be used to create the
	* service record. Its MAUUID representation can be used by clients to search for
	* this service.
	*
	* Example Bluetooth server url:
	* <tt>btspp://localhost:0000110100001000800000805F9B34FB;name=Serial Port</tt>
	*
	* Server connections are created synchronously; no CONN event is generated,
	* and as soon as this function returns, it's done.
	*
	* A server connection can not be read from or written to, but it can be closed.
	* You can also use it in calls to maAccept() and maConnGetAddr().
	*
	* \returns The connecting handle \>0, or one of the \link #CONNERR_GENERIC CONNERR \endlink values.
	* \see maGetEvent()
	* \see \ref connApiOverview
	*/
	MAHandle maConnect(in MAString url);

	/**
	* Closes a connection, freeing any resources associated with the handle.
	*
	* Cancels any active operations on the connection.
	* Such operations will finish with #CONNERR_CANCELED.
	*/
	void maConnClose(in MAHandle conn);

	/**
	* Asynchronously reads at least one and at most \a size bytes from a connection to memory.
	*
	* The result of the operation will be delivered in a CONN event, with
	* MAConnEventData::opType set to #CONNOP_READ.
	* The success value is the number of bytes read.
	*
	* \see maGetEvent
	* \see \ref connApiOverview
	*/
	void maConnRead(in MAHandle conn, out MAAddress dst, in int size);

	/**
	* Asynchronously writes \a size bytes to a connection from memory.
	*
	* The result of the operation will be delivered in a CONN event, with
	* MAConnEventData::opType set to #CONNOP_WRITE.
	* The success value is \> 0.
	*
	* \warning The source data must remain available until the operation is complete,
	* so if it was dynamically allocated, don't free it too early.
	* \see maGetEvent
	* \see \ref connApiOverview
	*/
	void maConnWrite(in MAHandle conn, in MAAddress src, in int size);

	/**
	* Asynchronously reads at least one and at most \a size bytes from a connection to
	* a data object, starting at the specified offset.
	* During the read, the data object being written to will be in flux.
	* Any attempt to access it will result in a Panic.
	*
	* The result of the operation will be delivered in a CONN event, with
	* MAConnEventData::opType set to #CONNOP_READ.
	* The success value is is the number of bytes read.
	*
	* \see maGetEvent
	* \see \ref connApiOverview
	*/
	void maConnReadToData(in MAHandle conn, in MAHandle data, in int offset, in int size);

	/**
	* Asynchronously writes \a size bytes to a connection from a data object,
	* starting at the specified offset.
	* During the write, the data object being read from will be in flux.
	* Any attempt to access it will result in a Panic.
	*
	* The result of the operation will be delivered in a CONN event, with
	* MAConnEventData::opType set to #CONNOP_WRITE.
	* The success value is \> 0.
	*
	* \see maGetEvent
	* \see \ref connApiOverview
	*/
	void maConnWriteFromData(in MAHandle conn, in MAHandle data, in int offset, in int size);

	/**
	* \brief An address for the TCP/IPv4 protocol.
	*/
	struct MAConnAddrInet4 {
		int addr;
		int port;
	}

	constset int BTADDR_ {
		LEN = 6;
	}

	/**
	* \brief A Bluetooth device address.
	*/
	struct MABtAddr {
		byte a[BTADDR_LEN];
	}


	/**
	* \brief An address for the Bluetooth Serial Port protocol.
	*/
	struct MAConnAddrBt {
		int port;
		MABtAddr addr;
	}

	constset int CONN_FAMILY_ {
		INET4 = 1;
		BT = 2;
	}

	/**
	* \brief A connection address.
	*/
	struct MAConnAddr {
		/// One of the CONN_FAMILY constants
		int family;
		union {
			MAConnAddrInet4 inet4;
			MAConnAddrBt bt;
		}
	}

	/**
	* Retrieves the address of a connection. On server connections,
	* you'll get the local address. On normal connections, you'll get the remote address.
	*
	* You can pass #HANDLE_LOCAL to retrieve the local address.
	* In that case, you must set MAConnAddr::family before calling this function,
	* to tell it which address to retrieve. Also, the port member is not set.
	*
	* \returns \< 0 on error.
	*/
	int maConnGetAddr(in MAHandle conn, out MAConnAddr addr);

	constset int HTTP_ {
		GET = 1;
		POST = 2;
		HEAD = 3;
		PUT = 4;
		DELETE = 5;
	}

	/**
	* Creates an unfinished HTTP/1.0 connection. You cannot read from this connection
	* until it's been Finished. Before then, you can set request headers. After,
	* you can get response headers.

	* POST connections are special; they let you write to the connection before
	* it's Finished. The first write causes the underlying TCP connection to be
	* established and request headers transmitted. After the first write has
	* begun, you may no longer set request headers.

	* \param url An HTTP or HTTPS URL. See maConnect() for the exact form.
	* \param method #HTTP_GET, #HTTP_POST, #HTTP_HEAD, #HTTP_PUT or #HTTP_DELETE.
	* \returns An unfinished HTTP connection handle \>0, or a
	* \link #CONNERR_GENERIC CONNERR \endlink value.
	* \see maHttpFinish
	*/
	MAHandle maHttpCreate(in MAString url, in int method);

	/**
	* Sets a request header of an HTTP connection.
	*
	* Overwrites any existing header with the same key. The keys is case-insensitive.
	*
	* If the connection's method is #HTTP_POST, it must not have been written to.
	* \param conn An unfinished HTTP connection handle.
	* \param key The name of the header.
	* \param value The new value of the header.
	*/
	void maHttpSetRequestHeader(in MAHandle conn, in MAString key, in MAString value);

	/**
	* Stores an HTTP response header in the specified buffer.
	*
	* The buffer may be too small to contain the header and the terminating zero;
	* in that case, the buffer will not be filled
	* and you should create a bigger buffer and call this function again.
	* Use the return value to determine how long the buffer needs to be.
	*
	* \param conn A finished HTTP connection handle.
	* \param key The name of the header. Case-insensitive.
	* \param buffer A string buffer.
	* \param bufSize The size of the buffer, in bytes.
	* \returns The length of the header value, excluding the terminating zero, or
	* #CONNERR_NOHEADER if the header doesn't exist.
	*/
	int maHttpGetResponseHeader(in MAHandle conn, in MAString key,
		out MAString buffer range("bufSize"), in int bufSize);


	//not needed yet
	//int maHttpGetResponseMessage(in MAHandle conn, out MAString buffer, in int bufSize);
	//int maHttpGetRequestHeader(in MAHandle conn, in MAString key, out MAString buffer, in int bufSize);


	/**
	* Asynchronously finishes an HTTP connection. This entails making the
	* underlying TCP connection and sending request headers, unless that has
	* already been done by a #HTTP_POST write, and receiving the response headers.
	*
	* The result of the operation will be delivered in a CONN event, with
	* MAConnEventData::opType set to #CONNOP_FINISH.
	* The success value is the HTTP response code.
	*
	* \param conn An unfinished HTTP connection handle.
	* \see maGetEvent
	* \see \ref connApiOverview
	*/
	void maHttpFinish(in MAHandle conn);

	/**
	* Loads a new object array from the a data object. The old object array is overwritten,
	* except where the new array has SKIP objects. In those cases, the old objects are saved.
	* Returns zero on error, \>0 on success. On error, the old object array remains unchanged.
	* \param data The data object containing new resources, in the format of a MoSync
	* compiled resource file.
	* \note There must not be any UBIN objects in the new array,
	* except those of the old array that were SKIP'd.
	*/
	int maLoadResources(in MAHandle data);

	/**
	* Loads a new program from the a data object, closes the running program, and starts the new one.
	* The format of the data object is a MoSync program file concatenated with a resource file.
	* If this function returns, there was an error.
	*
	* \param data The data object containing the new program.
	* \param reload If non-zero, the original program will be reloaded after the new program has
	* exited. If zero, MoSync will exit when the loaded program exists, unless that program,
	* or one of its sub-programs, calls this function with \a reload set to non-zero.
	*
	* \note A program that was loaded with this function cannot be reloaded; instead, it will
	* always be the very first program in the chain that is reloaded.
	* \note The stored reload flag is or'd with the one provided to each call to this function.
	* It is also reset when the reload occurs.
	* \note Thus, if one program loads another with reload on, and the loaded program loads another
	* with reload off, the original program will still be reloaded when the last one exits.
	* Should the original program decide to exit after being reloaded, it will not be reloaded again.
	*
	* \note The \link #EVENT_TYPE_CLOSE close event \endlink will disable the reload mechanism.
	*/
	void maLoadProgram(in MAHandle data, in int reload);

	constset int MAK_ {	//MobileAuthor Keys

		// start of ascii mapped key codes

		UNKNOWN			= 0;
		FIRST			= 0;
		BACKSPACE		= 8;
		TAB				= 9;
		CLEAR			= 12;
		RETURN			= 13;
		PAUSE			= 19;
		ESCAPE			= 27;
		SPACE			= 32;
		EXCLAIM			= 33;
		QUOTEDBL		= 34;
		POUND			= 35;
		HASH			= 35;
		GRID			= 35;
		DOLLAR			= 36;
		AMPERSAND		= 38;
		QUOTE			= 39;
		LEFTPAREN		= 40;
		RIGHTPAREN		= 41;
		ASTERISK		= 42;
		STAR			= 42;
		PLUS			= 43;
		COMMA			= 44;
		MINUS			= 45;
		PERIOD			= 46;
		SLASH			= 47;

		//Warning: do not disrupt the sequence of number keys!
		0				= 48;
		1				= 49;
		2				= 50;
		3				= 51;
		4				= 52;
		5				= 53;
		6				= 54;
		7				= 55;
		8				= 56;
		9				= 57;

		COLON			= 58;
		SEMICOLON		= 59;
		LESS			= 60;
		EQUALS			= 61;
		GREATER			= 62;
		QUESTION		= 63;
		AT				= 64;

		LEFTBRACKET		= 91;
		BACKSLASH		= 92;
		RIGHTBRACKET	= 93;
		CARET			= 94;
		UNDERSCORE		= 95;
		BACKQUOTE		= 96;

		// lower case ascii codes

		A				= 97;
		B				= 98;
		C				= 99;
		D				= 100;
		E				= 101;
		F				= 102;
		G				= 103;
		H				= 104;
		I				= 105;
		J				= 106;
		K				= 107;
		L				= 108;
		M				= 109;
		N				= 110;
		O				= 111;
		P				= 112;
		Q				= 113;
		R				= 114;
		S				= 115;
		T				= 116;
		U				= 117;
		V				= 118;
		W				= 119;
		X				= 120;
		Y				= 121;
		Z				= 122;

		// eof lower case ascii codes

		DELETE			= 127;

		// eof ascii mapped key codes

		// Numeric keypad
		//Warning: do not disrupt the sequence of number keys!
		KP0				= 256;
		KP1				= 257;
		KP2				= 258;
		KP3				= 259;
		KP4				= 260;
		KP5				= 261;
		KP6				= 262;
		KP7				= 263;
		KP8				= 264;
		KP9				= 265;

		KP_PERIOD		= 266;
		KP_DIVIDE		= 267;
		KP_MULTIPLY		= 268;
		KP_MINUS		= 269;
		KP_PLUS			= 270;
		KP_ENTER		= 271;
		KP_EQUALS		= 272;

		UP				= 273;
		DOWN			= 274;
		RIGHT			= 275;
		LEFT			= 276;
		INSERT			= 277;
		HOME			= 278;
		END				= 279;
		PAGEUP			= 280;
		PAGEDOWN		= 281;

		FIRE			= 284;
		SOFTLEFT		= 285;
		SOFTRIGHT		= 286;

		PEN				= 291;
		BACK = 292;
		MENU = 293;

		RSHIFT			= 303;
		LSHIFT			= 304;
		RCTRL			= 305;
		LCTRL			= 306;
		RALT			= 307;
		LALT			= 308;

		SEARCH			 = 309;
	}

	constset int MAKB_ { // Key Bits
		LEFT		= 0x00001;
		UP			= 0x00002;
		RIGHT		= 0x00004;
		DOWN		= 0x00008;
		FIRE		= 0x00010;
		SOFTLEFT	= 0x00020;
		SOFTRIGHT	= 0x00040;

		//Warning: do not disrupt the sequence of number keys!
		0			= 0x00080;
		1			= 0x00100;
		2			= 0x00200;
		3			= 0x00400;
		4			= 0x00800;
		5			= 0x01000;
		6			= 0x02000;
		7			= 0x04000;
		8			= 0x08000;
		9			= 0x10000;

		ASTERISK	= 0x20000;
		STAR		= 0x20000;
		HASH		= 0x40000;
		POUND		= 0x40000;
		GRID		= 0x40000;
		CLEAR		= 0x80000;
	}

	/**
	* Returns a bitmask consisting of \link #MAKB_LEFT MAKB \endlink flags describing the current
	* key state.
	*/
	int maGetKeys();

	constset int EVENT_ {
		BUFFER_SIZE = 256;
		/// In milliseconds
		CLOSE_TIMEOUT = 2000;
	}
	constset int EVENT_TYPE_ {
		/**
		* This event is posted when the operating system sends MoSync a command to exit.
		* Causes include the OS shutting down and OS-controlled user commands.
		* \see maGetEvent()
		*/
		CLOSE = 1;

		KEY_PRESSED = 2;
		KEY_RELEASED = 3;
		/// Connection
		CONN = 4;
		/// Bluetooth discovery
		BT = 5;
#if IX_GUIDO
		/// Has MAEvent::ked::key be the identifier for the TTS session, as returned by maStartSpeaking().
		TTS = 6;
#endif	//IX_GUIDO
#if IX_WLAN
		/// Uses MAEvent::state.
		WLAN = 7;
#endif	//IX_WLAN

		POINTER_PRESSED = 8;
		POINTER_RELEASED = 9;
		POINTER_DRAGGED = 10;

#if IX_CALL
		/// Has MAEvent::state be one of the \link #CALLSTATE_UNKNOWN CALLSTATE \endlink constants.
		CALL = 11;
#endif	//IX_CALL

		/**
		 * While MoSync doesn't have focus, no key events will arrive and the screen will not be updated.
		 * If the keypad is locked, no application will have focus.
		 * \see maLockKeypad
		 */
		FOCUS_LOST = 13;
		FOCUS_GAINED = 14;

#if IX_STREAMING
		/**
		* Has MAEvent::data point to a MAStreamEventData.
		*/
		STREAM = 15;
#endif	//IX_STREAMING
//#if IX_LOCATION
		/// Has MAEvent::data point to an MALocation.
		LOCATION = 16;

		/// MAEvent::state is one of the \link #MA_LPS_AVAILABLE MA_LPS \endlink constants.
		LOCATION_PROVIDER = 17;
//#endif	//IX_LOCATION
#if IX_AUDIOBUFFER
		/// MAEvent::state is \> 0 when the audio stream is waiting for more data,
		/// or \< 0 on error.
		AUDIOBUFFER_FILL = 18;
#endif
		/** \brief The size of the screen has changed.
		* Use maGetScrSize() to get the new size.
		*
		* If the screen is the current draw target, the clipping rectangle is removed.
		* Use maSetClipRect() to reset it.
		*/
		SCREEN_CHANGED = 21;

		/// Character input. Uses MAEvent::character.
		CHAR = 22;

		/** \brief The text box created by maTextBox() was just closed.
		* Uses MAEvent::textboxResult and MAEvent::textboxLength.
		*/
		TEXTBOX = 23;

		/** \brief The home screen became visible.
		 * Currently implemented only on Android.
		 * \see maHomeScreenEventsOn()
		 */
		HOMESCREEN_SHOWN = 24;

		/** \brief The home screen was hidden because an
		 * application came to front.
		 * Currently implemented only on Android.
		 * \see maHomeScreenEventsOn()
		 */
		HOMESCREEN_HIDDEN = 25;

		/** \brief The screen was turned on (the device
		 * went out of sleep state).
		 * Currently implemented only on Android.
		 * \see maScreenActivateEventsOn()
		 */
		SCREEN_STATE_ON = 26;

		/** \brief The screen was turned off (the device
		 * went into sleep state).
		 * Currently implemented only on Android.
		 * \see maScreenActivateEventsOn()
		 */
		SCREEN_STATE_OFF = 27;

		/**
		* \brief An event sent from a native widget.
		* \par The application can use the MAEvent.data field to access
		* widget event data, which is of type MAWidgetEventData.
		* For example: \n
		* \code MAWidgetEventData* widgetEventData = (MAWidgetEventData*) event.data; \endcode
		* \see MAWidgetEventData
		*/
		WIDGET = 28;

		/** \brief The bluetooth chip was turned off.
		* Bluetooth functions will return #CONNERR_UNAVAILABLE.
		* Currently implemented only on Android.
		*/
		BLUETOOTH_TURNED_OFF = 29;

		/** \brief The bluetooth chip was turned on.
		* Bluetooth functions will now work normally again.
		* Currently implemented only on Android.
		*/
		BLUETOOTH_TURNED_ON = 30;

		/**
		* \brief The ImagePicker dialog was dismissed either by Cancel, either by OK.
		*/
		IMAGE_PICKER = 31;

		/** \brief SMS result message.
		* The field status contains one of the
		* This event is sent on Android and iOS.
		*/
		SMS = 32;

		/**
		* \brief Provides data from active sensors.
		* \see MAEvent::sensor
		* \see maSensorStart()
		*/
		SENSOR = 33;

		/**
		* \bried The maAlert message box was dismissed by one of the available buttons.
		* See #EVENT_TYPE_ALERT for the event.
		*/
		ALERT = 34;

		/** \brief A new NFC tag was received
		* A new tag has been received, use maGetNextTag to
		* retreive it.
		*/
		NFC_TAG_RECEIVED = 35;

		/** \brief New tag data was read
		* An asynchronous NFC tag read operation was
		* completed.
		*/
		NFC_TAG_DATA_READ = 36;

		/** \brief New tag data was written
		* An asynchronous NFC tag write operation was
		* completed.
		*/
		NFC_TAG_DATA_WRITTEN = 37;

		/** \brief A batch operation was performed
		*/
		NFC_BATCH_OP = 38;

		/** \brief Tag authentication was performed
		* An asynchronous NFC tag authentication read was
		* completed.
		*/
		NFC_TAG_AUTH_COMPLETE = 39;

		/**
		* \brief Tag was made read only
		*  An asynchronous NFC tag read only operation was completed.
		*/
		NFC_TAG_READ_ONLY = 40;

		/**
		* Send by maOptionsBox dialog when one of the option buttons is clicked.
		*/
		OPTIONS_BOX_BUTTON_CLICKED = 41;
	}

	/**
	* \brief Data for a connection event, including an indicator or success or failure.
	*/
	struct MAConnEventData {
		/// The handle to the connection associated with the event.
		MAHandle handle;
		/// One of the \link #CONNOP_READ CONNOP \endlink constants.
		int opType;
		/// A success value \> 0 or a \link #CONNERR_GENERIC CONNERR \endlink code.
		int result;
	}

	/**
	* \brief A structure containing the sensor type and the data sent to the event.
	*/
	struct MASensor {
		int type;
		float values[3];
	}

	/**
	* \brief An event containing the result of an NFC asynchronous operation
	*/
	struct MANFCEventData {
		/// The handle this event pertains to.
		MAHandle handle;
		/// The result of the asynchronous operation, usually a length if >= 0,
		/// or an error code of < 0.
		int result;
		/// The destination of any read or write operation. Could be a memory
		/// address, a block number, or some other value depending on the operation.
		int dstId;
	}

	/**
	* \brief An event; a message indicating that something has happened, e.g. that a key has been pressed.
	*/
	struct MAEvent {
		/**
		* One of the \link #EVENT_TYPE_CLOSE EVENT_TYPE \endlink constants.
		*/
		int type;
		union {
			struct {
				/**
				* In KEY events, this will be one of the \link #MAK_UNKNOWN MAK \endlink constants.
				*/
				int key;
				/**
				* In KEY events, this will be the native keycode.
				*/
				int nativeKey;
			} ked;

			/**
			* In CHAR events, this is the Unicode character that was received.
			*/
			uint character;

			struct {
				/**
				* In POINTER events, this will be the location of the pointer.
				*/
				MAPoint2d point;

				/**
				* In POINTER events, this will be the finger triggering the event.
				*/
				int touchId;
			} pointer;

			/**
			* In \link #EVENT_TYPE_BT BT \endlink events, this will be a value \>= 0 or
			* one of the \link #CONNERR_GENERIC CONNERR \endlink constants.
			*/
			int state;

			/**
			* Valid only in CONN events.
			*/
			MAConnEventData conn;

			struct {
				/**
				* One of the \link #MA_TB_RES_OK MA_TB_RES \endlink codes.
				*/
				int textboxResult;
				/**
				* The length, in characters, of the finished text.
				* Does not include the terminating zero.
				*/
				int textboxLength;
			} textbox;

			struct {
				/**
				 * #EVENT_TYPE_IMAGE_PICKER events, this will be 0 if canceled or 1 if Ok was pressed.
				 */
				int imagePickerState;

				/**
				* #EVENT_TYPE_IMAGE_PICKER event, contains the new handle to the selected image.
				*/
				MAHandle imagePickerItem;
			} imagePicker;

			/**
			* #EVENT_TYPE_OPTIONS_BOX_BUTTON_CLICKED event, contains the index of the selected option.
			*/
			int optionsBoxButtonIndex;

			/**
			* #EVENT_TYPE_ALERT event. The index of the selected button.
			* If button1 is pressed, the value is 1.
			* If button2 is pressed, the value is 2.
			* If button3 is pressed, the value is 3.
			*/
			int alertButtonIndex;

			/**
			* In #EVENT_TYPE_SMS events, this will be one of the
			* @link #MA_SMS_RESULT_SENT MA_SMS_RESULT_* @endlink constants.
			*/
			int status;

			/**
			* Valid in \link #EVENT_TYPE_SENSOR SENSOR \endlink events.
			*/
			MASensor sensor;

			/**
			* NFC event data
			*/
			MANFCEventData nfc;

			/**
			* Used by custom events. See invididual event descriptions.
			*/
			void* data;
		}
	}

	/**
	* There is a FIFO buffer that contains up to #EVENT_BUFFER_SIZE events.
	* Each event has a type. Some types have additional data.
	*
	* This function retrieves the next event, unless the queue is empty.
	* Use maWait() to wait until more events are available.
	* \param event Pointer to an MAEvent struct that will be filled with the next event.
	*
	* When the \link #EVENT_TYPE_CLOSE Close event \endlink is posted,
	* you must call maExit as soon as possible, or
	* your program will be forcibly terminated. The timeout is device-dependent, but
	* never longer than #EVENT_CLOSE_TIMEOUT milliseconds.
	*
	* After the Close event has been posted, most syscalls will stop working,
	* returning default values and doing nothing.
	* Only the following groups of functions are guaranteed to remain operational:
	* Memory management, math, Resource management, Store, time, logging, maExit() and maPanic().
	*
	* \note Not all platforms have the capability to generate a Close event.
	* You must always provide another way for the user to exit your application.
	*
	* \returns \> 0 on success, or zero if the buffer is empty.
	*/
	int maGetEvent(out MAEvent event);

	/**
	* Suspends execution until there is an event in the buffer,
	* or \a timeout milliseconds have passed. A timeout <= 0 is considered infinite.
	* Timer accuracy is platform-specific, but should be better than 20 ms.
	*
	* Use this function rather than idle loops to save CPU/battery power.
	* \see maGetEvent()
	*/
	void maWait(in int timeout);

	/**
	* Returns the number of seconds that have passed since
	* 00:00:00, Jan 1st, 1970, UTC, according to the device clock.
	*/
	int maTime();
	/**
	* Returns the number of seconds that have passed since
	* 00:00:00, Jan 1st, 1970, local time, according to the device clock.
	*/
	int maLocalTime();
	/**
	* Returns the number of milliseconds that has passed since some unknown point in time.
	* Accuracy is platform-specific, but should be better than 20 ms.
	*/
	int maGetMilliSecondCount();

	/**
	* Returns an approximation to the amount of memory currently available for
	* allocating new objects, measured in bytes.
	*
	* There may be more memory available than reported by this function. Conversely,
	* in the time between calling this function and allocating an object, another program
	* may have allocated an object of its own, decreasing the available memory.
	*
	* The amount of memory required to allocate any specific object is device-dependent.
	*
	* When using this function to determine whether or not to allocate an object, always
	* leave some memory alone for use by the system,
	* preferably about 10% of the device's total memory, as reported by maTotalObjectMemory().
	*/
	int maFreeObjectMemory();

	/**
	* Returns the total amount of memory available to MoSync, measured in bytes.
	* May change over time, even as the program is running.
	*/
	int maTotalObjectMemory();

	/**
	* Switches on the vibrator for the requested number of milliseconds,
	* or switches it off if the requested duration is zero.
	* A call to this function will override the previous call.
	* Returns non-zero if the operation was allowed, zero if it wasn't.\n
	* \n
	* On devices which has no vibrator, this function will always return zero.
	* The user may turn vibration off in phone settings. In that case, calling this function
	* with a duration of zero may return non-zero, but a non-zero duration will return zero.
	* In any case, the only way to conclusively determine if vibration is currently supported
	* or not is to call this function with a duration of at least 1(one) ms.
	* On iPhone the argument won't be taken into account.
	*/
	int maVibrate(in int ms);

	constset int RUNTIME_ {
		/// The MoSync Reference Environment, also known as the Emulator.
		MORE = 1;
		/// Java ME
		JAVA = 2;
		/// Symbian
		SYMBIAN = 3;
		/// Windows CE, also known as Windows Mobile.
		WINCE = 4;
	}

	constset int REPORT_ {
		/// Caused by a MoSync Panic. MAPanicReport::code is the panic code.
		PANIC = 1;
		/// Caused by a native exception. MAPanicReport::string describes the exception.
		EXCEPTION = 2;
		/// Caused by a platform-specific error. MAPanicReport::code is valid.
		PLATFORM_CODE = 3;
		/// Caused by a call to maPanic(). MAPanicReport::code and MAPanicReport::string are the
		/// parameters from the call.
		USER_PANIC = 4;
		/// Caused by the Close event timeout. Neither code or string are valid.
		TIMEOUT = 5;
	}

	/**
	* \brief A MoSync Panic or other unrecoverable error.
	*
	* In MoSync Debug builds, when such an error occurs, the runtime writes
	* an instance of this structure to a Store named "panic.report".
	*
	* The length of that instance may be greater than sizeof(MAPanicReport),
	* because of the variable-length string that may appear at its end.
	* The member \a string can, then, be longer than the one byte that is declared.
	*
	* To properly read an instance of this struct from a store, you should allocate a
	* chunk of memory whose size is equal to the size of the store, then read the entire store
	* into that chunk of memory. Then you should make a pointer of type MAPanicReport and point it
	* to the chunk. Then you can read normally, using that pointer.
	*
	* \see maOpenStore()
	* \see maPanic()
	* \see malloc()
	*/
	struct MAPanicReport {
		/// The type of MoSync runtime that wrote the report. A \link #RUNTIME_MORE RUNTIME \endlink constant.
		int runtimeId;
		/**
		* The type report. Specifies whether the members \a code and \a string are valid.
		* A \link #REPORT_PANIC REPORT \endlink constant.
		*/
		int reportType;
		/// The time the report was generated. The format is unix time. \see maTime()
		int time;
		/**
		* The value of the MoSync instruction pointer at the time the report was generated.
		* \< 0 if the MoSync core was inaccessible.
		*/
		int ip;

		int code;
		char string[1];
	}

	/**
	* Starts playing a sound.
	*
	* If a sound was already playing, it is stopped.
	*
	* The sound data is formatted as follows: \<mime type\>\<null terminator byte\>\<encoded data\>.
	*
	* The .media directive in the MoSync resource compiler creates this formatting.
	*
	* If you download or generate sound clips dynamically, you'll have to take care
	* of the formatting yourself, or use a library that does it for you,
	* for example MAUtil::AudioDownloader.
	*
	* To play .media resources, use offset 0 and maGetDataSize().
	*
	* Do not touch the resource while it's playing, or there will be... trouble.
	*
	* \returns \>= 0 on success and \< 0 on failure.
	*
	* \param sound_res The data object in which the sound is stored.
	* \param offset The offset in the data object where the sound is stored.
	* \param size The size of the sound data.
	*/
	//TODO: make the sound resource go into flux while playing.
	int maSoundPlay(in MAHandle sound_res, in int offset, in int size);

	/**
	* Stops the sound and rewinds it.
	*/
	void maSoundStop();

	/**
	* Returns \> 0 if sound is playing, zero if it's not.
	*/
	int maSoundIsPlaying();

	/**
	* Returns the volume, in the range 0-100, used by the sound engine.
	* The initial volume is 100.
	*/
	int maSoundGetVolume();

	/**
	* Sets the volume, which is a value in the range 0-100. All other values will be clamped
	* to the allowed range.
	*/
	void maSoundSetVolume(in int vol);


	/**
	* Invokes an extension function. Normally you don't call this function directly.
	*/
	ioctl maInvokeExtension {}

	/**
	* These functions are available only on certain platforms.
	* Returns -1 if the function is not available.
	*/
	ioctl maIOCtl {

#if IX_RESOURCE_TYPES
	constset int RT_ {  //WARNING: must match the resource compiler.
		PLACEHOLDER = 1;
		IMAGE = 2;
		SPRITE = 3;
		BINARY = 4;
		UBIN = 5;
		SKIP = 6;
		LABEL = 9;
		FLUX = 127;
	}

#endif	//IX_RESOURCE_TYPES

		constset int FONT_TYPE_{
			SERIF = 0;
			SANS_SERIF = 1;
			MONOSPACE = 2;
		}

		constset int FONT_STYLE_{
			NORMAL = 0;
			BOLD = 1;
			ITALIC = 2;
		}

		/**
		* The available result codes for fonts.
		*/
		constset int RES_FONT_{
			/**
			* \brief Indicates that the call to a font syscall was successful.
			*/
			OK = 1;

			/**
			* \brief Indicates that an invalid font handle was passed.
			*/
			INVALID_HANDLE = -1;

			/**
			* \brief Indicates that the index was off the list size.
			*/
			INDEX_OUT_OF_BOUNDS = -2;

			/**
			* \brief Indicates that a default font with that combination does not exist.
			*/
			NO_TYPE_STYLE_COMBINATION = -3;

			/**
			* \brief Indicates that there is no font with that name on the device.
			*/
			NAME_NONEXISTENT = -4;

			/**
			* \brief Indicates that maFontGetCount() was not called first.
			*/
			LIST_NOT_INITIALIZED = -5;

			/**
			* \brief Indicates that the buffer is not big enough to store the font name.
			*/
			INSUFFICIENT_BUFFER = -6;

			/**
			* \brief Indicates that an invalid size was passed.
			*/
			INVALID_SIZE = -7;

			/**
			* \brief Indicates that the font cannot be deleted because it is in use.
			*  maFontDelete(handle)  fails with this return code.
			*/
			DELETE_DENIED = -8;
		}

		/**
		* Returns a handle to one of the default fonts of the device, in the style and size you specify.
		* \param 'type' The type of the font, can be FONT_TYPE_[SANS_SERIF,SERIF,MONOSPACE].
		* \param 'style' The style of the font, can be FONT_STYLE_[NORMAL,BOLD,ITALIC].
		* \param 'size' The size of the font.
		* \return The handle to the font, RES_FONT_NO_TYPE_STYLE_COMBINATION, or RES_FONT_INVALID_SIZE.
		*/
		MAHandle maFontLoadDefault(in int type, in int style, in int size);

		/**
		* Sets the font to be used with maDrawText and maDrawTextW, and returns the handle
		* to the previous font.
		* \param 'font' an MAHandle for a font object.
		* \return The handle to the previous font, or RES_FONT_INVALID_HANDLE.
		*/
		MAHandle maFontSetCurrent(in MAHandle font);

		/**
		* Returns the number of fonts that are available in the system.
		* \return Number of fonts.
		* \see maFontGetName.
		*/
		int maFontGetCount();

		/**
		* Copies the font postscript name of the given index to the buffer.
		* You must have first called maFontGetCount() at least once before calling this function.
		* \param 'index' A 0-based index to the font.
		* \param 'buffer' An empty char buffer that will receive the font name.
		* \param 'bufferLen' The size of the buffer.
		* \return The number of bytes copied (with terminating NULL) or RES_FONT_INDEX_OUT_OF_BOUNDS
		* 		or RES_FONT_INSUFFICIENT_BUFFER or RES_FONT_LIST_NOT_INITIALIZED.
		* \see maFontGetCount, maFontLoadWithName.
		*/
		int maFontGetName(in int index, out MAString buffer range("bufferLen"), in int bufferLen);

		/**
		* Returns a handle to a font with the specific postscript name and size.
		* \param 'postScriptName' The postscript name of the font.
		* \param 'size' The size of the font.
		* \return Handle to the font, RES_FONT_NAME_NONEXISTENT, or RES_FONT_INVALID_SIZE.
		*/
		MAHandle maFontLoadWithName(in char* postScriptName, in int size);

		/**
		* Deletes a loaded font
		* \param 'font' A font handle
		* \return RES_FONT_OK, RES_FONT_INVALID_HANDLE, or RES_FONT_DELETE_DENIED.
		*/
		int maFontDelete(in MAHandle font);

		/**
		 * Sends the current call stack to the report pipe. Returns 0 if succeeded.
		 */
		int maReportCallStack();

		/**
		* Dumps a string, an int, and the current call stack to the log file. Returns 0 if succeeded.
		*/
		int maDumpCallStackEx(in MAString str, in int data);

		/**
		* Protects a piece of the data memory.
		* Any attempt to write to that piece of memory will raise a panic.
		* \param 'start' The start address of the memory piece to protect.
		* \param 'length' The length of the memory piece to protect.
		*/
		void maProtectMemory(in MAAddress start, in int length);

		/**
		* Unprotects a piece of the data memory.
		* \param 'start' The start address of the memory piece to unprotect.
		* \param 'length' The length of the memory piece to unprotect.
		*/
		void maUnprotectMemory(in MAAddress start, in int length);

		/**
		* Toggles memory protection.
		* \param 'enable' If 1 turns on memory protection, if 0 turns of memory protection.
		*/
		void maSetMemoryProtection(in int enable);

		/**
		* Returns if memory protection is enabled or not.
		* \returns '1' if memory protection is turned on, '0' if it is turned off.
		*/
		int maGetMemoryProtection();

		/**
		* Returns the percentage of battery power remaining. This is an integer between 0 and 100.
		* Currently only available on some Symbian and Windows Mobile phones.
		*/
		int maGetBatteryCharge();

#if IX_GUIDO
		/**
		* Starts reading a text using TextToSpeech. If TTS is already active,
		* the old text is aborted.
		*
		* The system copies the text; it doesn't have to be kept in memory
		* for the duration of the speech.
		*
		* Only the Gui-Do platform supports TTS.
		*
		* \warning Bug: Do not call this immediately when the program starts.
		* The sound stream takes some time to initialize,
		* and if this is called before the initialization is done,
		* an Unhandled Symbian Error (-11) will occur.
		*
		* \returns A unique identifier for the TTS session.
		* TTS events will have a copy of this identifier.
		*/
		int maStartSpeaking(in MAString text);
		/**
		* Aborts TTS.
		*/
		int maStopSpeaking();
		/**
		* Returns \> 0 if TTS is active, zero otherwise.
		*/
		int maIsSpeaking();
		/**
		* Sets the volume of TTS. Returns the previous volume.
		* The volume ranges from 0 to 100. Illegal input values will be capped.
		* The default volume is 100.
		*/
		int maSetSpeechVolume(in int volume);

		/**
		* I'm guessting these range from 0 to 100, but I'm not sure.
		* Try-see if the original values reflect anything interesting.
		*/
		int maSetSpeechSpeed(in int speed);
		int maSetSpeechPitch(in int pitch);

		/**
		* Returns the hyperbolic sine of x.
		* \param x An angle in radians.
		*/
		double sinh(in double x);
		/**
		* Returns the hyperbolic cosine of x.
		* \param x An angle in radians.
		*/
		double cosh(in double x);
		/**
		* Returns the hyperbolic arc tangent of x.
		*/
		double atanh(in double x);
#endif	//IX_GUIDO

		/**
		* Calls on the operating system to lock the phone's keypad.
		* Returns \> 0 if successful.
		*/
		int maLockKeypad();
		/**
		* Calls on the operating system to unlock the phone's keypad.
		* Returns \> 0 if successful.
		*/
		int maUnlockKeypad();
		/**
		* Returns \> 0 if the phone's keypad is locked by the operating system, zero otherwise.
		*/
		int maKeypadIsLocked();

		/**
		* Writes data to the MoSync system log file.
		* Useful only for debugging purposes.
		*/
		int maWriteLog(in MAAddress src, in int size);

		/**
		* \brief Information about a Bluetooth device.
		*/
		struct MABtDevice {
			///in (pointer), out (buffer)
			char* name;
			///in, the length of the buffer pointed to by a name.
			int nameBufSize;
			///out, the length of the name, excluding the terminating zero.
			int actualNameLength;
			///out
			MABtAddr address;
		}

		/**
		* \brief A Universally Unique Identifier.
		*
		* Common Bluetooth UUID values can be found in MAUtil/mauuid.h.
		*/
		struct MAUUID {
			int i[4];
		}

		/**
		* \brief Information about an MABtService object.
		*/
		struct MABtServiceSize {
			/**
			* The buffer size neccesary to contain the full name,
			* or <0 if the service has no name.
			*/
			int nameBufSize;
			/**
			* The number of UUIDs associated with the service.
			*/
			int nUuids;
		}

		/**
		* \brief Information about a Bluetooth service.
		*/
		struct MABtService {
			/**
			* The port number for the service.
			* \see maConnect()
			*/
			int port;
			/**
			* Pointer to a buffer that receives the service's human-readable name.
			*/
			char* name;
			/**
			* The size of the buffer being pointed to by \a name.
			*/
			int nameBufSize;
			/**
			* Pointer to a buffer that receives the UUIDs associated with the service.
			* The buffer must be large enough to contain the number of UUIDs reported
			* by the last call to maBtGetNextServiceSize().
			*/
			MAUUID* uuids;
		}

		/**
		* Starts a device discovery operation.
		*
		* \param names Set this to non-zero to retrieve the names of remote devices.
		* This takes extra time, so set it to zero for faster scanning.
		*
		* \note On Windows, due to a bug in the Microsoft Bluetooth stack,
		* newly discovered devices may appear without names.
		* Re-scanning should make the devices' names appear properly.
		* A workaround is planned for a future release of MoSync.
		*
		* \returns 0 on success, \< 0 on failure.
		*
		* \see maBtGetNewDevice
		* \see maBtCancelDiscovery
		* \see EVENT_TYPE_BT
		*/
		int maBtStartDeviceDiscovery(in int names);

		/**
		* Fills an MABtDevice structure with information about a device.
		* Removes the data from an internal queue filled by maBtStartDeviceDiscovery().
		*
		* If the \a names parameter of maBtStartDeviceDiscovery() was zero,
		* all members of \a d except \a address are ignored and unchanged.
		*
		* The space needed to store the device name and its terminating zero
		* may be greater than a nameBufSize. In that case, the copy is truncated.
		* The maximum length of a device name according to the Bluetooth 2.0 specification
		* is 248 bytes, excluding the terminating zero. However, it's recommended that you
		* don't provide buffers larger than what your application has a use for.
		*
		* Note that you need to fill the MABtDevice structure before passing it
		* as a parameter, otherwise you will get memory access problems.
		*
		* \returns 1 if successful, zero if the queue is empty.
		*/
		int maBtGetNewDevice(out MABtDevice d);

		/**
		* Starts a service discovery operation.
		* Takes a device address and the UUID of the service class to search for.
		* For example, pass #RFCOMM_PROTOCOL_MAUUID and you'll get all connectable services.
		* Pass #SerialPort_Service_MAUUID and you'll get only that type of service.
		*
		* \see maBtGetNextServiceSize
		* \see maBtGetNewService
		* \see maBtCancelDiscovery
		* \see EVENT_TYPE_BT
		*
		* \returns 0 on success, \< 0 on failure.
		*
		* \note Service discovery is not supported on Android. Use MAUtil::BluetoothConnection
		* to connect via service UUID. That method is cross-platform.
		*/
		int maBtStartServiceDiscovery(in MABtAddr address, in MAUUID uuid);

		/**
		* Fills an MABtServiceSize structure with meta-data about the next service.
		* Does not remove the service from the queue.
		* \returns \> 0 on success, or zero if the queue is empty.
		* \see maBtStartServiceDiscovery
		* \see maBtGetNewService
		*/
		int maBtGetNextServiceSize(out MABtServiceSize dst);

		/**
		* Fills an MABtService structure with information about the next service.
		* Removes the data from the internal queue filled by maBtStartServiceDiscovery().
		* \returns \> 0 on success, or zero if the queue is empty.
		* \see maBtGetNextServiceSize
		*/
		int maBtGetNewService(out MABtService dst);

		/**
		* Cancels any active discovery operation.
		* If an operation was canceled, its last BT event will have the state #CONNERR_CANCELED.
		* This is an asynchronous operation. If this function returns 1,
		* it is not safe to start another discovery before
		* you've received the #CONNERR_CANCELED event.
		* \see maBtStartDeviceDiscovery
		* \see maBtStartServiceDiscovery
		* \see EVENT_TYPE_BT
		* \returns 0 if there was no active operation, 1 if there was.
		*/
		int maBtCancelDiscovery();

		/**@}*/

#if IX_WLAN
		constset int WLAN_ADDR_ {
			LEN = 6;
		}
		/**
		* \brief A WLAN address.
		*/
		struct MAWlanAddr {
			byte a[WLAN_ADDR_LEN];
		}

		/**
		* \brief A WLAN access point.
		*/
		struct MAWlanAp {
			/// out
			MAWlanAddr address;
			/// in(ptr), out(content)
			char* name;
			/// in
			int nameBufSize;
			/// out. dBm?
			int signalStrength;
		}

		/**
		* Causes EVENT_TYPE_WLAN. Returns \<0 on failure.
		* WLAN events' state are \>0 when the discovery is complete,
		* 0 when it's still going on, \<0 on error.
		*/
		int maWlanStartDiscovery();

		/**
		* Returns strlen(name) + 1 on success, 0 if no new AP is available, \<0 on failure.
		*
		* If \a dst.nameBufSize is less than the return value, the name is not copied.
		*
		* The IEEE 802.11 WLAN standard specifies that a name may be up to 32 characters long.
		* Your buffer should therefore be at least 33 bytes long,
		* in order to contain a maximum-length name and terminating zero.
		*/
		int maWlanGetNewAp(out MAWlanAp dst);
#endif	//IX_WLAN

		/**
		* \brief A geographical location specified by latitude and longitude, horizontal and vertical accuracy, and altitude.
		*
		* Only if \a state equals #MA_LOC_QUALIFIED do the other members contain valid data.
		*
		* Coordinates are in the WGS84 datum.
		*
		* The horizontal accuracy is the RMS (root mean square) of east accuracy
		* (latitudinal error in meters, 1-sigma standard deviation), north accuracy
		* (longitudinal error in meters, 1-sigma).
		*
		* The vertical accuracy is in meters in vertical direction
		* (orthogonal to ellipsoid surface, 1-sigma standard deviation).
		*
		* Accuracy values may be NaN, if accuracy is unknown.
		*
		* \see maLocationStart()
		*/
		struct MALocation {
			/**
			* The validity of the coordinates.
			* One of the \link #MA_LOC_NONE MA_LOC \endlink constants.
			*/
			int state;
			/*	//disabled
			* The time at which the location was collected.
			* This is the number of seconds that have passed since
			* 00:00:00, Jan 1st, 1970, local time.
			*/
			//int time;
			/*	//disabled
			* The millisecond component of \a time.
			*/
			//int timeMillis;

			double lat;
			double lon;
			double horzAcc;
			double vertAcc;
			float alt;
		}

		constset int MA_LOC_ {
			NONE = 1;
			INVALID = 2;
			UNQUALIFIED = 3;
			QUALIFIED = 4;
		}

		constset int MA_LPS_ {
			/**
			* Availability status code: the location provider is available.
			*/
			AVAILABLE = 1;

			/**
			* Availability status code: the location provider is temporarily unavailable.
			* Temporary unavailability means that the method is unavailable due to reasons
			* that can be expected to possibly change in the future and the provider to
			* become available. An example is not being able to receive the signal because
			* the signal used by the location method is currently being obstructed,
			* e.g. when deep inside a building for satellite based methods.
			* However, a very short transient obstruction of the signal should not cause
			* the provider to toggle quickly between TEMPORARILY_UNAVAILABLE and AVAILABLE.
			*/
			TEMPORARILY_UNAVAILABLE = 2;

			/**
			* Availability status code: the location provider is out of service.
			* Being out of service means that the method is unavailable and the implementation
			* is not able to expect that this situation would change in the near future.
			* An example is when using a location method implemented in an external device and
			* the external device is detached.
			*/
			OUT_OF_SERVICE = 3;
		}

		/**
		* Starts collecting location information.
		* Does nothing if collection is already active.
		* May cause a system popup asking for the user's permission.
		*
		* \link #EVENT_TYPE_LOCATION LOCATION events \endlink will be generated as the
		* estimated location is updated.
		*
		* \link #EVENT_TYPE_LOCATION_PROVIDER LOCATION_PROVIDER events \endlink will be generated
		* when the location provider state changes.
		*
		* \returns MA_LPS_AVAILABLE on success, 0 if collection was already active, or
		* MA_LPS_OUT_OF_SERVICE if the location provider is out of service, or
		* \< 0 on error.
		*
		* \note <b>The location API is experimental, not fully tested.
		* It may not work as advertised.</b>
		*
		* In particular, it is unsupported on the MoSync Emulator.
		* Implementation details are likely to change in the future.
		*/
		int maLocationStart();

		/**
		* Stops collecting location information, and stops generating events.
		* Does nothing if collection is not active.
		*
		* \note \link #EVENT_TYPE_LOCATION Location events \endlink that are generated before
		* this function returns may remain in the event queue afterwards.
		*
		* \returns 0.
		*/
		int maLocationStop();

		/**
		* Requests that the operating system handle (for example, display or install) the indicated URL.
		*
		* If the platform has the appropriate capabilities and resources available,
		* it SHOULD bring the appropriate application to the foreground and let the user
		* interact with the content, while keeping the MoSync application running in the background.
		* If the platform does not have appropriate capabilities or resources available,
		* it MAY wait to handle the request until after the MoSync application exits.
		* In this case, when the requesting MoSync application exits, the platform MUST then bring
		* the appropriate application (if one exists) to the foreground to let the user
		* interact with the content.
		*
		* The URL can be of the form <tt>http://\<address\></tt>, in which case the usual response is
		* to launch the built-in web browser.
		*
		* The URL can also be of the form <tt>tel:\<number\></tt>, in which case the request is
		* interpreted as a request to initiate a voice call to the specified number.
		*
		* If the URL refers to a packaged application
		* (a .JAR file on Java platforms, .SIS on Symbian or .CAB on Windows Mobile),
		* the request is interpreted as a request to install that application.
		*
		* The application being requested can be an update of the calling application.
		* In that case, the calling application must always exit before the request can be processed.
		*
		* \param url The URL for the platform to load.
		* An empty string or NULL cancels any pending requests.
		*
		* \returns \> 0 if maExit() must be called before the request can be processed.
		* 0 if the request is being processed.
		* \< 0 if the request could not be processed.
		* Specifically, the error code #IOCTL_UNAVAILABLE means that the protocol
		* of the request is not supported on the platform.
		*/
		int maPlatformRequest(in MAString url);

		constset int MA_ACCESS_ {
			READ = 1;
			READ_WRITE = 3;
		}

		/**
		* Opens a file handle.
		* If the file exists, the file will be accessible according to the mode specified.
		* If the file does not exist, a handle will still be returned and
		* maFileExists() will return false.
		* The file may then be created by calling maFileCreate().
		*
		* Directories may be opened with this function. They cannot be read or written,
		* but they can be created and deleted, and their existence can be queried.
		* Directory paths must end with a slash('/').
		*
		* Attempting to open an existing directory without ending its path with a slash will fail.
		* Likewise, attempting to open an existing file while ending its path with a slash will also fail.
		* Either case will return #MA_FERR_WRONG_TYPE.
		*
		* \note To avoid memory leaks, all opened handles should be closed using maFileClose().
		*
		* \note To find valid file paths, use maFileListStart().
		*
		* \param path The absolute path to the file.
		* \param mode The access mode. Either #MA_ACCESS_READ or #MA_ACCESS_READ_WRITE.
		* Directories also use these access modes. #MA_ACCESS_READ lets you see if the directory exists.
		* #MA_ACCESS_READ_WRITE also lets you create or delete it.
		* \returns The new file handle, or \< 0 on error.
		*
		* \note If any maFile function other than maFileOpen() fails,
		* the state of the file handle becomes boundedly undefined.
		* This means that any operation on it, other than maFileClose(), may fail.
		*/
		MAHandle maFileOpen(in MAString path, in int mode);

		/**
		* Returns 1 if the file exists, 0 if it doesn't, or \< 0 on error.
		*/
		int maFileExists(in MAHandle file);

		/**
		* Closes a file handle. Returns 0. Panics on error.
		*/
		int maFileClose(in MAHandle file);

		/**
		* Creates a file or directory, given an file handle opened with #MA_ACCESS_READ_WRITE.
		* The file must not exist prior to calling this function.
		* After creation, the file will be accessible for writing and reading.
		* Returns 0 on success, or \< 0 on error.
		*/
		int maFileCreate(in MAHandle file);

		/**
		* Deletes a file or directory.
		* The file must exist prior to calling this function.
		* If it's a directory, it must be empty.
		* Returns 0 on success, or \< 0 on error.
		*/
		int maFileDelete(in MAHandle file);

		/**
		* Returns the size of the file, or \< 0 on error.
		* \note MoSync cannot handle files larger than 2 GiB (2^31 - 1 bytes).
		* \param file A file handle. The file must exist and must not be a directory.
		*/
		int maFileSize(in MAHandle file);

		/**
		* Returns the number of free bytes on the file system on which \a file resides.
		* Note that due to file system overhead, it is not possible to use all of
		* this space for file data.
		* Returns \< 0 on error.
		*/
		int maFileAvailableSpace(in MAHandle file);

		/**
		* Returns the total size, in bytes, of the file system on which \a file resides.
		* Returns \< 0 on error.
		*/
		int maFileTotalSpace(in MAHandle file);

		/**
		* Returns the date/time when the file was last modified, or \< 0 on error.
		* The time format is Unix UTC.
		* \see maTime()
		*/
		int maFileDate(in MAHandle file);

		/**
		* Renames a file.
		*
		* If \a newName does not contain a slash,
		* the file stays in its original directory.
		*
		* If \a newName does contain a slash, it must be a complete pathname,
		* and the file is moved to that path. The new path must be on the same file system
		* as the original path. If it is not, this function fails with #MA_FERR_RENAME_FILESYSTEM.
		* Moving a file to another directory is not supported on Java ME. If it is attempted,
		* this function fails with #MA_FERR_RENAME_DIRECTORY.
		*
		* \returns 0 on success, or \< 0 on error.
		*/
		int maFileRename(in MAHandle file, in MAString newName);

		/**
		* Truncates the file.
		*
		* If \a offset is less than the file's current size,
		* the file's new size is equal to the offset. All data after the offset is discarded.
		*
		* If \a offset is equal to the file's current size, this function does nothing.
		*
		* If \a offset is greater than the file's current size,
		* this function MAY increase the size of the file.
		* You can determine if it did so by calling maFileSeek() with #MA_SEEK_END.
		*
		* If the file's current position is greater than \a offset, it is reset
		* to be equal to \a offset.
		*
		* The file must exist prior to calling this function.
		* Returns 0 on success, or \< 0 on error.
		*/
		int maFileTruncate(in MAHandle file, in int offset);

		/**
		* Write from memory to file.
		* Returns 0 on success, or \< 0 on error.
		*/
		int maFileWrite(in MAHandle file, in MAAddress src, in int len);
		/**
		* Write from data object to file.
		* Returns 0 on success, or \< 0 on error.
		*/
		int maFileWriteFromData(in MAHandle file, in MAHandle data, in int offset, in int len);
		/**
		* Read from file to memory.
		* Returns 0 on success, or \< 0 on error.
		*/
		int maFileRead(in MAHandle file, out MAAddress dst, in int len);
		/**
		* Read from file to data object.
		* Returns 0 on success, or \< 0 on error.
		*/
		int maFileReadToData(in MAHandle file, in MAHandle data, in int offset, in int len);

		/**
		* Returns the file's current position, or \< 0 on error.
		* \param file A file handle. The file must exist and must not be a directory.
		*/
		int maFileTell(in MAHandle file);

		/**
		* Sets the file's position.
		* \param file A file handle. The file must exist and must not be a directory.
		* \param offset The offset of the new position,
		* relative to the position specified by \a whence.
		* \param whence One of the \link #MA_SEEK_SET MA_SEEK \endlink constants.
		* \returns The new position, or \< 0 on error.
		*/
		int maFileSeek(in MAHandle file, in int offset, in int whence);

		constset int MA_SEEK_ {
			/// Beginning of file.
			SET = 0;
			/// Current position.
			CUR = 1;
			/// End of file.
			END = 2;
		}

		constset int MA_FL_SORT_ {
			/// Don't sort the files.
			NONE = 0;
			/// Sort the files by date. See maFileDate().
			DATE = 1;
			/// Sort the files by name. Case-sensitive?
			NAME = 2;
			/// Sort the files by size. See maFileSize().
			SIZE = 3;
		}

		constset int MA_FL_ORDER_ {
			/// Oldest / smallest / A first.
			ASCENDING = 0x10000;
			/// Newest / biggest / Z first.
			DESCENDING = 0x20000;
		}

		/**
		* Creates a listing of names of files and directories, or file systems.
		* Call maFileListNext() repeatedly to retrieve the names. Call maFileListClose() to
		* free the resources used.
		*
		* It is often useful to begin by listing the file systems.
		*
		* \param path The full path to a directory, or the empty string,
		* which specifies that the root file systems should be listed.
		* Which root file systems are listed vary between platforms.
		* \param filter A string to match names with. May include an asterisk ('*') wildcard
		* to represent 0 or more characters. Ignored if \a path is empty.
		* \param sorting One of the \link #MA_FL_SORT_DATE MA_FL_SORT \endlink flags,
		* OR'd with one of the \link #MA_FL_ORDER_ASCENDING MA_FL_ORDER \endlink flags.
		* #MA_FL_SORT_NONE must not be combined with an
		* \link #MA_FL_ORDER_ASCENDING MA_FL_ORDER \endlink flag.
		* \note Sorting is not supported on JavaME. If it is attempted,
		* this function will fail with #MA_FERR_SORTING_UNSUPPORTED.
		*
		* \returns A File Listing handle, or \< 0 on error.
		*/
		MAHandle maFileListStart(in MAString path, in MAString filter, in int sorting);

		/**
		* Writes the name of the next file in the list to the specified buffer.
		*
		* The buffer may be too small to contain the name and the terminating zero;
		* in that case, the internal list pointer remains unchanged,
		* the buffer will not be filled,
		* and you should allocate a bigger buffer and call this function again.
		* You may call this function with NULL and 0 to simply retrieve the length of the name.
		*
		* If the name ends with a slash('/'), it is a directory.
		*
		* \returns The length of the name, excluding the terminating zero,
		* or 0 if there are no more files, or \< 0 on error.
		*/
		int maFileListNext(in MAHandle list, out MAString nameBuf range("bufSize"), in int bufSize);

		/**
		* Closes a file listing, freeing its resources.
		*
		* \returns 0.
		*/
		int maFileListClose(in MAHandle list);

		constset int MA_FERR_ {
			GENERIC = -2;
			NOTFOUND = -3;
			FORBIDDEN = -4;
			RENAME_FILESYSTEM = -5;
			RENAME_DIRECTORY = -6;
			WRONG_TYPE = -7;
			/// The sorting method requested is unsupported on the current platform.
			SORTING_UNSUPPORTED = -8;
		}

		//maybe add support for "hidden" files

		//possible C++ library functions
		//getURL()
		//isDir()
		//getName()
		//getPath()

		/**
		* Sends a text SMS. Since this may cost money for the user,
		* some platforms ask the user for permission,
		* by displaying a modal Yes/No message box.
		*
		* \param dst The phone number to send the message to.
		* \param msg The message to send. Only printable 7-bit ASCII characters are guaranteed
		* to arrive unaltered. 8-bit Latin-1 characters should work in most cases.
		*
		* \returns 0 on success. A \link #CONNERR_GENERIC CONNERR \endlink code \< 0 on error.
		* #CONNERR_FORBIDDEN if the user denied permission, and CONNERR_UNAVAILABLE if the
		* device cannot send SMS messages.
		*
		* \note Will create a text file on PC platforms, instead of sending anything.
		*/
		int maSendTextSMS(in MAString dst, in MAString msg);
		//int maSendBinarySMS(in MAString dst, in Address msg, in int len);

		/**
		* Values for the status field in the #EVENT_TYPE_SMS event.
		* This event is sent on Android and iOS.
		*/
		constset int MA_SMS_RESULT_ {
			/// The SMS was sent.
			SENT = 1;
			/// The SMS was NOT sent.
			NOT_SENT = 2;
			/// The SMS was delivered.
			DELIVERED = 3;
			/// The SMS was NOT delivered.
			NOT_DELIVERED = 4;
		}

#if IX_RECORD
		//These functions are all synchronous,
		//although the handles can be used with asynchronous maConnRead().

		//returns a read-only connection handle. use it with maConnRead(), maRecordStart(), maRecordPause() and maConnClose().
		int maRecordSetup();

		//extension proposal:
		//in int type (audio, video, a/v, photo),
		//in int format (type-dependant. PCM, AMR, MP3, AAC; H.263; JPEG)

		//Note: since the size of data generated is usually unknown,
		//if one wants to write the data to a binary resource,
		//segmented binaries are required if any semblance of performance is to be upheld.
		//See wiki/MoSyncTodo for info on segmented binaries.


		//creates an image, using data from the phone's camera.
		//move this to a camera api?
		//int maRecordSnap(in MAHandle placeholder);	//in ? config (size, zoom, et al)


		//causes the connection to fill with data over time.
		//if it's not read quickly enough, data will be lost or the system will crash.
		int maRecordStart(in MAHandle rec);

		int maRecordPause(in MAHandle rec);
#endif	//IX_RECORD_AUDIO

#if IX_CELLID
		/**
		* \brief Information about the current cell, including country,
		* network and area code and the cell ID.
		*/
		struct MACellInfo {
			/**
			* Mobile Country Code. Identifies the country whose cellular network the phone
			* is connected to.
			*/
			char mcc[4];
			/**
			* Mobile Network Code. Identifies the network operator
			* in the country specified by the MCC.
			*/
			char mnc[8];
			/**
			* Location Area Code. Identifies a geographic area within the cellular network
			* specified by the MCC and MNC.
			*/
			int lac;
			/**
			* Cell ID. Identifies the base station the phone is connected to,
			* within the cellular network specified by the MCC and MNC.
			* \note While a phone may be in range of several base stations at any time,
			* only one of those base stations controls the connection between the phone and
			* the network. That is the base station reported here.
			*/
			int cellId;
		}

		/**
		* Retrieves the current cellular network information.
		* If the phone is offline or otherwise has no signal, this function will fail.
		* \param pInfo A pointer to a struct which will receive the information.
		* \returns 0 if successful. \< 0 otherwise.
		*/
		int maGetCellInfo(out MACellInfo pInfo);
#endif	//IX_CELLID

#if IX_CALL
		//TODO: document these states.
		constset int CALLSTATE_ {
			UNKNOWN = 0;
			IDLE = 1;
			DIALLING = 2;
			RINGING = 3;
			ANSWERING = 4;
			CONNECTING = 5;
			CONNECTED = 6;
			RECONNECTPENDING = 7;
			DISCONNECTING = 8;
			HOLD = 9;
			TRANSFERRING = 10;
			TRANSFERALERTING = 11;
		}

		/**
		* Starts dialing a voice call.
		* Returns 0 on successful beginning of dial, or \< 0 on error,
		* like a call already in progress.
		* Causes CALL events.
		* \param phoneNumber Max length: 100.
		*/
		int maCallDial(in MAString phoneNumber);

		/**
		* Starts answering a voice call. The call state must be #CALLSTATE_RINGING.
		* Returns 0 on successful initialization of the answering process,
		* or \< 0 on error, like if the line is not ringing.
		* Causes CALL events.
		* \note The line state may change while this function is being called. Therefore,
		* it may fail even if you haven't received a new CALL event.
		*/
		int maCallAnswer();

		/**
		* Starts hanging up a voice call, if a call is in progress.
		* Returns 0 if no call is in progress, or on successful beginning of hangup.
		* Returns \< 0 on error.
		* Can cause CALL events.
		*/
		int maCallHangup();
#endif	//IX_CALL

#if IX_STREAMING
		/**
		* Starts playing sound streamed from the specified connection.
		* The connection is made inaccessible for ordinary operations.
		* Causes STREAM events when the state of the streaming changes.
		* The connection is closed when the sound stops.
		* \returns \> 0 on successful start, \< 0 on error.
		* \param conn A readable connection, opened with maConnect() or maHttpCreate().
		* HTTP connections must be Finished to be readable.
		* \param mimeType The MIME type of the sound stream.
		* It can sometimes be retrieved from the HTTP "Content-Type" header.
		*/
		int maSoundPlayConn(in MAHandle conn, in MAString mimeType);

		//TODO: when streaming goes public, make this part of the union instead of custom.
		/**
		* \brief Event data associated with an audio stream.
		*/
		struct MAStreamEventData {
			/// One of the \link #STREAMEVENT_OPEN_COMPLETE STREAMEVENT \endlink constants.
			int event;
			/// The stream associated with the event.
			MAHandle stream;

			/**
			* Positive values denote progress. Negative values denote errors. Zero is not used.
			* \todo Define all possible values. They're currently platform-specific.
			*/
			int result;
		}

		//TODO: equalize over all platforms
		constset int STREAMEVENT_ {
			/// A connection to the streaming server has been established.
			OPEN_COMPLETE = 1;
			/// After this event, you can retrieve information about the stream.
			PREPARE_COMPLETE = 2;
			/// The stream reached its end.
			PLAY_COMPLETE = 3;
			/// Also known as buffering.
			LOADING_STARTED = 4;
			/// After this event, the stream is actually playing.
			LOADING_COMPLETE = 5;
			UNKNOWN_EVENT = 6;
		}

		/**
		* Top-left corner, auto-starts playing.
		* Causes \link #EVENT_TYPE_STREAM STREAM \endlink events.
		* Only one stream is allowed at a time.
		* \param url An RTSP url.
		* \returns A Stream MAHandle \>0, if successful in starting the operation.
		* #IOCTL_UNAVAILABLE if the function is unavailable. \<= -2 on other errors.
		* \todo Define error codes.
		*/
		MAHandle maStreamVideoStart(in MAString url);

		/**
		* Returns the size, in pixels, of the video stream. \<0 if the length cannot be determined.
		*
		* Will only work after #STREAMEVENT_PREPARE_COMPLETE has been received for the stream.
		*/
		MAExtent maStreamVideoSize(in MAHandle stream);

		/**
		* Sets the screen rectangle that the video stream should be shown in.
		* The default rectangle is in the top-left corner of the screen,
		* and has the same size as the source video.
		*
		* Will only work after #STREAMEVENT_PREPARE_COMPLETE has been received for the stream.
		*
		* If the video is playing when you call this function, the picture frame may go black
		* for a second while the system reorders itself.
		*
		* Whether the video is stretched or clipped to fit in the specified rectangle
		* depends on the combination platform/codec.
		* There should be a list; we don't have one yet.
		* Symbian always stretches.
		* I suspect most Java platforms stretches too, but I'm not sure.
		*
		* \returns #IOCTL_UNAVAILABLE if the function is unavailable. \<= -2 on other errors.
		*/
		int maStreamVideoSetFrame(in MAHandle stream, in MARect rect);

		/**
		* Returns the length of the stream, in milliseconds. \<0 if the length cannot be determined.
		*
		* Will only work after #STREAMEVENT_PREPARE_COMPLETE has been received for the stream.
		*/
		int maStreamLength(in MAHandle stream);

		/**
		* Returns the current playing time position of the stream, in milliseconds.
		* Returns \<0 if the position cannot be determined.
		*
		* Will only work after #STREAMEVENT_PREPARE_COMPLETE has been received for the stream.
		*/
		int maStreamPos(in MAHandle stream);

		/**
		* Sets the playing time position in the stream.
		* The provided position is clamped to the length of the stream.
		* For some platform/media combinations, setting the position is not very accurate.
		* The return value will indicate the actual position set.
		*
		* Will only work after #STREAMEVENT_PREPARE_COMPLETE has been received for the stream.
		*
		* \param stream A valid stream handle.
		* \param pos A position, in milliseconds.
		* \returns \<0 on error.
		*/
		int maStreamSetPos(in MAHandle stream, in int pos);

		/**
		* Pauses the stream. Does nothing if the stream is already paused.
		*/
		int maStreamPause(in MAHandle stream);

		/**
		* Resumes the stream. Does nothing if the stream is already playing.
		*/
		int maStreamResume(in MAHandle stream);

		/**
		* Closes the stream, releasing resources and rendering the handle invalid.
		*/
		int maStreamClose(in MAHandle stream);
#endif	//IX_STREAMING

		/**
		* \brief A structure containing information about the native framebuffer, including color format and resolution.
		*
		* The 'sizeInBytes' field is the amount of bytes that should be used to allocate the offscreen framebuffer (a backbuffer).
		*/
		struct MAFrameBufferInfo {
			int sizeInBytes;         // The size in bytes of the frame buffer, is calculated as width*pitch.
			int bytesPerPixel;       // The amount of bytes per pixel.
			int bitsPerPixel;        // The amount of bits per pixel.
			int redMask;             // The mask representing the bits occupied of the red color component in a pixel.
			int redShift;            // The index of the lowest significant bit of the red color component.
			int redBits;             // The amount of bits for the red color component.
			int greenMask;           // The mask representing the bits occupied of the green color component in a pixel.
			int greenShift;          // The index of the lowest significant bit of the green color component.
			int greenBits;           // The amount of bits for the green color component.
			int blueMask;            // The mask representing the bits occupied of the blue color component in a pixel.
			int blueShift;           // The index of the lowest significant bit of the blue color component.
			int blueBits;            // The amount of bits for the blue color component.
			int width;               // The width of the screen in pixels.
			int height;              // The height of the screen in pixels.
			int pitch;               // The pitch of the screen in byes, i.e. the amount of bytes to offset in order to step one scanline.
			int supportsGfxSyscalls; // If 1, standard graphic syscalls can by used to draw to the custom framebuffer, otherwise not.
		}

		/**
		 * Get frame buffer info. Use info.sizeInBytes to allocate memory for framebuffer.
		 * \param info A pointer to an MAFrameBufferInfo structure, which the information will be written to.
		 * \returns \<=0 on error.
		 */
		int maFrameBufferGetInfo(out MAFrameBufferInfo info);

		/**
		 * Pass a pointer to your framebuffer here. Each time an maUpdateScreen is performed,
		 * this piece of memory will be copied to the actual screen memory.
		 * \param data A pointer to the custom framebuffer.
		 * \returns \<=0 on error.
		 */
		int maFrameBufferInit(in MAAddress data);

		/**
		 * Close the framebuffer. The graphics sub-system will be set to use the standard framebuffer.
		 * \returns \<=0 on error.
		 */
		int maFrameBufferClose();

#if IX_AUDIOBUFFER
		constset int AUDIO_FMT_ {
			S8 = 1;
			S16 = 2;
			U8 = 3;
			U16 = 4;
		}

		/**
		* \brief Information about an audio buffer, including format, sample rate, channels, and size.
		*/
		struct MAAudioBufferInfo {
			int fmt;	//one of the AUDIO_FMT constants
			int sampleRate;	//in hertz
			int numChannels;
			int bufferSize;	//in bytes?
			MAAddress buffer;	//should be const void*
		}

		// returns 1.
		// should cause #EVENT_TYPE_AUDIOBUFFER_FILL when the system is ready to accept sound data.
		// Check MAEvent::state to see if the system failed.
		int maAudioBufferInit(in MAAudioBufferInfo info);

		/*
		* Call these functions in series after you have got the #EVENT_TYPE_AUDIOBUFFER_FILL event and filled your buffer.
		* Note: eventhough you aren't going to fill the buffer
		*/
		// returns 1.
		int maAudioBufferReady();

		// returns 1.
		int maAudioBufferClose();
#endif

		/**
		* Asynchronously accepts and opens a remote connection to a service.
		*
		* When a connection is accepted, a CONN event with #CONNOP_ACCEPT will be generated.
		* If the accept was successful, MAConnEventData::result will be a handle to the new,
		* normal connection. MAConnEventData::handle will be the server connection specified
		* in the call to this function.
		*
		* To accept another connection after such an event, call this function again.
		*
		* \param serv A server connection, opened with maConnect.
		* \returns \< 0 on error, \> 0 on success.
		* \see maConnect
		* \see maGetEvent
		*/
		int maAccept(in MAHandle serv);

		/**
		* Sends the application to the background, unless it's already there.
		* Generates a \link #EVENT_TYPE_FOCUS_LOST FOCUS_LOST \endlink event.
		* \note Only available on multi-tasking operating systems.
		*/
		int maSendToBackground();

		/**
		* Brings the application to the foreground, unless it's already there.
		* Generates a \link #EVENT_TYPE_FOCUS_LOST FOCUS_GAINED \endlink event.
		* \note Only available on multi-tasking operating systems.
		*/
		int maBringToForeground();

#if IX_SEGMENTED_DATA
		/**
		* Increases the size of a data object.
		* \note There is no way to decrease the size of a data object.
		* However, you can still destroy it.
		* \returns #RES_OK if succeded and #RES_OUT_OF_MEMORY if failed.
		* \see maDestroyObject()
		* \see maCreateData()
		* \see maGetDataSize()
		*/
		int maAddDataSize(in MAHandle data, in int size);
#endif	//IX_SEGMENTED_DATA

		/**
		* Retrieves the value of a Java System Property, or a MoSync System Property.
		*
		* There are a few MoSync System Properties. They are unavailable on some devices.
		* "mosync.imei" and "mosync.imsi" is the device's IMEI and IMSI number, respectively.
		* The format of these numbers is not specified. It varies from device to device.
		*
		* "mosync.iso-639-1" and "mosync.iso-639-2" is the current language used by the system's UI.
		* Multi-language applications should use this to determine which language to use.
		*
		* "mosync.winmobile.locale.SABBREVLANGNAME" is a windows mobile specific property.
		* See http://msdn.microsoft.com/en-us/library/dd373831%28VS.85%29.aspx.
		*
		* See http://www.loc.gov/standards/iso639-2/php/code_list.php -
		* The official list of valid ISO-639 codes (online).
		*
		* "mosync.device" is a description of the device. May include vendor, model name
		* and firmware version.
		* The format of this description is not specified. It varies from device to device.
		*
		* "mosync.path.local" is the absolute path to the local file system,
		* on devices that have a local file system. The returned path has a
		* trailing slash character ('/').
		*
		* \param key The property's key.
		* \param buf A buffer where the value should be written.
		* \param size The size of the buffer, in bytes.
		* \returns The length of the value, including the terminating zero.
		* If this is greater than \a size, the value will not have been copied to be buffer.
		* In that case, you can make a bigger buffer and try again.
		* If the property did not exist (System.getProperty() returned null),
		* -2 will be returned.
		*/
		int maGetSystemProperty(in MAString key, out MAString buf range("size"), in int size);

group PIMAPI "PIM API" {

#if IX_PIM
		constset int MA_PIM_ {
			/**
			* Each contact commonly includes a name and one or more phone numbers.
			* May also include a street address and an email address.
			*/
			CONTACTS = 1;
			EVENTS = 2;
			TODOS = 3;
		}

	group PIMConsts "PIM Constants" {
		constset int MA_PIM_TYPE_ {
			/// bytes
			/// the bytes are not null-terminated.
			BINARY = 0;
			/// int
			BOOLEAN = 1;
			/// int
			/// unix time.
			DATE = 2;
			/// int
			INT = 3;
			/// wide-string '\\0'
			STRING = 4;
			/// int (wide-string '\\0')*
			/// the int specifies the number of strings.
			/// there is no extra null terminator at the end of the list.
			STRING_ARRAY = 5;
		}

		constset int MA_PIM_FIELD_CONTACT_ {
			/**
			* @brief The addresses of the contact. Multiple string arrays. Has \link #MA_PIM_CONTACT_ADDR_POBOX MA_PIM_CONTACT_ADDR \endlink indices.
			*
			* @validvalue #MA_PIM_TYPE_STRING_ARRAY.
			*
			* @addsetget
			*
			* @attributes MA_PIM_ATTR_ADDR_HOME, MA_PIM_ATTR_ADDR_WORK, MA_PIM_ATTR_ADDR_OTHER, MA_PIM_ATTR_ADDR_CUSTOM.
			*
			* @platforms Android, iOS.
			*
			*/
			ADDR = 100;

			/**
			* @brief The birthday of the contact. Single date.
			*
			* @validvalue #MA_PIM_TYPE_DATE.
			*
			* @addsetget
			*
			* @platforms Android, iOS.
			*
			*/
			BIRTHDAY = 101;

			/**
			* @brief Access class. Single integer. May be one of #MA_PIM_CONTACT_CLASS_CONFIDENTIAL, #MA_PIM_CONTACT_CLASS_PRIVATE, or #MA_PIM_CONTACT_CLASS_PUBLIC.
			*
			* @validvalue #MA_PIM_TYPE_INT.
			*
			* @addsetget
			*
			* @platforms Symbian.
			*
			*/
			CLASS = 102;

			/**
			* @brief The email addresses of the contact. Multiple strings.
			*
			* @validvalue #MA_PIM_TYPE_STRING.
			*
			* @addsetget
			*
			* @attributes MA_PIM_ATTR_EMAIL_HOME, MA_PIM_ATTR_EMAIL_WORK, MA_PIM_ATTR_EMAIL_MOBILE, MA_PIM_ATTR_EMAIL_OTHER, MA_PIM_ATTR_EMAIL_CUSTOM.
			*
			* @platforms Android, iOS.
			*
			*/
			EMAIL = 103;

			/**
			* @brief The formatted addresses of the contact. Single string.
			*
			* @validvalue #MA_PIM_TYPE_STRING.
			*
			* @getonly
			*
			* @attributes MA_PIM_ATTR_FORMATTED_ADDR_HOME, MA_PIM_ATTR_FORMATTED_ADDR_WORK, MA_PIM_ATTR_FORMATTED_ADDR_OTHER, MA_PIM_ATTR_FORMATTED_ADDR_CUSTOM.
			*
			* @platforms Android.
			*
			*/
			FORMATTED_ADDR = 104;

			/**
			* @brief The formatted name of the contact. Single string.
			*
			* @validvalue #MA_PIM_TYPE_STRING.
			*
			* @getonly
			*
			* @platforms Symbian.
			*
			*/
			FORMATTED_NAME = 105;

			/**
			* @brief The name of the contact. Single string array containing Family name, Given name, Middle name, Prefix,
			* Suffix, Phonetic family name, Phonetic given name, Phonetic middle name. Has \link #MA_PIM_CONTACT_NAME_FAMILY MA_PIM_CONTACT_NAME \endlink indices.
			*
			* @validvalue #MA_PIM_TYPE_STRING_ARRAY.
			*
			* @getonly
			*
			* @platforms Android, iOS.
			*
			*/
			NAME = 106;

			/**
			* @brief The nickname of the contact. Single string.
			*
			* @validvalue #MA_PIM_TYPE_STRING.
			*
			* @addsetget
			*
			* @platforms Android, iOS.
			*
			*/
			NICKNAME = 107;

			/**
			* @brief Supplementary information, or a comment. Multiple string.
			*
			* @validvalue #MA_PIM_TYPE_STRING.
			*
			* @addsetget
			*
			* @platforms Android, iOS.
			*
			*/
			NOTE = 108;

			/**
			* @brief The organization name of the contact. Multiple string.
			*
			* @validvalue #MA_PIM_TYPE_STRING.
			*
			* @addsetget
			*
			* @attributes MA_PIM_ATTR_ORG_WORK, MA_PIM_ATTR_ORG_OTHER, MA_PIM_ATTR_ORG_CUSTOM.
			*
			* @platforms Android, iOS.
			*
			*/
			ORG = 109;

			/**
			* @brief The contact's photo. A single int representing a data handle. Connected with PHOTO_URL.
			*
			* @validvalue #MA_PIM_TYPE_INT.
			*
			* @addsetget
			*
			* @platforms Android, iOS.
			*
			*/
			PHOTO = 110;

			/**
			* @brief The contact's photo url. A single string representing the URL of a photo. Connected with PHOTO.
			*
			* @validvalue #MA_PIM_TYPE_STRING.
			*
			* @setonly
			*
			* @platforms Android, iOS.
			*
			*/
			PHOTO_URL = 111;

			/**
			* @brief The public key of the contact. Connected with PUBLIC_KEY_STRING.
			*
			* @validvalue #MA_PIM_TYPE_BINARY.
			*
			* @addsetget
			*
			* @platforms Symbian.
			*
			*/
			PUBLIC_KEY = 112;

			/**
			* @brief A string representation of the contact's public key. Connected with PUBLIC_KEY.
			*
			* @validvalue #MA_PIM_TYPE_STRING.
			*
			* @addsetget
			*
			* @platforms Symbian.
			*
			*/
			PUBLIC_KEY_STRING = 113;

			/**
			* @brief The revision date of the field. Single date.
			*
			* @validvalue #MA_PIM_TYPE_DATE.
			*
			* @getonly
			*
			* @platforms Android, iOS.
			*
			*/
			REVISION = 114;

			/**
			* @brief The telephone numbers of the contact. Multiple strings.
			*
			* @validvalue #MA_PIM_TYPE_STRING.
			*
			* @addsetget
			*
			* @attributes MA_PIM_ATTR_PHONE_HOME, MA_PIM_ATTR_PHONE_MOBILE, MA_PIM_ATTR_PHONE_HOME_FAX, MA_PIM_ATTR_PHONE_WORK_FAX, MA_PIM_ATTR_PHONE_PAGER, MA_PIM_ATTR_PHONE_IPHONE, MA_PIM_ATTR_PHONE_WORK, MA_PIM_ATTR_PHONE_CALLBACK, MA_PIM_ATTR_PHONE_CAR, MA_PIM_ATTR_PHONE_COMPANY_MAIN, MA_PIM_ATTR_PHONE_ISDN, MA_PIM_ATTR_PHONE_OTHER_FAX, MA_PIM_ATTR_PHONE_RADIO, MA_PIM_ATTR_PHONE_TELEX, MA_PIM_ATTR_PHONE_TTY_TDD, MA_PIM_ATTR_PHONE_WORK_MOBILE, MA_PIM_ATTR_PHONE_WORK_PAGER, MA_PIM_ATTR_PHONE_ASSISTANT, MA_PIM_ATTR_PHONE_MMS, MA_PIM_ATTR_PHONE_OTHER, MA_PIM_ATTR_PHONE_CUSTOM.
			*
			* @platforms Android, iOS.
			*
			*/
			TEL = 115;

			/**
			* @brief The professional title of the contact inside the organization. Multiple strings.
			*
			* @validvalue #MA_PIM_TYPE_STRING.
			*
			* @addsetget
			*
			* @attributes MA_PIM_ATTR_TITLE_WORK, MA_PIM_ATTR_TITLE_OTHER, MA_PIM_ATTR_TITLE_CUSTOM.
			*
			* @platforms Android, iOS.
			*
			*/
			TITLE = 116;

			/**
			* @brief The unique identifier of the contact on the current device. Single string.
			*
			* @validvalue Single #MA_PIM_TYPE_STRING.
			*
			* @getonly
			*
			* @platforms Android, iOS.
			*
			*/
			UID = 117;

			/**
			* @brief Uniform Resource Locators associated with the contact. Multiple strings.
			*
			* @validvalue #MA_PIM_TYPE_STRING.
			*
			* @addsetget
			*
			* @attributes MA_PIM_ATTR_WEBSITE_HOMEPAGE, MA_PIM_ATTR_WEBSITE_BLOG, MA_PIM_ATTR_WEBSITE_PROFILE, MA_PIM_ATTR_WEBSITE_HOME, MA_PIM_ATTR_WEBSITE_WORK, MA_PIM_ATTR_WEBSITE_FTP, MA_PIM_ATTR_WEBSITE_OTHER, MA_PIM_ATTR_WEBSITE_CUSTOM.
			*
			* @platforms Android, iOS.
			*
			*/
			URL = 118;

			/**
			* @brief The IM addresses of the contact. Multiple arrays. Has \link #MA_PIM_CONTACT_IM_USERNAME MA_PIM_CONTACT_IM \endlink indices.
			*
			* @validvalue #MA_PIM_TYPE_STRING_ARRAY.
			*
			* @addsetget
			*
			* @attributes MA_PIM_ATTR_IM_HOME, MA_PIM_ATTR_IM_WORK, MA_PIM_ATTR_IM_OTHER, MA_PIM_ATTR_IM_CUSTOM.
			*
			* @platforms Android, iOS.
			*
			*/
			IM = 119;

			/**
			* @brief A relation of the contact.
			*
			* @validvalue #MA_PIM_TYPE_STRING.
			*
			* @addsetget
			*
			* @attributes MA_PIM_ATTR_RELATION_MOTHER, MA_PIM_ATTR_RELATION_FATHER, MA_PIM_ATTR_RELATION_PARENT, MA_PIM_ATTR_RELATION_SISTER, MA_PIM_ATTR_RELATION_BROTHER, MA_PIM_ATTR_RELATION_CHILD, MA_PIM_ATTR_RELATION_FRIEND, MA_PIM_ATTR_RELATION_SPOUSE, MA_PIM_ATTR_RELATION_PARTNER, MA_PIM_ATTR_RELATION_MANAGER, MA_PIM_ATTR_RELATION_ASSISTANT, MA_PIM_ATTR_RELATION_DOMESTIC_PARTNER, MA_PIM_ATTR_RELATION_REFERRED_BY, MA_PIM_ATTR_RELATION_RELATIVE, MA_PIM_ATTR_RELATION_CUSTOM.
			*
			* @platforms Android, iOS.
			*
			*/
			RELATION = 120;

			/**
			* @brief Information about the organization. Has \link #MA_PIM_CONTACT_ORGANIZATION_NAME MA_PIM_CONTACT_ORGANIZATION \endlink indices.
			*
			* @validvalue #MA_PIM_TYPE_STRING_ARRAY.
			*
			* @addsetget
			*
			* @attributes MA_PIM_ATTR_ORG_INFO_WORK, MA_PIM_ATTR_ORG_INFO_OTHER, MA_PIM_ATTR_ORG_INFO_CUSTOM.
			*
			* @platforms Android, iOS.
			*
			*/
			ORG_INFO = 121;
		}

		constset int MA_PIM_CONTACT_ADDR_ {
			/// Index for #MA_PIM_FIELD_CONTACT_ADDR. Post office box number.
			POBOX = 0;
			/// Index for #MA_PIM_FIELD_CONTACT_ADDR. Extra info.
			EXTRA = 1;
			/// Index for #MA_PIM_FIELD_CONTACT_ADDR. Street name and number.
			STREET = 2;
			/// Index for #MA_PIM_FIELD_CONTACT_ADDR. Locality name. (ex. city)
			LOCALITY = 3;
			/// Index for #MA_PIM_FIELD_CONTACT_ADDR. Region name. (ex. province, state or territory)
			REGION = 4;
			/// Index for #MA_PIM_FIELD_CONTACT_ADDR. Postal code.
			POSTALCODE = 5;
			/// Index for #MA_PIM_FIELD_CONTACT_ADDR. Country name.
			COUNTRY = 6;
			/// Index for #MA_PIM_FIELD_CONTACT_ADDR. Neighborhood.
			NEIGHBORHOOD = 7;
		}

		constset int MA_PIM_CONTACT_NAME_ {
			/// Index for #MA_PIM_FIELD_CONTACT_NAME. Family name.
			FAMILY = 0;
			/// Index for #MA_PIM_FIELD_CONTACT_NAME. Given name.
			GIVEN = 1;
			/// Index for #MA_PIM_FIELD_CONTACT_NAME. Alternate/secondary names, if any.
			OTHER = 2;
			/// Index for #MA_PIM_FIELD_CONTACT_NAME. Prefix. (ex. "Dr.")
			PREFIX = 3;
			/// Index for #MA_PIM_FIELD_CONTACT_NAME. Suffix. (ex. "M.D.")
			SUFFIX = 4;
			/// Index for #MA_PIM_FIELD_CONTACT_NAME. Phonetic last name.
			PHONETIC_FAMILY = 5;
			/// Index for #MA_PIM_FIELD_CONTACT_NAME. Phonetic first name.
			PHONETIC_GIVEN = 6;
			/// Index for #MA_PIM_FIELD_CONTACT_NAME. Phonetic middle name.
			PHONETIC_OTHER = 7;
		}

		constset int MA_PIM_CONTACT_ORG_INFO_ {
			/// #MA_PIM_TYPE_STRING.
			/// Only for Android and iOS devices.
			DEPARTMENT = 0;
			/// #MA_PIM_TYPE_STRING.
			/// Only for Android devices.
			JOB_DESCRIPTION = 1;
			/// #MA_PIM_TYPE_STRING.
			/// Only for Android devices.
			SYMBOL = 2;
			/// #MA_PIM_TYPE_STRING.
			/// Only for Android devices.
			PHONETIC_NAME = 3;
			/// #MA_PIM_TYPE_STRING.
			/// Only for Android devices.
			OFFICE_LOCATION = 4;
			/// #MA_PIM_TYPE_STRING.
			/// Only for Android devices.
			PHONETIC_NAME_STYLE = 5;
		}

		constset int MA_PIM_CONTACT_IM_ {
			/// #MA_PIM_TYPE_STRING.
			USERNAME = 0;
			/// #MA_PIM_TYPE_STRING.
			PROTOCOL = 1;
		}

		constset int MA_PIM_CONTACT_CLASS_ {
			/// Value for #MA_PIM_FIELD_CONTACT_CLASS.
			CONFIDENTIAL = 200;
			/// Value for #MA_PIM_FIELD_CONTACT_CLASS.
			PRIVATE = 201;
			/// Value for #MA_PIM_FIELD_CONTACT_CLASS.
			PUBLIC = 202;
		}

		constset MAString MA_PIM_CONTACT_IM_PROTOCOL_ {
			/// This constant describes an AIM protocol.
			AIM = "AIM";
			/// This constant describes a MSN protocol.
			MSN = "MSN";
			/// This constant describes a Yahoo protocol.
			YAHOO = "Yahoo";
			/// This constant describes a Skype protocol.
			SKYPE = "Skype";
			/// This constant describes a QQ protocol.
			QQ = "QQ";
			/// This constant describes a Google Talk protocol.
			GOOGLE_TALK = "GoogleTalk";
			/// This constant describes an ICQ protocol.
			ICQ = "ICQ";
			/// This constant describes a Jabber protocol.
			JABBER = "Jabber";
			/// This constant describes a NetMeeting protocol.
			NETMEETING = "Netmeeting";
		}

		// deprecated
		constset int MA_PIM_ATTR_ {
			/// The value describes an assistant.
			ASST = 1;
			/// Unknown.
			AUTO = 2;
			/// The value describes a fax number.
			FAX = 4;
			/// The value describes a home phone number.
			HOME = 8;
			/// The value describes a mobile phone number.
			MOBILE = 16;
			/// Unknown.
			OTHER = 32;
			/// The value describes a pager number.
			PAGER = 64;
			/// In a field with multiple values, this one is preferred before the others.
			/// Only one value per field may be marked PREFERRED. Marking a value PREFERRED
			/// causes any other PREFERRED value in the field to become unmarked.
			PREFERRED = 128;
			/// The value describes an SMS number?
			SMS = 256;
			/// The value describes a work phone number.
			WORK = 512;
		}

		constset int MA_PIM_ATTR_ADDR_ {
			/// The constant describes a home address.
			HOME = 101;
			/// The constant describes a work address.
			WORK = 102;
			/// The constant describes a different address type.
			OTHER = 103;
			/// The constant describes a custom address type.
			/// The field's label can be set.
			CUSTOM = 104;
		}

		constset int MA_PIM_ATTR_EMAIL_ {
			/// The constant describes a home e-mail address.
			HOME = 201;
			/// The constant describes a work e-mail address.
			WORK = 202;
			/// The constant describes a mobile e-mail address.
			MOBILE = 203;
			/// The constant describes a different e-mail address type.
			OTHER = 204;
			/// The constant describes a custom e-mail address type.
			/// The field's label can be set.
			CUSTOM = 205;
		}

		constset int MA_PIM_ATTR_FORMATTED_ADDR_ {
			/// The constant describes a home formatted address.
			HOME = 301;
			/// The constant describes a work formatted address.
			WORK = 302;
			/// The constant describes a different formatted address type.
			OTHER = 303;
			/// The constant describes a custom formatted address type.
			/// The field's label can be set.
			CUSTOM = 304;
		}

		constset int MA_PIM_ATTR_ORG_ {
			/// The constant describes a work organization.
			WORK = 401;
			/// The constant describes a different organization type.
			OTHER = 402;
			/// The constant describes a custom organization type.
			/// The field's label can be set.
			CUSTOM = 403;
		}

		constset int MA_PIM_ATTR_PHONE_ {
			/// The constant describes a home phone number.
			HOME = 501;
			/// The constant describes a mobile phone number.
			MOBILE = 502;
			/// The constant describes a home fax phone number.
			HOME_FAX = 503;
			/// The constant describes a work fax phone number.
			WORK_FAX = 504;
			/// The constant describes a pager phone number.
			PAGER = 505;
			/// The constant describes an iPhone phone number.
			IPHONE = 506;
			/// The constant describes a work phone number.
			WORK = 507;
			/// The constant describes a callback phone number.
			CALLBACK = 508;
			/// The constant describes a car phone number.
			CAR = 509;
			/// The constant describes a company main phone number.
			COMPANY_MAIN = 510;
			/// The constant describes a ISDN phone number.
			ISDN = 511;
			/// The constant describes a other fax type phone number.
			OTHER_FAX = 512;
			/// The constant describes a radio phone number.
			RADIO = 513;
			/// The constant describes a telex phone number.
			TELEX = 514;
			/// The constant describes a TTY TDD phone number.
			TTY_TDD = 515;
			/// The constant describes a work mobile phone number.
			WORK_MOBILE = 516;
			/// The constant describes a work pager phone number.
			WORK_PAGER = 517;
			/// The constant describes an assistant phone number.
			ASSISTANT = 518;
			/// The constant describes a MMS phone number.
			MMS = 519;
			/// The constant describes a different phone number type.
			OTHER = 520;
			/// The constant describes a custom phone number type.
			/// The field's label can be set.
			CUSTOM = 521;
		}

		constset int MA_PIM_ATTR_TITLE_ {
			/// The constant describes a work title.
			/// Not available on iOS.
			WORK = 601;
			/// The constant describes a different title type.
			/// Not available on iOS.
			OTHER = 602;
			/// The constant describes a custom title type.
			/// The field's label can be set.
			/// Not available on iOS.
			CUSTOM = 603;
		}

		constset int MA_PIM_ATTR_WEBSITE_ {
			/// The constant describes a homepage website.
			HOMEPAGE = 701;
			/// The constant describes a blog website.
			BLOG = 702;
			/// The constant describes a profile website.
			PROFILE = 703;
			/// The constant describes a home website.
			HOME = 704;
			/// The constant describes a work website.
			WORK = 705;
			/// The constant describes a FTP website.
			FTP = 706;
			/// The constant describes a different website type.
			OTHER = 707;
			/// The constant describes a custom website type.
			/// The field's label can be set.
			CUSTOM = 708;
		}

		constset int MA_PIM_ATTR_IM_ {
			/// The constant describes a home IM address.
			HOME = 801;
			/// The constant describes a work IM address.
			WORK = 802;
			/// The constant describes a different IM address type.
			OTHER = 803;
			/// The constant describes a custom IM address type.
			/// The field's label can be set.
			CUSTOM = 804;
		}

		constset int MA_PIM_ATTR_RELATION_ {
			/// The constant describes a mother relation.
			MOTHER = 901;
			/// The constant describes a father relation.
			FATHER = 902;
			/// The constant describes a parent relation.
			PARENT = 903;
			/// The constant describes a sister relation.
			SISTER = 904;
			/// The constant describes a brother relation.
			BROTHER = 905;
			/// The constant describes a child relation.
			CHILD = 906;
			/// The constant describes a friend relation.
			FRIEND = 907;
			/// The constant describes a spouse relation.
			SPOUSE = 908;
			/// The constant describes a partner relation.
			PARTNER = 909;
			/// The constant describes a manager relation.
			MANAGER = 910;
			/// The constant describes a assistant relation.
			ASSISTANT = 911;
			/// The constant describes a domestic partner relation.
			DOMESTIC_PARTNER = 912;
			/// The constant describes a referred by relation.
			REFERRED_BY = 913;
			/// The constant describes a relative relation.
			RELATIVE = 914;
			/// The constant describes a custom relation type.
			/// The field's label can be set.
			/// Not available on iOS.
			CUSTOM = 915;
		}

		constset int MA_PIM_ATTR_ORG_INFO_ {
			/// The constant describes a work organization.
			/// Not available on iOS.
			WORK = 1001;
			/// The constant describes a different organization type.
			/// Not available on iOS.
			OTHER = 1002;
			/// The constant describes a custom organization type.
			/// The field's label can be set.
			/// Not available on iOS.
			CUSTOM = 1003;
		}

		constset int MA_PIM_ATTR {
			/// The constant describes a preferred field.
			PREFERRED = 0x10000;
		}

		constset int MA_PIM_ERR_ {
			/// No error. The operation completed successfully.
			NONE = 0;
			/// This function is unavailable on the current platform.
			UNAVAILABLE = -1;
			/// The native database's data type for the given field did not match the MoSync API.
			NATIVE_TYPE_MISMATCH = -2;
			/// The specified list type is invalid.
			LIST_TYPE_INVALID = -3;
			/// The specified pim list is not available on the current platform.
			LIST_UNAVAILABLE = -4;
			/// The specified list is already opened.
			LIST_ALREADY_OPENED = -5;
			/// The specified field is invalid.
			FIELD_INVALID = -6;
			/// The field type is not supported.
			FIELD_UNSUPPORTED = -7;
			/// The requested field doesn't have a value.
			FIELD_EMPTY = -8;
			/// More values in this field are not supported.
			FIELD_COUNT_MAX = -9;
			/// The field is read-only.
			FIELD_READ_ONLY = -10;
			/// The field is write-only.
			FIELD_WRITE_ONLY = -11;
			/// The given index is not valid.
			INDEX_INVALID = -12;
			/// Invalid handle.
			HANDLE_INVALID = -13;
			/// The field/attribute combination is not supported.
			ATTRIBUTE_COMBO_UNSUPPORTED = -14;
			/// The values's attribute is not set to custom.
			ATTRIBUTE_CUSTOM = -15;
			/// Invalid buffer structure.
			BUFFER_INVALID = -16;
			/// The value does not have a custom label.
			NO_LABEL = -17;
			/// The operation is not allowed by the Address Book database.
			OPERATION_NOT_PERMITTED = -18;
		}
	}

	group PIMFunctions "PIM Functions"{
		/**
		* \brief Opens a PimList. Use maPimListNext() to open the list's items.
		* \param listType One of the \link #MA_PIM_CONTACTS MA_PIM \endlink constants.
		* \returns \>= 0 A PimList handle.
		*          \<  0 on error:
		*                    #MA_PIM_ERR_LIST_ALREADY_OPENED if the list is already opened.
		*                    #MA_PIM_ERR_LIST_UNAVAILABLE if the list is not available on the current platform.
		*                    #MA_PIM_ERR_LIST_TYPE_INVALID if the given list type is invalid.
		*/
		MAHandle maPimListOpen(in int listType);

		/**
		* \brief Returns a handle to the next PimItem in the \a list, or 0 if there are no more items,
		* or \< 0 on error.
		* You must use maPimItemClose() on every item to prevent memory leaks.
		* \param list List handle provided by maPimListOpen(int listType).
		* \returns \> 0 a PimItem handle.
		*          \= 0 if there are no more items.
		*          \< 0 on error:
		*                    #MA_PIM_ERR_HANDLE_INVALID if the list handle is invalid.
		*/
		MAHandle maPimListNext(in MAHandle list);

		/**
		* \brief Closes a PimList.
		* \param list List handle provided by maPimListOpen(int listType).
		* \returns #MA_PIM_ERR_NONE on success, or \< 0 on error.
		* #MA_PIM_ERR_LIST_NOT_OPENED if the list is not opened.
		* #MA_PIM_ERR_UNAVAILABLE_LIST if the list is unavailable.
		* #MA_PIM_ERR_INVALID_HANDLE if the list handle is invalid.
		* \note This does not close the list's items, but it does invalidate them,
		* so that maPimItemClose() is the only function you can safely use on them.
		*/
		int maPimListClose(in MAHandle list);

		/**
		* \brief Returns the number of fields in the \a item.
		* \param item Item handle provided by maPimListNext(MAHandle list).
		* \returns \>= 0 the number of fields in the item.
		*          \<  0 on error:
		*                    #MA_PIM_ERR_HANDLE_INVALID if the item handle is invalid.
		*/
		int maPimItemCount(in MAHandle item);

		/**
		* \brief Returns the field id of the item's n:th field.
		* Panics on invalid indices.
		* \param item Opened by maPimListNext().
		* \param n \>= 0 and \< maPimItemCount().
		* \returns \> 0 one of the \link #MA_PIM_FIELD_CONTACT_ADDR MA_PIM_FIELD \endlink constants.
		*          \< 0 on error:
		*                    #MA_PIM_ERR_HANDLE_INVALID if the item handle is invalid.
		*                    #MA_PIM_ERR_INDEX_INVALID if the param n is not valid.
		* \note On Android and iOS the panic system can be disabled so you'll get error codes instead.
		*/
		int maPimItemGetField(in MAHandle item, in int n);

		/**
		* \brief Returns the number of values in the field for a given item.
		* \param item Opened by maPimListNext().
		* \param field One of the \link #MA_PIM_FIELD_CONTACT_ADDR MA_PIM_FIELD \endlink constants.
		* \returns \> 0 the number of values in the field.
		*          \= 0 if the item field has no values.
		*          \< 0 on error:
		*                    #MA_PIM_ERR_HANDLE_INVALID if the item handle is invalid.
		*                    #MA_PIM_ERR_FIELD_UNSUPPORTED if the field is unsupported.
		*                    #MA_PIM_ERR_FIELD_INVALID if the field is invalid.
		*/
		int maPimItemFieldCount(in MAHandle item, in int field);

		/**
		* \brief Returns the attribute for the specified value in a field and item.
		* Panics on field/index combinations that don't exist in this item.
		* \param item Opened by maPimListNext().
		* \param field One of the \link #MA_PIM_FIELD_CONTACT_ADDR MA_PIM_FIELD \endlink constants.
		* \param index \>= 0 and \< maPimItemFieldCount().
		* \returns \> 0 the attribute for the specified field.
		*          \= 0 if the field doesn't have attributes.
		*          \< 0 on error:
		*                    #MA_PIM_ERR_HANDLE_INVALID if the item handle is invalid.
		*                    #MA_PIM_ERR_FIELD_INVALID if the field is invalid.
		*                    #MA_PIM_ERR_FIELD_UNSUPPORTED if the field type is unsupported.
		*                    #MA_PIM_ERR_FIELD_EMPTY if the given field doesn't have values.
		*                    #MA_PIM_ERR_INDEX_INVALID if the index is invalid.
		* \note On Android and iOS the panic system can be disabled so you'll get error codes instead.
		*/
		int maPimItemGetAttributes(in MAHandle item, in int field, in int index);

		/**
		* \brief Sets a custom label for a value in a field and item.
		* Panics on field/index combinations that don't exist in this item.
		* The value's attribute must be set to custom.
		* The label has #MA_PIM_TYPE_STRING and is stored in \a args.buf.
		* \a args.bufSize must be valid.
		* \param args Common arguments.
		* \param index An index into the field's value array.
		* This is a number \>= 0 and \< the return value of maPimItemFieldCount().
		* \returns           #MA_PIM_ERR_NONE on success.
		*                    #MA_PIM_ERR_HANDLE_INVALID if the item handle is invalid.
		*                    #MA_PIM_ERR_FIELD_INVALID if the field is invalid.
		*                    #MA_PIM_ERR_FIELD_UNSUPPORTED if the field type is unsupported.
		*                    #MA_PIM_ERR_FIELD_EMPTY if the given field doesn't have values.
		*                    #MA_PIM_ERR_FIELD_READ_ONLY if the field is read-only.
		*                    #MA_PIM_ERR_INDEX_INVALID if the index is invalid.
		*                    #MA_PIM_ERR_NO_LABEL if the attribute is not set to custom.
		* \note This function is available only on Android or iOS.
		* \note On Android and iOS the panic system can be disabled so you'll get error codes instead.
		*/
		int maPimItemSetLabel(in MA_PIM_ARGS args, in int index);

		/**
		* Retrieves the custom label for a value in a field and item,
		* if the value has a custom label.
		* The label has #MA_PIM_TYPE_STRING and is stored in \a args.buf.
		* \a args.bufSize must be valid.
		* \param args Common arguments.
		* \param index An index into the field's value array.
		* This is a number \>= 0 and \< the return value of maPimItemFieldCount().
		* \returns \>= 0 the number of bytes occupied by the value.
		*          \<  0 on error:
		*                    #MA_PIM_ERR_HANDLE_INVALID if the item handle is invalid.
		*                    #MA_PIM_ERR_FIELD_INVALID if the field is invalid.
		*                    #MA_PIM_ERR_FIELD_UNSUPPORTED if the field type is unsupported.
		*                    #MA_PIM_ERR_FIELD_EMPTY if the given field doesn't have values.
		*                    #MA_PIM_ERR_INDEX_INVALID if the index is invalid.
		*                    #MA_PIM_ERR_NO_LABEL if the attribute type is not set to custom.
		*                    #MA_PIM_ERR_BUFFER_TOO_SMALL if the size of the value is greaten than bufSize.
		* \note This function is available on Android or iOS.
		*/
		int maPimItemGetLabel(in MA_PIM_ARGS args, in int index);

		/**
		* Returns one of the type of the field.
		* \param list Opened by maPimListOpen().
		* \param field One of the \link #MA_PIM_FIELD_CONTACT_ADDR MA_PIM_FIELD \endlink constants.
		* \returns \>= 0 any of the \link #MA_PIM_TYPE_BINARY MA_PIM_TYPE \endlink constants.
		*          \<  0 on error:
		*                    #MA_PIM_ERR_HANDLE_INVALID if the list handle is invalid.
		*                    #MA_PIM_ERR_FIELD_INVALID if the field is invalid.
		*                    #MA_PIM_ERR_FIELD_UNSUPPORTED if the field type is unsupported.
		*/
		int maPimFieldType(in MAHandle list, in int field);

		/**
		* \brief Arguments for PIM functions.
		*/
		struct MA_PIM_ARGS {
			/// Opened by maPimListNext().
			MAHandle item;
			/// One of the \link #MA_PIM_FIELD_CONTACT_ADDR MA_PIM_FIELD \endlink constants.
			int field;
			/// The address to a buffer, where a value is or will be stored.
			MAAddress buf;
			/// The size of the buffer, in bytes.
			int bufSize;
		}

		/**
		* Copies the specified value from a field and item to \a args.buf.
		* \param args Common arguments.
		* \param index An index into the field's value array.
		* This is a number \>= 0 and \< the return value of maPimItemFieldCount().
		* \returns \>= 0 The number of bytes occupied by the value.
		*          \<  0 on error:
		*                    #MA_PIM_ERR_HANDLE_INVALID if the item handle is invalid.
		*                    #MA_PIM_ERR_FIELD_INVALID if the field is invalid.
		*                    #MA_PIM_ERR_FIELD_UNSUPPORTED if the field type is unsupported.
		*                    #MA_PIM_ERR_FIELD_EMPTY if the given field doesn't have values.
		*                    #MA_PIM_ERR_INDEX_INVALID if the index is invalid.
		*                    #MA_PIM_ERR_FIELD_WRITE_ONLY if the field is write-only.
		*/
		int maPimItemGetValue(in MA_PIM_ARGS args, in int index);

		/**
		* Changes a value and its attributes in a field and item.
		* This function cannot be used to add a new value.
		* \param args Common arguments.
		* \param index An index into the field's value array.
		* This is a number \>= 0 and \< the return value of maPimItemFieldCount().
		* \param attributes The value's new attributes.
		* \returns           #MA_PIM_ERR_NONE on success.
		*                    #MA_PIM_ERR_HANDLE_INVALID if the item handle is invalid.
		*                    #MA_PIM_ERR_FIELD_INVALID if the field is invalid.
		*                    #MA_PIM_ERR_FIELD_UNSUPPORTED if the field type is unsupported.
		*                    #MA_PIM_ERR_FIELD_READ_ONLY if the field is read-only.
		*                    #MA_PIM_ERR_FIELD_EMPTY if the given field doesn't have values.
		*                    #MA_PIM_ERR_INDEX_INVALID if the index is invalid.
		*                    #MA_PIM_ERR_ATTRIBUTE_COMBO_UNSUPPORTED if the field/attribute combination is not supported.
		*                    #MA_PIM_ERR_BUFFER_INVALID if the buffer is not valid.
		* \note The new value is not actually written to disk until
		* the item is closed with maPimItemClose(). If the program exits before then,
		* the changes are lost.
		* \note When setting a value with #MA_PIM_TYPE_STRING_ARRAY, at least one
		* string must be present and have a length greater than zero.
		* Any surplus strings are ignored.
		*/
		int maPimItemSetValue(in MA_PIM_ARGS args, in int index, in int attributes);

		/**
		* Adds a new value to a field and item.
		* \param args Common arguments.
		* \param attributes The new value's attributes.
		* \returns />= 0 the index of the new added value.
		*          /<  0 on error:
		*                    #MA_PIM_ERR_HANDLE_INVALID if the item handle is invalid.
		*                    #MA_PIM_ERR_FIELD_INVALID if the field is invalid.
		*                    #MA_PIM_ERR_FIELD_UNSUPPORTED if the field type is unsupported.
		*                    #MA_PIM_ERR_FIELD_READ_ONLY if the field is read-only.
		*                    #MA_PIM_ERR_FIELD_COUNT_MAX if more values cannot be added to this field.
		*                    #MA_PIM_ERR_ATTRIBUTE_COMBO_UNSUPPORTED if the field/attribute combination is not supported.
		*                    #MA_PIM_ERR_BUFFER_INVALID if the buffer is not valid.
		* \note The new value is not actually written to disk until
		* the item is closed with maPimItemClose(). If the program exits before then,
		* the changes are lost.
		*/
		int maPimItemAddValue(in MA_PIM_ARGS args, in int attributes);

		/**
		* Removes a value from a field and item.
		* \param item Opened by maPimListNext().
		* \param field One of the \link #MA_PIM_FIELD_CONTACT_ADDR MA_PIM_FIELD \endlink constants.
		* \param index \>= 0 and \< maPimItemFieldCount().
		* \returns #MA_PIM_ERR_NONE on success.
		*          #MA_PIM_ERR_HANDLE_INVALID if the item handle is invalid.
		*          #MA_PIM_ERR_FIELD_INVALID if the field is invalid.
		*          #MA_PIM_ERR_FIELD_UNSUPPORTED if the field type is unsupported.
		*          #MA_PIM_ERR_FIELD_READ_ONLY if the field is read-only.
		*          #MA_PIM_ERR_FIELD_EMPTY if the given field doesn't have values.
		*          #MA_PIM_ERR_INDEX_INVALID if the index is invalid.
		* \note The changes is not actually written to disk until
		* the item is closed with maPimItemClose(). If the program exits before then,
		* the changes are lost.
		*/
		int maPimItemRemoveValue(in MAHandle item, in int field, in int index);

		/**
		* Closes the handle to a PimItem, releasing resources used by the system.
		* Writes any changes to disk.
		* \returns #MA_PIM_ERR_NONE on success.
		*          #MA_PIM_ERR_HANDLE_INVALID if the item handle is invalid, or if the item's list is closed.
		* \note An item can also be closed by maPimItemRemove().
		* \warning Does not write changes to disk if the item's List is closed.
		* Make sure to keep the List open while editing items.
		*/
		int maPimItemClose(in MAHandle item);

		/**
		* Creates a new empty item in the specified list.
		* \returns \>= 0 A handle to the new item.
		*          \<  0 on error:
		*                    #MA_PIM_ERR_HANDLE_INVALID if the list handle is invalid.
		* \note The handle must be closed with maPimItemClose() to avoid memory leaks.
		*/
		MAHandle maPimItemCreate(in MAHandle list);

		/**
		* Removes an item from a list. This also has the effect of closing the item.
		* \see maPimItemClose()
		* \returns #MA_PIM_ERR_NONE on success.
		*          #MA_PIM_ERR_HANDLE_INVALID if the list handle or item handle are invalid.
		* \note If this function fails, the item is not closed.
		*/
		int maPimItemRemove(in MAHandle list, in MAHandle item);
		} //end of pim functions

#endif	//IX_PIM
}
#if IX_WIDGET
#include "native_ui_intro_doc.idl"
group WidgetAPI "Widget API" {

	/**
	* Widgets can send events for instance when their internal state is changed (like when a
	* button is pressed). These are events sent using the MoSync event system \ref maGetEvent.
	* When an event is received with the type #EVENT_TYPE_WIDGET the 'data' member of the MAEvent
	* struct is a pointer to data of type #MAWidgetEventData.
	*/
	group WidgetEvents "Widget events" {
	/**
	* @brief A struct that holds the data associated with a widget event.
	*/
	struct MAWidgetEventData {
		/**
		* @brief Determines which kind of widget event that has occurred. See \ref WidgetEventTypes "Widget event types" for the possible values.
		*/
		int eventType;

		/**
		* @brief Handle to the widget that sent the event.
		*/
		MAWidgetHandle widgetHandle;

		union {
			/**
			* @brief The index when a #MAW_EVENT_CLICKED event is receieved for a list view.
			*/
			int listItemIndex;

			/**
			* @brief The type of button that was clicked when a #MAW_EVENT_CLICKED event is receieved for a searchbar.
			* The type of searchbar button clicked:
			* - 0 means 'search'
			* - 1 means 'cancel'
			*/
			int searchBarButton;

			/**
			* @brief The new state of the checkbox when a #MAW_EVENT_CLICKED event is receieved for a checkbox or toggle button.
			* - 0 means 'unchecked'
			* - 1 means 'checked'
			*/
			int checked;

			/**
			* @brief The new tab index when a #MAW_EVENT_TAB_CHANGED event is received.
			*/
			int tabIndex;

			/**
			* @brief Used by event #MAW_EVENT_WEB_VIEW_CONTENT_LOADING.
			* One of:
			*  #MAW_CONSTANT_STARTED
			*  #MAW_CONSTANT_DONE
			*  #MAW_CONSTANT_STOPPED
			*  #MAW_CONSTANT_ERROR
			*/
			int status;

			/**
			* @brief Parameters for the #MAW_EVENT_WEB_VIEW_HOOK_INVOKED event.
			*/
			struct {
				/**
				* @brief The type of hook that has been invoked.
				* One of:
				*  #MAW_CONSTANT_SOFT
				*  #MAW_CONSTANT_HARD
				*/
				int hookType;

				/**
				* @brief The handle to url data. This is string data,
				* there is NO null terminating character. The encoding
				* of the data is determined by the application.
				* The data MUST be deallocated with maDestroyObject after
				* it hs been used. Each event allocates a new data object
				* for the url data.
				*/
				MAHandle urlData;
			} webViewHookInfo;

			/**
			* @brief TODO: Document when this structure is used.
			*/
			struct {
				/**
				* @brief The handle to the screen that was popped from the stack screen.
				*/
				MAWidgetHandle fromScreen;

				/**
				* @brief The handle to the screen that will be shown. If there is no screen
				* to pop to, this will be the same as widgetHandle.
				*/
				MAWidgetHandle toScreen;
			} stackScreenPopInfo;

			/**
			* The value of the slider when a #MAW_EVENT_SLIDER_VALUE_CHANGED event is received.
			*/
			int sliderValue;

			struct {
					/**
					* @brief The day value when a #MAW_EVENT_DATE_PICKER_VALUE_CHANGED event is received.
					*/
					int dayOfMonth;

					/**
					* @brief The month value when a #MAW_EVENT_DATE_PICKER_VALUE_CHANGED event is received.
					*/
					int month;

					/**
					* @brief The year value when a #MAW_EVENT_DATE_PICKER_VALUE_CHANGED event is received.
					*/
					int year;
			} datePickerValueInfo;

			struct {
					/**
					* @brief The hour value when a #MAW_EVENT_TIME_PICKER_VALUE_CHANGED event is received.
					*/
					int hour;

					/**
					* @brief The minute value when a #MAW_EVENT_TIME_PICKER_VALUE_CHANGED event is received.
					*/
					int minute;
			} timePickerValueInfo;

			/**
			* The value of the number picker when a #MAW_EVENT_NUMBER_PICKER_VALUE_CHANGED event is received.
			*/
			int numberPickerValue;

			/**
			* The new state of the Video view when a #MAW_EVENT_VIDEO_STATE_CHANGED event is received.
			* One of the MAW_VIDEO_WIDGET_STATE constants.
			*/
			int videoViewState;

			/**
			* Send by the OptionDialog view when a #MAW_EVENT_OPTION_DIALOG_BUTTON_CLICKED event is received.
			*/
			int optionDialogButtonIndex;
		}
	}

	/**
	* The available widget event types.
	*/
	group WidgetEventTypes "Widget event types" {
	constset int MAW_EVENT_ {
		/**
		* @brief A pointer pressed event has occurred.
		*/
		POINTER_PRESSED = 2;

		/**
		* @brief A pointer released event has occurred.
		*/
		POINTER_RELEASED = 3;

		/**
		* @brief This event is not used and has been deprecated.
		*
		* @deprecated Use #MAW_EVENT_WEB_VIEW_CONTENT_LOADING.
		*/
		CONTENT_LOADED = 4;

		/**
		* @brief Sent when something is clicked.
		*/
		CLICKED = 5;

		/**
		* @brief Sent when an item in a list view is clicked.
		*/
		ITEM_CLICKED = 6;

		/**
		* @brief Sent when a tab widget has changed to a new tab.
		*/
		TAB_CHANGED = 7;

		/**
		* @brief Sent when an GLView has been initialized and is ready for setup.
		*/
		GL_VIEW_READY = 8;

		/**
		 * @brief Sent when the URL of a web view changes
		 * @deprecated Use event #MAW_EVENT_WEB_VIEW_HOOK_INVOKED.
		 */
		WEB_VIEW_URL_CHANGED = 9;

		/**
		 * @brief Sent when a screen has been popped from a stack screen.
		 */
		STACK_SCREEN_POPPED = 10;

		/**
		 * @brief Sent when the progress level has been changed.
		 * This includes changes that were initiated by the user through a touch gesture,
         * or arrow key/trackball as well as changes that were initiated programmatically.
		 */
	    SLIDER_VALUE_CHANGED = 11;

		/**
		 * @brief Sent when the user changes\d the date in a Date Picker.
		 */
		DATE_PICKER_VALUE_CHANGED = 12;

		/**
		 * @brief Sent when the user changes\d the time in a Time Picker.
		 */
		TIME_PICKER_VALUE_CHANGED = 13;

		/**
		 * @brief Sent when the user changes\d the value in a Number Picker.
		 */
		NUMBER_PICKER_VALUE_CHANGED = 14;

		/**
		 * @brief Sent from the Video View when the state of the video has changed.
		 */
		VIDEO_STATE_CHANGED = 15;

        /**
         * @brief Sent from the Edit box when it gains focus(the user selects the widget).
         * The virtual keyboard is shown.
         * Only for iphone platform.
         */
         EDIT_BOX_EDITING_DID_BEGIN = 16;

        /**
         * @brief Sent from the Edit box when it loses focus.
         * The virtual keyboard is hidden.
         * Only for iphone platform.
         */
         EDIT_BOX_EDITING_DID_END = 17;

        /**
         * @brief Sent from the Edit box when the text was changed.
         */
         EDIT_BOX_TEXT_CHANGED = 18;

        /**
         * @brief Sent from the Edit box when the return button was pressed.
         * On iphone platform the virtual keyboard is not closed after receiving this event.
         * The virtual keyboard can be hided by setting the MAW_EDIT_BOX_SHOW_KEYBOARD to "false".
         */
         EDIT_BOX_RETURN = 19;

		/**
		* @brief A WebView widget reports status of loading
		* page content. Event parameter status is set to one
		* of the following values:
		*   #MAW_CONSTANT_STARTED
		*   #MAW_CONSTANT_DONE
		*   #MAW_CONSTANT_STOPPED
		*   #MAW_CONSTANT_ERROR
		*/
		WEB_VIEW_CONTENT_LOADING = 20;

		/**
		* @brief A web view hook has captured a url.
		*
		* The event parameter hookType is set to
		* the type of hook, one of:
		*   #MAW_CONSTANT_SOFT
		*   #MAW_CONSTANT_HARD
		*
		* Event parameter urlData is a handle to the url that
		* has been captured.
		*
		* Use syscall maGetDataSize to get the size of the url data
		* and maReadData to access the data.
		*
		* NOTE: When you get this message you have ownership
		* of the url data handle and you have the responsibility to
		* deallocate it using maDestroyObject.
		*
		* To get this event, you need to register a hook pattern, using
		* maWidgetSetProperty with the properties #MAW_WEB_VIEW_SOFT_HOOK
		* and/or #MAW_WEB_VIEW_HARD_HOOK.
		*/
		WEB_VIEW_HOOK_INVOKED = 21;

		/**
		* Send by a Dialog widget when when a user dismisses a popover by tapping outside of it.
		* It will not be sent if it was dismissed by calling #maWidgetModalDialogHide().
		* Available only on the iPad.
		*/
		DIALOG_DISMISSED = 22;

	}

	} // end of WidgetEventTypes

	} // end of WidgetEvents

	/**
	* The available constants for the widget api.
	*/
	group WidgetConstants "Widget constants" {
	constset int MAW_CONSTANT_ {
		/**
		* @brief A handle to the MoSync canvas screen. Use maWidgetScreenShow with this handle to show the initial mosync canvas.
		*/
		MOSYNC_SCREEN_HANDLE = 0;

		/**
		* @brief If set to the width or height of a widget and the parent is either a vertical or horizontal layout it tries to fill the available space in that dimension. If there are multiple widgets specified with this constant, the space will then be shared equally. If the parent isn't a horizontal or vertical layout it just resizes the child to the size of its parent.
		*/
		FILL_AVAILABLE_SPACE = -1;

		/**
		* @brief If set to the width or height of a widget it will be as big as its content in that dimension.
		*/
		WRAP_CONTENT = -2;

		/**
		* @brief Loading a page has started. Used in
		* #MAW_EVENT_WEB_VIEW_CONTENT_LOADED.
		*/
		STARTED = 1;

		/**
		* @brief Loading a page is done. Used in
		* #MAW_EVENT_WEB_VIEW_CONTENT_LOADED.
		*/
		DONE = 2;

		/**
		* @brief Loading a page has stopped (aborted). Used in
		* #MAW_EVENT_WEB_VIEW_CONTENT_LOADED.
		*/
		STOPPED = 3;

		/**
		* @brief Loading a page has failed. Used in
		* #MAW_EVENT_WEB_VIEW_CONTENT_LOADED.
		*/
		ERROR = -1;

		/**
		* @brief The hook type is a soft hook. Used in
		* #MAW_EVENT_WEB_VIEW_HOOK_INVOKED.
		*/
		SOFT = 5;

		/**
		* @brief The hook type is a hard hook. Used in
		* #MAW_EVENT_WEB_VIEW_HOOK_INVOKED.
		*/
		HARD = 6;

		/**
		* @brief The popover arrow should point up. Used in
		* #MAW_MODAL_DIALOG_ARROW_POSITION.
		*/
		ARROW_UP = 1;

		/**
		* @brief The popover arrow should point down. Used in
		* #MAW_MODAL_DIALOG_ARROW_POSITION.
		*/
		ARROW_DOWN = 2;

		/**
		* @brief The popover arrow should point left. Used in
		* #MAW_MODAL_DIALOG_ARROW_POSITION.
		*/
		ARROW_LEFT = 4;

		/**
		* @brief The popover arrow should point right. Used in
		* #MAW_MODAL_DIALOG_ARROW_POSITION.
		*/
		ARROW_RIGHT = 8;

		/**
		* @brief The popover arrow can point anywhere. Used in
		* #MAW_MODAL_DIALOG_ARROW_POSITION.
		*/
		ARROW_ANY = 15;

	}
	}

	group WidgetAlignment "Widget alignment" {
	constset MAString MAW_ALIGNMENT_
	{
		/**
		* @brief Constant that represents a left aligned widget.
		*/
		LEFT = "left";

		/**
		* @brief Constant that represents a right aligned widget.
		*/
		RIGHT = "right";

		/**
		* @brief Constant that represents a center aligned widget.
		*/
		CENTER = "center";

		/**
		* @brief Constant that represents a top aligned widget.
		*/
		TOP = "top";

		/**
		* @brief Constant that represents a bottom aligned widget.
		*/
		BOTTOM = "bottom";
	}
	}

	/**
	* The available playback actions for the video view. For more info see \ref WidgetVideoViewProperties.
	*/
	group VideoViewAction "Video view action" {
	constset int MAW_VIDEO_VIEW_ACTION_ {
		/**
		* @brief Play the video.
		*/
		PLAY = 1;

		/**
		* @brief Pause the video.
		*/
		PAUSE = 2;

		/**
		* @brief Stop the video.
		*/
		STOP = 3;
	}
	}

   /**
	* Events for the video view. When the state of the video view changes an event with one
	* of the next constants will be send.
    * NOTE: there is a slightly different behaviour depending on the platform:
    *  - on iOS the source is loaded into memory when
    *  MAW_VIDEO_VIEW_STATE_PLAYING is received.
    *   - on Android the source is loaded into memory when
    *  MAW_VIDEO_VIEW_STATE_SOURCE_READY is received.
	*/
	group VideoViewEvent "Video view event" {
	constset int MAW_VIDEO_VIEW_STATE_ {
		/**
		* @brief The video is playing.
		*/
		PLAYING = 1;

		/**
		* @brief The video is paused.
		*/
		PAUSED = 2;

		/**
		* @brief The video is stopped.
		*/
		STOPPED = 3;

		/**
		* @brief The video has finished playing.
		*/
		FINISHED = 4;

		/**
		* @brief The source is ready to be played.
		* NOTE: On Android this event is received after loading url/path.
		*       On iOS this event is received after PLAYING event is received.
		*/
		SOURCE_READY = 5;

		/**
		* @brief Playback is temporarily interruped(maybe there's no data in the buffer).
		*/
		INTERRUPTED = 6;

	}
	}

	/**
	* The available result codes for the widget api.
	*/
	group WidgetResultCodes "Widget result codes" {
	constset int MAW_RES_ {
		/**
		* @brief Indicates that the call to a widget syscall was successful.
		*/
		OK = 0;

		/**
		* @brief Indicates that the call to a widget syscall was unsuccessful.
		*/
		ERROR = -2;

		/**
		* @brief Indicates that the call to maWidgetSetProperty or maWidgetGetProperty received an invalid property name.
		*/
		INVALID_PROPERTY_NAME = -2;

		/**
		* @brief Indicates that the call to maWidgetSetProperty or maWidgetGetProperty received an invalid property value.
		*/
		INVALID_PROPERTY_VALUE = -3;

		/**
		* @brief Indicates that the call to a widget function received an invalid handle.
		*/
		INVALID_HANDLE = -4;

		/**
		* @brief Indicates that the call maWidgetCreate received an invalid type name.
		*/
		INVALID_TYPE_NAME = -5;

		/**
		* @brief Indicates that the call to maWidgetInsertChild received an invalid index.
		*/
		INVALID_INDEX = -6;

		/**
		* @brief Indicates that the call maWidgetGetProperty needs a larger buffer.
		*/
		INVALID_STRING_BUFFER_SIZE = -7;

		/**
		* @brief Indicates that maWidgetScreenShow received an invalid (non-screen) widget handle.
		*/
		INVALID_SCREEN = -8;

		/**
		* @brief Indicates that the caller tried to add a widget to a non-layout.
		*/
		INVALID_LAYOUT = -9;

		/**
		* @brief Indicates that the caller tried to remove a visible root widget (screen) and the MoSync view will become visible.
		*/
		REMOVED_ROOT = -10;

		/**
		* @brief Indicates that a syscall tried to access a feature that is not supported by the current framework version.
		*/
		FEATURE_NOT_AVAILABLE = -11;

		/**
		* @brief Indicates that a syscall tried to add a dialog to a parent, which cannot be done because dialogs are in fact
		* containers for other widgets.
		*/
		CANNOT_INSERT_DIALOG = -12;

	}
	} // end of WidgetResultCodes

	/**
	* The available widget types for maWidgetCreate().
	*/
	group WidgetTypes "Widget types" {
	constset MAString MAW_ {
		/**
		* @brief A screen is the root of all widgets currently visible on a screen. See \ref WidgetScreenProperties "Screen properties" for the properties available.
		*/
		SCREEN = "Screen";

		/**
		* @brief A tab screen is a special type of screen that can have any number of sub-screens each switchable using a tab bar. See \ref WidgetTabScreenProperties "Tab screen properties" for the properties available.
		*/
		TAB_SCREEN = "TabScreen";

		/**
		* @brief A stack screen is a special type of screen that manages navigation
		* between a set of screens.
		*
		* The screen stack can be pushed or popped. Pushing a given screen will hide
		* the current screen and display the pushed screen. Popping a screen hides
		* the current screen and shows the previous screen in the stack. See
		* maWidgetStackScreenPush() and maWidgetStackScreenPop().
		*
		* Navigation between the screens in the stack is handled according to the
		* norm on the specific platform. On iPhone a navigation bar is added to each
		* pushed screen that can be used to go back, while on Android there is no
		* extra UI added and the back button is used to go back to the previous screen.
		* See \ref WidgetStackScreenProperties "Stack screen properties" for the
		* properties available.
		*/
		STACK_SCREEN = "StackScreen";

		/**
		* @brief A button is a widget that represent a physical button that can be pressed. See \ref WidgetButtonProperties "Button properties" for the properties available.
		*/
		BUTTON = "Button";

		/**
		* @brief An image is a widget that can be used to display an image. See \ref WidgetImageProperties "Image properties" for the properties available.
		*/
		IMAGE = "Image";

		/**
		* @brief An image button is a button that will also affect the appearance of the background image when pressed. See \ref WidgetImageButtonProperties "Image button properties" for the properties available.
		*/
		IMAGE_BUTTON = "ImageButton";

		/**
		* @brief A label is a widget that can be used to display static non-editable text. See \ref WidgetLabelProperties "Label properties" for the properties available.
		*/
		LABEL = "Label";

		/**
		* @brief An editbox is an editable label. See \ref WidgetEditBoxProperties "Editbox properties" for the properties available.
		*/
		EDIT_BOX = "EditBox";

		/**
		* @brief A list view is a vertical list of widgets that is also scrollable.
		*/
		LIST_VIEW = "ListView";

		/**
		* @brief A list view item is a special kind of layout compatible with the list view. That has a predefined common layout for adding text, an icon etc. See \ref WidgetListViewItemProperties "List view item properties" for the properties available.
		*/
		LIST_VIEW_ITEM = "ListViewItem";

		/**
		 * @brief A check box is a widget that acts like a physical switch. When pressed it will toggle its internal state that can either be checked or non-checked. See \ref WidgetCheckBoxProperties "Check box properties" for the properties available.
		 * If you want to display it with a "light" indicator, as it is on iOS use a Toggle Button instead.

		 */
		CHECK_BOX = "CheckBox";

		/**
		 * @brief A horizontal layout is a layout that stacks widgets in the horizontal axis. See \ref WidgetHorizontalLayoutProperties "Horizontal layout properties" for the properties available.
		 */
		HORIZONTAL_LAYOUT = "HorizontalLayout";

		/**
		 * @brief A vertical layout is a layout that stacks widgets in the vertical axis. See \ref WidgetVerticalLayoutProperties "Vertical layout properties" for the properties available.
		 */
		VERTICAL_LAYOUT = "VerticalLayout";

		/**
		 * @brief A relative layout is a layout that layouts widgets relative to its coordinate system.
		 */
		RELATIVE_LAYOUT = "RelativeLayout";

		/**
		 * @brief A search bar is a special kind of edit box that is used for searching. See \ref WidgetSearchBarProperties "Search bar properties" for the properties available.
		 */
		SEARCH_BAR = "SearchBar";

		/**
		 * @brief A nav bar is an iphone specific widget that shows a nav bar with an optional title and back button. See \ref WidgetNavBarProperties "Nav bar properties" for the properties available.
		 * See \ref WidgetNavBarProperties "Navigation Bar properties" for the properties available.
		 */
		NAV_BAR = "NavBar";

		/**
		 * @brief A GL view is a widget that is used to display graphics rendered by the GPU using OpenGL|ES 1.0/1.1 calls. See \ref WidgetGLViewProperties "GL view properties" for the properties available.
		 */
		GL_VIEW = "GLView";

		/**
		 * @brief A GL view is a widget that is used to display graphics rendered by the GPU using OpenGL|ES 2.0 calls. See \ref WidgetGLViewProperties "GL view properties" for the properties available.
		 */
		GL2_VIEW = "GL2View";

		/**
		 * @brief A Camera preview widget is a widget that can bound to a camera and contain the live veiw data from the camera.
		 */
		CAMERA_PREVIEW="CameraPreview";

		/**
		 * @brief A web view is a widget used to render web pages. See \ref WidgetWebViewProperties "Web view properties" for the properties available.
		 */
		WEB_VIEW = "WebView";

		/**
		 * @brief A progress bar is a visual indicator of progress in some operation.
		 * Displays a bar to the user representing how far the operation has progressed.
		 * A progress bar can also be made indeterminate, when the length of the task is unknown.
		 *
		 * See \ref WidgetProgressBarProperties "Progress bar properties" for the properties available.
		 */
		PROGRESS_BAR = "ProgressBar";

		 /**
		 * @brief An activity indicator is a visual indicator of progress in some operation.
		 * It shows a cyclic animation without an indication of progress.
		 * It is used when the length of the task is unknown.
		 *
		 * See \ref WidgetActivityIndicatorProperties "Activity Indicator properties" for the properties available.
		 */
		ACTIVITY_INDICATOR = "ActivityIndicator";

		/**
		 * @brief A Slider is an extension of ProgressBar that adds a draggable thumb.
		 * The user can touch the thumb and drag left or right to set the current progress level.
		 *
		 * See \ref WidgetSliderProperties "Slider properties" for the properties available.
		 */
		SLIDER = "Slider";

		/**
		 * @brief A Date Picker is a widget for selecting a date. The date can be selected by a year, month, and day spinners.
		 * The minimal and maximal date from which dates to be selected can be customized.
		 * The picker is initialized with the current system date.
		 *
		 * See \ref WidgetDatePickerProperties "Date Picker properties" for the properties available.
		 */
		DATE_PICKER = "DatePicker";

		/**
		 * @brief A Time Picker is a widget for selecting time of day, in 24 hour mode.
		 * The hour and each minute digit can be controlled by vertical spinners.
		 * The hour can be entered by keyboard input.
		 * Availabe only on iOS for the moment.
		 * See \ref WidgetTimePickerProperties "Time Picker properties" for the properties available.
		 */
		TIME_PICKER = "TimePicker";

		/**
		 * @brief A Number Picker is a widget that enables the user to select a number from a predefined range.
		 * Note: for the moment it is available only on iOS.
		 * See \ref WidgetNumberPickerProperties "Number Picker properties" for the properties available.
		 */
		NUMBER_PICKER = "NumberPicker";

		/**
		 * @brief A Video View displays a video file.
		 * By default, it has attached a controller view that typically contains the buttons like
		 * "Play/Pause", "Rewind", "Fast Forward" and a progress slider.
		 * See \ref WidgetVideoViewProperties "Video View properties" for the properties available.
		 */
		VIDEO_VIEW = "VideoView";

		/**
		 * @brief A Toggle Button is a widget that acts like a physical switch. Displays checked/unchecked states as a button with a "light" indicator and by default accompanied with the text "ON" or "OFF".
		 * It is available only on Android, and it's similar to the Check Box on iOS.
		 * When pressed it will toggle its internal state that can either be checked or non-checked. See \ref WidgetToggleButtonProperties "Toggle button properties" for the properties available.
		 */
		TOGGLE_BUTTON = "ToggleButton";

		/**
		* @brief A dialog is a sort of modal view, that can look different depending on the platform.
		* A Dialog gets visible only after calling maWidgetModalDialogShow().
		* On Android it is a modal alert dialog.
		* On iPad it is a PopoverController, and on iPhone it is a modal view.
		* When a Dialog widget is created it is empty, it has no content. Any type of widget can be added inside it via #maWidgetAddChild syscalls.
		* To show a Dialog call #maWidgetModalDialogShow(), to dismiss it call: #maWidgetModalDialogHide(), and to delete it call #maWidgetDestroy.
		* See \ref WidgetModalDialogProperties "Modal Dialog properties" for the properties available.
		*/
		MODAL_DIALOG = "ModalDialog";
	}
	} // end of WidgetTypes


	/**
	* All widgets have a set of properties that can be set. In order to set them, use maWidgetSetProperty(). These properties may change
	* things like the visual appearance of the widget or the way it works.
	*/
	group WidgetProperties "Widget properties" {

	/**
	* The available widget properties for all widgets.
	*/
	constset MAString MAW_WIDGET_ {
		/**
		* @brief Sets or gets the horizontal distance from the parent widget in a RelativeLayout.
		*
		* @validvalue A positive integer in number of pixels.
		*
		* @setandget
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(widgetHandle, MAW_WIDGET_LEFT, "100");
		* \endcode
		*/
		LEFT = "left";

		/**
		* @brief Specifies the vertical distance from the parent widget in a RelativeLayout.
		*
		* @validvalue A positive integer in number of pixels.
		*
		* @setandget
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(widgetHandle, MAW_WIDGET_TOP, "100");
		* \endcode
		*/
		TOP = "top";

		/**
		* @brief Sets or gets the width of a widget.
		*
		* @validvalue A positive integer in pixles, or any of the constants #MAW_CONSTANT_FILL_AVAILABLE_SPACE, #MAW_CONSTANT_WRAP_CONTENT.
		*
		* @setandget
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(widgetHandle, MAW_WIDGET_WIDTH, "100");
		*	maWidgetSetProperty(widgetHandle, MAW_WIDGET_WIDTH, MAW_CONSTANT_FILL_AVAILABLE_SPACE);
		* \endcode
		*/
		WIDTH = "width";

		/**
		* @brief Sets or gets the height of a widget.
		*
		* @validvalue A positive integer in pixles, or any of the constants #MAW_CONSTANT_FILL_AVAILABLE_SPACE, #MAW_CONSTANT_WRAP_CONTENT.
		*
		* @setandget
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(widgetHandle, MAW_WIDGET_HEIGHT, "100");
		*	maWidgetSetProperty(widgetHandle, MAW_WIDGET_HEIGHT, MAW_CONSTANT_FILL_AVAILABLE_SPACE);
		* \endcode
		*/
		HEIGHT = "height";

		/**
		* @brief Sets the transparency of the widget background.
		*
		* @validvalue A floay between 0.0 and 1.0, where 0.0 is fully transparent and 1.0 is opaque.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(widgetHandle, MAW_WIDGET_ALPHA, "0.0"); // Not visible
		*	maWidgetSetProperty(widgetHandle, MAW_WIDGET_ALPHA, "0.5"); // Half visible
		*	maWidgetSetProperty(widgetHandle, MAW_WIDGET_ALPHA, "1.0"); // Fully visible
		* \endcode
		*/
		ALPHA = "alpha";

		/**
		* @brief Specifies the background color of a widget.
		*
		* @validvalue A hexadecimal value 0xRRGGBB, where R, G and B are the red, green and blue components respectively.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(widgetHandle, MAW_WIDGET_BACKGROUND_COLOR, "0xff0000"); // Red
		* \endcode
		*/
		BACKGROUND_COLOR = "backgroundColor";

		/**
		* @brief Sets whether the widget is visible or not. Layouts ignore invisible widgets.
		*
		* @validvalue A boolean string 'true' or 'false', where true is visible and false is invisible.
		*
		* @setandget
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(widgetHandle, MAW_WIDGET_VISIBLE, "false");
		* \endcode
		*/
		VISIBLE = "visible";

		/**
		* @brief Sets whether the widget is enabled or not. If not, the widget is grayed out.
		*
		* Widgets are enabled by default.
		*
		* @validvalue A boolean string 'true' or 'false', where true is enabled and false is disabled.
		*
		* @setandget
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(buttonHandle, MAW_WIDGET_ENABLED, "false");
		* \endcode
		*/
		ENABLED = "enabled";

		/**
		* @brief Specifies the background gradient of a widget.
		* Currently implemented only on Android.
		*
		* @validvalue Two hexadecimal values 0xRRGGBB, where R, G and B are the red, green and blue components respectively,
		* separated by comma.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(widgetHandle, MAW_WIDGET_BACKGROUND_GRADIENT,  "0x27408B,0xCAE1FF");
		* \endcode
		*/
		BACKGROUND_GRADIENT = "backgroundGradient";
	}

	/**
	* The available widget properties for a #MAW_SCREEN. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetScreenProperties "Screen properties" {
	constset MAString MAW_SCREEN_ {
		/**
		* @brief Sets the title of a screen. The screen title is used by tab screen to display a text on the tab indicator.
		*
		* @validvalue Null terminated string. The length of the string should be short enough to fit in a tab indicator.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(screenHandle, MAW_SCREEN_TITLE, "My title");
		* \endcode
		*/
		TITLE = "title";

		/**
		* @brief Sets an icon for a screen. The icon is used by a tab screen to display an icon on the tab indicator.
		*
		* @validvalue MoSync handle to an uncompressed image resource. The size of the image should be small enough to fit in a tab indicatior.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(screenHandle, MAW_SCREEN_ICON, toString(R_MY_ICON));
		* \endcode
		*/
		ICON = "icon";
	}
	} // end of WidgetScreenProperties

	/**
	* The available widget properties for a #MAW_TAB_SCREEN. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetTabScreenProperties "Tab screen properties" {
	constset MAString MAW_TAB_SCREEN_ {
		/**
		* @copydoc MAW_SCREEN_TITLE
		*/
		TITLE = "title";

		/**
		* @copydoc MAW_SCREEN_ICON
		*/
		ICON = "icon";

		/**
		* @brief Sets or gets the currently open tab to the tab with the given index.
		*
		* @validvalue A 0-indexed tab number.
		*
		* @setandget
		*
		* @par Example set
		* \code
		*	maWidgetSetProperty(tabScreenHandle, MAW_TAB_SCREEN_CURRENT_TAB, "1");
		* \endcode
		*
		* @par Example get
		* \code
		* 	char currentTabBuffer[BUFFER_SIZE];
		* 	int result = maWidgetGetProperty(
		* 		tabScreenHandle,
		* 		MAW_WEB_VIEW_CURRENT_TAB,
		* 		currentTabBuffer,
		*		BUFFER_SIZE);
		* 	if (result > 0)
		* 	{
		* 	    // Do something with current tab.
		* 	}
		* \endcode
		*/
		CURRENT_TAB = "currentTab";
	}
	} // end of WidgetTabScreenProperties

	/**
	* The available widget properties for a #MAW_STACK_SCREEN. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetStackScreenProperties "Stack screen properties" {
	constset MAString MAW_STACK_SCREEN_ {
		/**
		* @copydoc #MAW_SCREEN_TITLE
		*/
		TITLE = "title";

		/**
		* @copydoc #MAW_SCREEN_ICON
		*/
		ICON = "icon";

		/**
		* @brief Specifies whether the back button automatically should pop the stack screen.
		*
		* This can have different behaviors on different platforms, on iPhone the UI back button is disabled, on Android the stack screen ignores back button events.
		*
		* @validvalue A boolean string 'true' or 'false'.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(stackScreenHandle, MAW_STACK_SCREEN_BACK_BUTTON_ENABLED, "false");
		* \endcode
		*/
		BACK_BUTTON_ENABLED = "backButtonEnabled";

	}
	} // end of WidgetStackScreenProperties

	/**
	* The available widget properties for a #MAW_LABEL. See of \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetLabelProperties "Label properties" {
	constset MAString MAW_LABEL_ {
		/**
		* @brief Sets or gets the text that is displayed in the label.
		*
		* @validvalue A null-terminated string.
		*
		* @setandget
		*
		* @par Example set
		* \code
		*	maWidgetSetProperty(labelHandle, MAW_LABEL_TEXT, "My label");
		* \endcode
		*
		* @par Example get
		* \code
		* 	char textBuffer[BUFFER_SIZE];
		* 	int result = maWidgetGetProperty(labelHandle, MAW_LABEL_TEXT, textBuffer, BUFFER_SIZE);
		* 	if (result > 0)
		* 	{
		* 	    // Do something with the label text.
		* 	}
		* \endcode
		*/
		TEXT = "text";

		/**
		* @brief Sets the vertical alignment of the text inside the label. If the widget's height is WRAP_CONTENT this property has no effect.
		*
		* @validvalue One of the constants #MAW_ALIGNMENT_TOP, #MAW_ALIGNMENT_CENTER or #MAW_ALIGNMENT_BOTTOM.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(labelHandle, MAW_LABEL_TEXT_VERTICAL_ALIGNMENT, MAW_ALIGNMENT_CENTER);
		* \endcode
		*/
		TEXT_VERTICAL_ALIGNMENT = "textVerticalAlignment";

		/**
		* @brief Sets the horizontal alignment of the text inside the label. If the widget's height is WRAP_CONTENT this property has no effect.
		*
		* @validvalue Takes one of the constants #MAW_ALIGNMENT_TOP, #MAW_ALIGNMENT_CENTER or #MAW_ALIGNMENT_BOTTOM.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(labelHandle, MAW_LABEL_TEXT_HORIZONTAL_ALIGNMENT, MAW_ALIGNMENT_CENTER);
		* \endcode
		*/
		TEXT_HORIZONTAL_ALIGNMENT = "textHorizontalAlignment";

		/**
		* @brief Sets the font color of the label's text.
		*
		* @validvalue A hexadecimal value 0xRRGGBB, where R, G and B are the red, green and blue components respectively.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(labelHandle, MAW_LABEL_FONT_COLOR, "0xff0000");
		* \endcode
		*/
		FONT_COLOR = "fontColor";

		/**
		* @brief Sets the font size in points of the label's text.
		*
		* @validvalue A float that specifies the number of points.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(labelHandle, MAW_LABEL_FONT_SIZE, "13.0");
		* \endcode
		*/
		FONT_SIZE = "fontSize";

		/**
		* @brief Sets the typeface and style in which the text should be displayed.
		*
		* @validvalue A font handle received from loading fonts using
		* #maFontGetName and #maFontLoadWithName syscalls.
		*
		* @setonly
		*
		* @par Example
		* \code
		*   int nrFonts = maFontGetCount();
		*    char buf[256];
		*    // Get first font name.
		*    maFontGetName(1, buf, 256);
		*    // Load that font for size 10.
		*    int fontHandle = maFontLoadWithName(buf, 10);
		*    // Set that font to the label.
		*	maWidgetSetProperty(labelHandle, MAW_LABEL_FONT_HANDLE, toString(fontHandle));
		* \endcode
		*/
		FONT_HANDLE = "fontHandle";

		/**
		* @brief Sets the maximum number of lines used for rendering text.
		* To remove any maximum limit, and use as many lines as needed, set the value of this property to 0.
		*
		* @validvalue An integer that specifies the maximum number of lines.
		*
		* @setandget.
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(labelHandle, MAW_LABEL_MAX_NUMBER_OF_LINES, "3");
		* \endcode
		*/
		MAX_NUMBER_OF_LINES = "maxNumberOfLines";
	}
	} // end of WidgetLabelProperties

	/**
	* The available widget properties for a #MAW_BUTTON. See of \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetButtonProperties "Button properties" {
	constset MAString MAW_BUTTON_ {
		/**
		* @brief Sets or gets the text that is displayed in the label.
		*
		* @validvalue A null-terminated string.
		*
		* @setandget
		*
		* @par Example set
		* \code
		*	maWidgetSetProperty(buttonHandle, MAW_BUTTON_TEXT, "My button");
		* \endcode
		*
		* @par Example get
		* \code
		* 	char textBuffer[BUFFER_SIZE];
		* 	int result = maWidgetGetProperty(buttonHandle, MAW_BUTTON_TEXT, textBuffer, BUFFER_SIZE);
		* 	if (result > 0)
		* 	{
		* 	    // Do something with the label text.
		* 	}
		* \endcode
		*/
		TEXT = "text";

		/**
		* @brief Sets the vertical alignment of the text inside the button. If the widget's height is WRAP_CONTENT this property has no effect.
		*
		* @validvalue One of the constants #MAW_ALIGNMENT_TOP, #MAW_ALIGNMENT_CENTER or #MAW_ALIGNMENT_BOTTOM.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(buttonHandle, MAW_BUTTON_TEXT_VERTICAL_ALIGNMENT, MAW_ALIGNMENT_CENTER);
		* \endcode
		*/
		TEXT_VERTICAL_ALIGNMENT = "textVerticalAlignment";

		/**
		* @brief Sets the horizontal alignment of the text inside the button. If the widget's width is WRAP_CONTENT this property has no effect.
		*
		* @validvalue Takes one of the constants #MAW_ALIGNMENT_LEFT, #MAW_ALIGNMENT_CENTER or #MAW_ALIGNMENT_RIGHT.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(buttonHandle, MAW_BUTTON_TEXT_HORIZONTAL_ALIGNMENT, MAW_ALIGNMENT_CENTER);
		* \endcode
		*/
		TEXT_HORIZONTAL_ALIGNMENT = "textHorizontalAlignment";

		/**
		* @brief Sets the font color of the button's text.
		*
		* @validvalue A hexadecimal value 0xRRGGBB, where R, G and B are the red, green and blue components respectively.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(buttonHandle, MAW_BUTTON_FONT_COLOR, "0xff0000");
		* \endcode
		*/
		FONT_COLOR = "fontColor";

		/**
		* @brief Sets the font size in points of the button's text.
		*
		* @validvalue A float that specifies the number of points.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(buttonHandle, MAW_BUTTON_FONT_SIZE, "13.0");
		* \endcode
		*/
		FONT_SIZE = "fontSize";

		/**
		* @brief Sets the typeface and style in which the text should be displayed.
		*
		* @validvalue A font handle received from loading fonts using
		* #maFontGetName and #maFontLoadWithName syscalls.
		*
		* @setonly
		*
		* @par Example
		* \code
		*   int nrFonts = maFontGetCount();
		*    char buf[256];
		*    // Get first font name.
		*    maFontGetName(1, buf, 256);
		*    // Load that font for size 10.
		*    int fontHandle = maFontLoadWithName(buf, 10);
		*    // Set that font to the label.
		*	maWidgetSetProperty(buttonHandle, MAW_BUTTON_FONT_HANDLE, toString(fontHandle));
		* \endcode
		*/
		FONT_HANDLE = "fontHandle";
	}
	} // end of WidgetButtonProperties

	/**
	* The available widget properties for a #MAW_IMAGE_BUTTON. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetImageButtonProperties "Image button properties" {
	constset MAString MAW_IMAGE_BUTTON_ {
		/**
		* @brief Sets or gets the text that is displayed in the label.
		* Note: It is not available on Android, as native image buttons do not have text attached.
		* @validvalue A null-terminated string.
		*
		* @setandget
		*
		* @par Example set
		* \code
		*	maWidgetSetProperty(imageButtonHandle, MAW_IMAGE_BUTTON_TEXT, "My button");
		* \endcode
		*
		* @par Example get
		* \code
		* 	char textBuffer[BUFFER_SIZE];
		* 	int result = maWidgetGetProperty(imageButtonHandle, MAW_IMAGE_BUTTON_TEXT, textBuffer, BUFFER_SIZE);
		* 	if (result > 0)
		* 	{
		* 	    // Do something with the label text.
		* 	}
		* \endcode
		*/
		TEXT = "text";

		/**
		* @brief Sets the vertical alignment of the text inside the button. If the widget's height is WRAP_CONTENT this property has no effect.
		*
		* @validvalue One of the constants #MAW_ALIGNMENT_TOP, #MAW_ALIGNMENT_CENTER or #MAW_ALIGNMENT_BOTTOM.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(imageButtonHandle, MAW_IMAGE_BUTTON_TEXT_VERTICAL_ALIGNMENT, MAW_ALIGNMENT_CENTER);
		* \endcode
		*/
		TEXT_VERTICAL_ALIGNMENT = "textVerticalAlignment";

		/**
		* @brief Sets the horizontal alignment of the text inside the button. If the widget's height is WRAP_CONTENT this property has no effect.
		*
		* @validvalue Takes one of the constants #MAW_ALIGNMENT_TOP, #MAW_ALIGNMENT_CENTER or #MAW_ALIGNMENT_BOTTOM.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(imageButtonHandle, MAW_IMAGE_BUTTON_TEXT_HORIZONTAL_ALIGNMENT, MAW_ALIGNMENT_CENTER);
		* \endcode
		*/
		TEXT_HORIZONTAL_ALIGNMENT = "textHorizontalAlignment";

		/**
		* @brief Sets the font color of the button's text.
		*
		* @validvalue A hexadecimal value 0xRRGGBB, where R, G and B are the red, green and blue components respectively.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(imageButtonHandle, MAW_IMAGE_BUTTON_FONT_COLOR, "0xff0000");
		* \endcode
		*/
		FONT_COLOR = "fontColor";

		/**
		* @brief Sets the font size in points of the button's text.
		*
		* @validvalue A float that specifies the number of points.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(imageButtonHandle, MAW_IMAGE_BUTTON_FONT_SIZE, "13.0");
		* \endcode
		*/
		FONT_SIZE = "fontSize";

		/**
		* Sets the background image. This will be scaled to fit the whole widget (not keeping the aspect).
		*
		* @validvalue MoSync handle to an uncompressed image resource.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(imageButtonHandle, MAW_IMAGE_BUTTON_BACKGROUND_IMAGE, toString(R_MY_IMAGE));
		* \endcode
		*/
		BACKGROUND_IMAGE = "backgroundImage";

		/**
		* Sets the foreground image of the button. This won't be scaled at all.
		*
		* @validvalue MoSync handle to an uncompressed image resource.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(imageButtonHandle, MAW_IMAGE_BUTTON_IMAGE, toString(R_MY_IMAGE));
		* \endcode
		*/
		IMAGE = "image";

		/**
		* @brief Sets the typeface and style in which the text should be displayed.
		*
		* @validvalue A font handle received from loading fonts using
		* #maFontGetName and #maFontLoadWithName syscalls.
		* Note: It is not available on Android, as native image buttons do not have text attached.
		* @setonly
		*
		* @par Example
		* \code
		*   int nrFonts = maFontGetCount();
		*    char buf[256];
		*    // Get first font name.
		*    maFontGetName(1, buf, 256);
		*    // Load that font for size 10.
		*    int fontHandle = maFontLoadWithName(buf, 10);
		*    // Set that font to the label.
		*	maWidgetSetProperty(imageButtonHandle, MAW_IMAGE_BUTTON_FONT_HANDLE, toString(fontHandle));
		* \endcode
		*/
		FONT_HANDLE = "fontHandle";
	}
	} // end of WidgetImageButtonProperties

	/**
	* The available widget properties for a #MAW_IMAGE. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetImageProperties "Image properties" {
	constset MAString MAW_IMAGE_ {
		/**
		* Sets the image that will be displayed.
		*
		* @validvalue MoSync handle to an uncompressed image resource.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(buttonHandle, MAW_IMAGE_IMAGE, toString(R_MY_IMAGE));
		* \endcode
		*/
		IMAGE = "image";

		/**
		* @brief Specifies what type of scaling should be applied to the image.
		*
		* @validvalue Either 'none', 'scaleXY' or 'scalePreserveAspect'. Default 'none'.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(imageHandle, MAW_IMAGE_SCALE_MODE, "scaleXY");
		* \endcode
		*/
		SCALE_MODE = "scaleMode";
	}
	} // end of WidgetImageProperties

	group WidgetEditBoxConstants "Edit box constants" {
	    constset int MAW_EDIT_BOX_TYPE_ {
	        /**
			* The user is allowed to enter any text, including line breaks.
			*/
			ANY = 0;
			/**
			* The user is allowed to enter an e-mail address.
			*/
			EMAILADDR = 1;
			/**
			* The user is allowed to enter an integer value.
			*/
			NUMERIC = 2;
			/**
			* The user is allowed to enter a phone number.
			*/
			PHONENUMBER = 3;
			/**
			* The user is allowed to enter a URL.
			*/
			URL = 4;
			/**
            * The user is allowed to enter a real number value.
			* This extends #MAW_EDIT_BOX_TYPE_NUMERIC by allowing a decimal point.
			*/
			DECIMAL = 5;
			/**
			* The user is allowed to enter any text, except for line breaks.
			* Unavailable on some platforms.
			*/
			SINGLE_LINE = 6;
	    }

	    constset int MAW_EDIT_BOX_FLAG_ {
			/**
			* Indicates that the text entered is confidential data that should be
			* obscured whenever possible. This implies #MAW_EDIT_BOX_FLAG_SENSITIVE.
			*/
			PASSWORD = 0;
			/**
			* Indicates that the text entered is sensitive data that the implementation
			* must never store into a dictionary or table for use in predictive, auto-completing,
			* or other accelerated input schemes. A credit card number is an example of sensitive data.
			* Only for Android platform.
			*/
			SENSITIVE = 1;
			/**
			* This flag is a hint to the implementation that during text editing,
			* the initial letter of each word should be capitalized.
			*/
			INITIAL_CAPS_WORD = 2;
			/**
			* This flag is a hint to the implementation that during text editing,
			* the initial letter of each sentence should be capitalized.
			*/
			INITIAL_CAPS_SENTENCE = 3;
			/**
			* Capitalize all characters automatically.
			*/
			INITIAL_CAPS_ALL_CHARACTERS = 4;
	    }
	} // end of WidgetEditBoxConstants

	/**
	* The available widget properties for a #MAW_EDIT_BOX. See of \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetEditBoxProperties "Edit box properties" {
	constset MAString MAW_EDIT_BOX_ {
		/**
		* @brief Set or get the text entered in the edit box.
		*
		* @validvalue A null-terminated string.
		*
		* @setandget
		*
		* @par Example set
		* \code
		*	maWidgetSetProperty(editBoxHandle, MAW_EDIT_BOX_TEXT, "My label");
		* \endcode
		*
		* @par Example get
		* \code
		* 	char textBuffer[BUFFER_SIZE];
		* 	int result = maWidgetGetProperty(editBoxHandle, MAW_EDIT_BOX_TEXT, textBuffer, BUFFER_SIZE);
		* 	if (result > 0)
		* 	{
		* 	    // Do something with the edit box text
		* 	}
		* \endcode
		*/
		TEXT = "text";

		/**
		* @brief Set a text in the edit box that acts as a placeholder when an edit box is empty.
		*
		* @validvalue A null-terminated string.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(editBoxHandle, MAW_EDIT_BOX_PLACEHOLDER, "Enter text...");
		* \endcode
		*/
		PLACEHOLDER = "placeholder";

		/**
		* @brief Shows or hides the virtual keyboard. If shown the focus will be set to this widget.
		*
		* @validvalue A boolean string 'true' or 'false'.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(editBoxHandle, MAW_EDIT_BOX_SHOW_KEYBOARD, "true");
		* \endcode
		*/
		SHOW_KEYBOARD = "showKeyboard";

		/**
		* @brief Specifies what editing mode the edit box should have.
		* @deprecated use #MAW_EDIT_BOX_INPUT_FLAG instead.
		* @validvalue Either 'password' or 'text'.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(editBoxHandle, MAW_EDIT_BOX_EDIT_MODE, "password");
		* \endcode
		*/
		EDIT_MODE = "editMode";

		/**
		* @brief Specifies what editing mode the edit box should have.
		*
		* @validvalue One of the values #MAW_EDIT_BOX_TYPE_ANY, #MAW_EDIT_BOX_TYPE_EMAILADDR,
		* #MAW_EDIT_BOX_TYPE_NUMERIC, #MAW_EDIT_BOX_TYPE_PHONENUMBER, #MAW_EDIT_BOX_TYPE_URL,
		* #MAW_EDIT_BOX_TYPE_DECIMAL, #MAW_EDIT_BOX_TYPE_SINGLELINE.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(editBoxHandle, MAW_EDIT_BOX_INPUT_MODE, toString(MAW_EDIT_BOX_NUMERIC);
		* \endcode
		*/
		INPUT_MODE = "inputMode";

		/**
		* @brief Specifies the editing flags applied to the edit box.
		*
		* @validvalue One of the values #MAW_EDIT_BOX_FLAG_PASSWORD,
		* #MAW_EDIT_BOX_FLAG_SENSITIVE, #MAW_EDIT_BOX_FLAG_INITIAL_CAPS_ALL_CHARACTERS,
		* #MAW_EDIT_BOX_FLAG_INITIAL_CAPS_WORD, #MAW_EDIT_BOX_FLAG_INITIAL_CAPS_SENTENCE.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(editBoxHandle, MAW_EDIT_BOX_INPUT_FLAG, toString(MAW_EDIT_BOX_FLAG_PASSWORD));
		* \endcode
		*/
		INPUT_FLAG = "inputFlag";
	}
	} // end of WidgetEditBoxProperties

	/**
	* The available widget properties for a #MAW_LIST_VIEW_ITEM. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetListViewItemProperties "List view item properties" {
	constset MAString MAW_LIST_VIEW_ITEM_ {
		/**
		* @brief Sets the text part of the list view item. If there is an icon the text will be placed to the right of it, otherwise near the left edge.
		*
		* @validvalue A null-terminated string.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(listViewItemHandle, MAW_LIST_VIEW_ITEM_TEXT, "My label");
		* \endcode
		*/
		TEXT = "text";

		/**
		* @brief Sets an icon of the list view item that is placed to the left of the text.
		*
		* @validvalue MoSync handle to an uncompressed image resource.
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(listViewItemHandle, MAW_LIST_VIEW_ITEM_ICON, toString(R_MY_ICON));
		* \endcode
		*/
		ICON = "icon";

		/**
		* @brief Sets the type of list item displayed. Provides the corresponding icon in the right side of the list view.
		*
		* @note Only available for iOS.
		*
		* @validvalue One of "none", "hasChildren", "hasDetails" or "isChecked".
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(listViewItemHandle, MAW_LIST_VIEW_ITEM_ACCESSORY_TYPE, "hasChildren");
		* \endcode
		*/
		ACCESSORY_TYPE = "accessoryType";

		/**
		* @brief Sets the font color of the text part.
		*
		* @validvalue  A hexadecimal value 0xRRGGBB, where R, G and B are the red, green and blue components respectively.
		*
		* @setonly
		*
		* @par Example set the font color to red.
		* \code
		*	maWidgetSetProperty(listViewItemHandle, MAW_LIST_VIEW_ITEM_FONT_COLOR, "0xFF0000");
		* \endcode
		*/
		FONT_COLOR = "fontColor";

		/**
		* @brief Sets the font size in points of the text part.
		*
		* @validvalue A float that specifies the number of points.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(listViewItemHandle, MAW_LIST_VIEW_ITEM_FONT_SIZE, "13.0");
		* \endcode
		*/
		FONT_SIZE = "fontSize";

		/**
		* @brief Sets the typeface and style in which the text should be displayed.
		*
		* @validvalue A font handle received from loading fonts using
		* #maFontGetName and #maFontLoadWithName syscalls.
		*
		* @setonly
		*
		* @par Example
		* \code
		*   int nrFonts = maFontGetCount();
		*    char buf[256];
		*    // Get first font name.
		*    maFontGetName(1, buf, 256);
		*    // Load that font for size 10.
		*    int fontHandle = maFontLoadWithName(buf, 10);
		*    // Set that font to the list view item.
		*	maWidgetSetProperty(listViewItemHandle, MAW_LIST_VIEW_ITEM_FONT_HANDLE, toString(fontHandle));
		* \endcode
		*/
		FONT_HANDLE = "fontHandle";
	}
	} // end of WidgetListViewItemProperties

	/**
	* The available widget properties for a #MAW_CHECK_BOX. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetCheckBoxProperties "Check box properties" {
	constset MAString MAW_CHECK_BOX_ {
		/**
		* @brief Set or get the checked state of the checkbox.
		*
		* @validvalue A boolean string 'true' or 'false'.
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(checkBoxHandle, MAW_CHECK_BOX_CHECKED, "true");
		* \endcode
		*/
		CHECKED = "checked";
	}
	} // end of WidgetCheckBoxProperties

	/**
	* The available widget properties for a #MAW_TOGGLE_BUTTON. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetToggleButtonProperties "Toggle button properties" {
	constset MAString MAW_TOGGLE_BUTTON_ {
		/**
		* @brief Set or get the checked state of the toggle button.
		*
		* @validvalue A boolean string 'true' or 'false'.
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(toggleButtonHandle, MAW_TOGGLE_BUTTON_CHECKED, "true");
		* \endcode
		*/
		CHECKED = "checked";
	}
	} // end of WidgetCheckBoxProperties

	/**
	* The available widget properties for a #MAW_HORIZONTAL_LAYOUT. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetHorizontalLayoutProperties "Horizontal layout properties" {
	constset MAString MAW_HORIZONTAL_LAYOUT_ {
		/**
		* @brief Sets how the children in the layout should be aligned in the vertical axis.
		*
		* @validvalue One of the constants #MAW_ALIGNMENT_TOP, #MAW_ALIGNMENT_CENTER or #MAW_ALIGNMENT_BOTTOM.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(horizontalLayoutHandle, MAW_HORIZONTAL_LAYOUT_CHILD_VERTICAL_ALIGNMENT, MAW_ALIGNMENT_CENTER);
		* \endcode
		*/
		CHILD_VERTICAL_ALIGNMENT = "childVerticalAlignment";

		/**
		* @brief Sets how the children in the layout should be aligned in the horizontal axis.
		*
		* @validvalue One of the constants #MAW_ALIGNMENT_LEFT, #MAW_ALIGNMENT_CENTER or #MAW_ALIGNMENT_RIGHT.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(horizontalLayoutHandle, MAW_HORIZONTAL_LAYOUT_CHILD_HORIZONTAL_ALIGNMENT, MAW_ALIGNMENT_CENTER);
		* \endcode
		*/
		CHILD_HORIZONTAL_ALIGNMENT = "childHorizontalAlignment";

		/**
		* @brief Sets the top padding.
		*
		* @validvalue The top padding in pixels.
		*
		* @setonly
		*
		* @par Example
		* \code
		*  // Set a 50px top padding.
		*	maWidgetSetProperty(horizontalLayoutHandle, MAW_HORIZONTAL_LAYOUT_PADDING_TOP, "50");
		* \endcode
		*/
		PADDING_TOP = "paddingTop";

		/**
		* @brief Sets the left padding.
		*
		* @validvalue The left padding in pixels.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(horizontalLayoutHandle, MAW_HORIZONTAL_LAYOUT_PADDING_LEFT, "50");
		* \endcode
		*/
		PADDING_LEFT = "paddingLeft";

		/**
		* @brief Sets the right padding.
		*
		* @validvalue The right padding in pixels.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(horizontalLayoutHandle, MAW_HORIZONTAL_LAYOUT_PADDING_RIGHT, "50");
		* \endcode
		*/
		PADDING_RIGHT = "paddingRight";

		/**
		* @brief Sets the bottom padding.
		*
		* @validvalue The bottom padding in pixels.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(horizontalLayoutHandle, MAW_HORIZONTAL_LAYOUT_PADDING_BOTTOM, "50");
		* \endcode
		*/
		PADDING_BOTTOM = "paddingBottom";
	}
	} // end of WidgetHorizontalLayoutProperties

	/**
	* The available widget properties for a #MAW_VERTICAL_LAYOUT. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetVerticalLayoutProperties "Vertical layout properties" {
	constset MAString MAW_VERTICAL_LAYOUT_ {
		/**
		* @brief Sets how the children in the layout should be aligned in the vertical axis.
		*
		* @validvalue One of the constants #MAW_ALIGNMENT_TOP, #MAW_ALIGNMENT_CENTER or #MAW_ALIGNMENT_BOTTOM.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(verticalLayoutHandle, MAW_VERTICAL_LAYOUT_CHILD_VERTICAL_ALIGNMENT, MAW_ALIGNMENT_CENTER);
		* \endcode
		*/
		CHILD_VERTICAL_ALIGNMENT = "childVerticalAlignment";

		/**
		* @brief Sets how the children in the layout should be aligned in the horizontal axis.
		*
		* @validvalue One of the constants #MAW_ALIGNMENT_LEFT, #MAW_ALIGNMENT_CENTER or #MAW_ALIGNMENT_RIGHT.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(verticalLayoutHandle, MAW_VERTICAL_LAYOUT_CHILD_HORIZONTAL_ALIGNMENT, MAW_ALIGNMENT_CENTER);
		* \endcode
		*/
		CHILD_HORIZONTAL_ALIGNMENT = "childHorizontalAlignment";

		/**
		* @brief Sets the top padding.
		*
		* @validvalue The top padding in pixels.
		*
		* @setonly
		*
		* @par Example
		* \code
		*  // Set a 50px top padding.
		*	maWidgetSetProperty(verticalLayoutHandle, MAW_VERTICAL_LAYOUT_PADDING_TOP, "50");
		* \endcode
		*/
		PADDING_TOP = "paddingTop";

		/**
		* @brief Sets the left padding.
		*
		* @validvalue The left padding in pixels.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(verticalLayoutHandle, MAW_VERTICAL_LAYOUT_PADDING_LEFT, "50");
		* \endcode
		*/
		PADDING_LEFT = "paddingLeft";

		/**
		* @brief Sets the right padding.
		*
		* @validvalue The right padding in pixels.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(verticalLayoutHandle, MAW_VERTICAL_LAYOUT_PADDING_RIGHT, "50");
		* \endcode
		*/
		PADDING_RIGHT = "paddingRight";

		/**
		* @brief Sets the bottom padding.
		*
		* @validvalue The bottom padding in pixels.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(verticalLayoutHandle, MAW_VERTICAL_LAYOUT_PADDING_BOTTOM, "50");
		* \endcode
		*/
		PADDING_BOTTOM = "paddingBottom";
	}
	} // end of WidgetVerticalLayoutProperties

	/**
	* The available widget properties for a #MAW_SEARCH_BAR. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetSearchBarProperties "Search bar properties" {
	constset MAString MAW_SEARCH_BAR_ {
		/**
		* @brief Set or get the current text of the search bar.
		*
		* @validvalue A null-terminated string.
		*
		* @setandget
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(searchBarHandle, MAW_SEARCH_BAR_TEXT, "My search query");
		* \endcode
		*/
		TEXT = "text";

		/**
		* @brief Set a text in the search bar that acts as a placeholder when an edit box is empty.
		*
		* @validvalue A null-terminated string.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(searchBarHandle, MAW_SEARCH_BAR_PLACEHOLDER, "Search...");
		* \endcode
		*/
		PLACEHOLDER = "placeholder";

		/**
		* @brief Shows or hides the virtual keyboard. If shown the focus will be set to this widget.
		*
		* @validvalue A boolean string 'true' or 'false'.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(searchBarHandle, MAW_SEARCH_BAR_SHOW_KEYBOARD, "true");
		* \endcode
		*/
		SHOW_KEYBOARD = "showKeyboard";
	}
	} // end of WidgetSearchBarProperties

	/**
	* The available widget properties for a #MAW_GL_VIEW. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetGLViewProperties "GL view properties" {
	constset MAString MAW_GL_VIEW_ {
		/**
		* @brief Property that tells the gl view that it should be redrawn.
		*
		* @validvalue The value isn't taken into account.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(glViewHandle, MAW_GL_VIEW_INVALIDATE, "");
		* \endcode
		*/
		INVALIDATE = "invalidate";

		/**
		* @brief Property that tells the gl view that all following gl calls will apply to this view.
		*
		* @validvalue The value isn't taken into account.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(glViewHandle, MAW_GL_VIEW_BIND, "");
		* \endcode
		*/
		BIND = "bind";
	}
	} // end of WidgetGLViewProperties

	/**
	* The available widget properties for a #MAW_WEB_VIEW.
	* See @ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetWebViewProperties "Web view properties" {
	constset MAString MAW_WEB_VIEW_ {
		/**
		* @brief Set or get the currently displayed url in the web view.
		*
		* You can also use this property to evaluate JavaScript in the WebView,
		* by using a url that starts with "javascript:" followed by the
		* JavaScript code.
		*
		* Note that if the url is a non-local url that will cause data to
		* be downloaded over the network, you need to set "Internet Access"
		* permissions for the application.
		*
		* @validvalue Any valid URL.
		*
		* @setandget
		*
		* @par Example
		* @code
		*	maWidgetSetProperty(webViewHandle, MAW_WEB_VIEW_URL, "http://www.mosync.com/");
		* @endcode
		*
		* @code
		*	maWidgetSetProperty(
		*		webViewHandle,
		*		MAW_WEB_VIEW_URL,
		*		"javascript:document.body.innerHTML= '<p>Hello World</p>'");
		* @endcode
		*/
		URL = "url";

		/**
		* @brief Set the currently displayed HTML data in the web view.
		*
		* @validvalue Any valid HTML data.
		*
		* @setonly
		*
		* @par Example
		* @code
		*	maWidgetSetProperty(webViewHandle, MAW_WEB_VIEW_HTML, "<h1>Hello World</h1>");
		* @endcode
		*/
		HTML = "html";

		/**
		* @brief Set the base URL used by the web-view when loading relative paths.
		* The value of this URL is used when setting the #MAW_WEB_VIEW_URL and
		* #MAW_WEB_VIEW_HTML properties. The default value for this property points to
		* the Assets folder in the local file system ("file://pathToLocalFileSystem/Assets/").
		*
		* @note Use: #maGetSystemProperty ("mosync.path.local.url") to find the baseURL
		* for the local file system.
		*
		* @validvalue Any valid URL schema.
		*
		* @setandget
		*/
		BASE_URL = "baseUrl";

		/**
		* @brief Set the pattern used to "soft hook" urls, to get notified
		* when pages are being loaded.
		*
		* When this pattern matches a url that is being requested
		* to load in the WebView, event #MAW_EVENT_WEB_VIEW_HOOK_INVOKED
		* is sent, and the page loads NORMALLY.
		*
		* Note that when receiving event #MAW_EVENT_WEB_VIEW_HOOK_INVOKED
		* you MUST deallocate the urlData handle of the event by calling
		* maDestroyObject on the handle. Destory the handle when you are done
		* reading the url data, to avoid that memory will get used up.
		*
		* The pattern is a url pattern specified using regular expression
		* syntax, according to the ICU regular expression standard, using
		* complete match. For example, the ".*" matching expression is used
		* to match any url string. To match all HTTP requests, use the
		* pattern "http://.*". To match all requests for a specific domain,
		* use a pattern like ".*google.com.*". For further infomation, see:
		* http://userguide.icu-project.org/strings/regexp
		* When typing a C-string with a pattern that contains a matching
		* expression with a backslash, make sure to escape the backslash,
		* for example "\B" should be "\\B".
		*
		* By setting the pattern to an empty string, the soft hook mechanism
		* is turned off, and #MAW_EVENT_WEB_VIEW_HOOK_INVOKED is not sent.
		*
		* Both "soft" hooks and "hard" hooks can be enabled simultaneously,
		* but only one hook pattern can be used for each type of hook. When
		* setting a new hook pattern, the old hook is replaced.
		*
		* Note that urls opened using maWidgetSetProperty with the property
		* MAW_WEB_VIEW_URL are NOT hooked. This way of loading a page is
		* excluded from the hook mechanism to prevent "loops" when loading
		* pages.
		*
		* @validvalue A string with a url pattern.
		*
		* @setonly
		*
		* @par Example
		* @code
		*   // Hook all urls.
		*	maWidgetSetProperty(webViewHandle, MAW_WEB_VIEW_SOFT_HOOK, ".*");
		*
		*   // Hook no urls.
		*	maWidgetSetProperty(webViewHandle, MAW_WEB_VIEW_SOFT_HOOK, "");
		*
		*   // Hook urls that start with "mosync:".
		*	maWidgetSetProperty(webViewHandle, MAW_WEB_VIEW_SOFT_HOOK, "mosync://.*");
		* @endcode
		*/
		SOFT_HOOK = "softHook";

		/**
		* @brief Set the pattern used to "hard hook" urls, to get notified
		* and prevent loading of pages.
		*
		* Hard hooks are useful for communicating events from a WebView,
		* for example by setting document.location to a url string in
		* JavaScript. Example: document.location = 'mosync://ExitApp'
		* The application can then examine the url data and take action
		* depending on the url content.
		*
		* When this pattern matches a url that is being requested
		* to load in the WebView, event #MAW_EVENT_WEB_VIEW_HOOK_INVOKED
		* is sent, and page loading is ABORTED.
		*
		* Note that when receiving event #MAW_EVENT_WEB_VIEW_HOOK_INVOKED
		* you MUST deallocate the urlData handle of the event by calling
		* maDestroyObject on the handle. Destory the handle when you are done
		* reading the url data, to avoid that memory will get used up.
		*
		* The pattern is a url pattern specified using regular expression
		* syntax, according to the ICU regular expression standard, using
		* complete match. For example, the ".*" matching expression is used
		* to match any url string. To match all HTTP requests, use the
		* pattern "http://.*". To match all requests for a specific domain,
		* use a pattern like ".*google.com.*". For further infomation, see:
		* http://userguide.icu-project.org/strings/regexp
		* When typing a C-string with a pattern that contains a matching
		* expression with a backslash, make sure to escape the backslash,
		* for example "\B" should be "\\B".
		*
		* By setting the pattern to an empty string, the soft hook mechanism
		* is turned off, and #MAW_EVENT_WEB_VIEW_HOOK_INVOKED is not sent.
		*
		* Both "soft" hooks and "hard" hooks can be enabled simultaneously,
		* but only one hook pattern can be used for each type of hook. When
		* setting a new hook pattern, the old hook is replaced.
		*
		* The "hard" hook property takes precedence over the "soft" hook
		* property. When both properties are set,
		* #MAW_EVENT_WEB_VIEW_HOOK_INVOKED is sent once, for the
		* "hard" hook type.
		*
		* Note that urls opened using maWidgetSetProperty with the property
		* MAW_WEB_VIEW_URL are NOT hooked. This way of loading a page is
		* excluded from the hook mechanism to prevent "loops" when loading
		* pages.
		*
		* @validvalue A string with a url pattern.
		*
		* @setonly
		*
		* @par Example
		* @code
		*   // Hook urls that start with "mosync:".
		*	maWidgetSetProperty(webViewHandle, MAW_WEB_VIEW_HARD_HOOK, "mosync://.*");
		* @endcode
		*/
		HARD_HOOK = "hardHook";

		/**
		* @brief Property to get a new url whenever the webview changes the url.
		* See #MAW_EVENT_WEB_VIEW_URL_CHANGED.
		*
		* @deprecated Use event #MAW_EVENT_WEB_VIEW_HOOK_INVOKED
		*
		* @validvalue Any valid URL.
		*
		* @getonly
		*
		* @par Example
		* @code
		* 	char urlBuffer[BUFFER_SIZE];
		* 	int result = maWidgetGetProperty(
		*     webViewHandle,
		*     MAW_WEB_VIEW_NEW_URL,
		*     urlBuffer,
		*     BUFFER_SIZE);
		* 	if (result > 0)
		* 	{
		* 	    // Do something with URL.
		* 	}
		* @endcode
		*/
		NEW_URL = "newurl";

		/**
		* @brief Sets or gets whether the horizontal scrollbar should be drawn or not.
		* Available only on Android for the moment.
		*
		* @validvalue A boolean string 'true' or 'false'.
		*
		* @setandget
		*
		* @par Example
		* \code
        *   maWidgetSetProperty(webViewHandle, MAW_WEB_VIEW_HORIZONTAL_SCROLLBAR_ENABLED, "true");
		* \endcode
		*/
		HORIZONTAL_SCROLL_BAR_ENABLED = "horizontalScrollBarEnabled";

		/**
		* @brief Sets or gets whether the vertical scrollbar should be drawn or not.
		* The scrollbar is drawn by default.
		* Available only on Android for the moment.
		*
		* @validvalue A boolean string 'true' or 'false'.
		*
		* @setandget
		*
		* @par Example
		* \code
        *   maWidgetSetProperty(webViewHandle, MAW_WEB_VIEW_VERTICAL_SCROLLBAR_ENABLED, "false");
		* \endcode
		*/
		VERTICAL_SCROLL_BAR_ENABLED = "verticalScrollBarEnabled";

		/**
		* @brief Enable or disable the zoom controls of the web view.
		*
		* @validvalue "true" to enable, "false" to disable.
		*
		* @setonly
		*
		* @par Example
		* @code
		*	maWidgetSetProperty(webViewHandle, MAW_WEB_VIEW_ENABLE_ZOOM, "true");
		* @endcode
		*/
		ENABLE_ZOOM = "enableZoom";

		/**
		* @brief Navigate forward or back the browsing history.
		*
		* @validvalue "back" or "forward".
		*
		* @setonly
		*
		* @par Example
		* @code
		*	maWidgetSetProperty(webViewHandle, MAW_WEB_VIEW_NAVIGATE, "back");
		* @endcode
		*/
		NAVIGATE = "navigate";
	}

	} // end of WidgetWebViewProperties
	/**
	* The available widget properties for a #MAW_PROGRESS_BAR. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetProgressBarProperties "Progress bar properties" {
	constset MAString MAW_PROGRESS_BAR_ {
		/**
		* @brief Sets or gets the range of the progress bar to 0..max.
		*
		* @validvalue An positive integer that specifies the upper range of this progress bar.
		*
		* @setandget
		*
		* @par Example
		* \code
        *   maWidgetSetProperty(progressBarHandle, MAW_PROGRESS_BAR_MAX, "100");
		* \endcode
		*/
		MAX = "max";

		/**
		* @brief Set or gets the current progress to the specified value.
		*
		* @validvalue An int that specifies the new progress, between 0 and max value. See \ref MAW_PROGRESS_BAR_MAX.
		*
		* @setandget
		*
		* @par Example
		* \code
		* 	maWidgetSetProperty(progressBarHandle, MAW_PROGRESS_BAR_PROGRESS, "10");
		* \endcode
		*/
		PROGRESS = "progress";

		/**
		* @brief Increase the progress bar's progress by the specified amount.
		*
		* @validvalue An int that specifies the amount by which the progress must be increased.
		*
		* @setonly
		*
		* @par Example
		* \code
        *   maWidgetSetProperty(progressBarHandle, MAW_PROGRESS_BAR_INCREMENT_PROGRESS, "20");
		* \endcode
		*/
		INCREMENT_PROGRESS = "incrementProgress";
	}
	} // end of WidgetProgressBarProperties

	/**
	* The available widget properties for a #MAW_ACTIVITY_INDICATOR. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetActivityIndicatorProperties "Activity Indicator properties" {
	constset MAString MAW_ACTIVITY_INDICATOR_ {
		/**
		* @brief Sets if the indicator is still on or off.
		* If set to false, it doesn't delete the widget just dismisses it.
		* @validvalue A boolean string 'true' or 'false'.
		*
		* @setonly
		*
		* @par Example
		* \code
		*   // The activity is done. Now this widget is dismissed.
        *   maWidgetSetProperty(activityIndicatorHandle, MAW_ACTIVITY_INDICATOR_IN_PROGRESS, "false");
		* \endcode
		*/
		IN_PROGRESS = "inProgress";
	}
	} // end of WidgetActivityIndicatorProperties

	/**
	* The available widget properties for a #MAW_SLIDER. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetSliderProperties "Slider properties" {
	constset MAString MAW_SLIDER_ {
		/**
		* @brief Sets or gets the range of the slider to 0..max.
		*
		* @validvalue An positive integer that specifies the upper range of this slider.
		*
		* @setandget
		*
		* @par Example
		* \code
        *   maWidgetSetProperty(sliderHandle, MAW_SLIDER_MAX, "100");
		* \endcode
		*/
		MAX = "max";

		/**
		* @brief Set or gets the current value to the slider.
		*
		* @validvalue An int that specifies the new value, between 0 and max value. See \ref MAW_SLIDER_MAX.
		*
		* @setandget
		*
		* @par Example
		* \code
		* 	maWidgetSetProperty(sliderHandle, MAW_SLIDER_VALUE, "10");
		* \endcode
		*/
		VALUE = "value";

		/**
		* @brief Increase the current value of the slider by the specified amount.
		*
		* @validvalue An int that specifies the amount by which the slider value must be increased.
		*
		* @setonly
		*
		* @par Example
		* \code
        *   maWidgetSetProperty(sliderHandle, MAW_SLIDER_INCREASE_VALUE, "20");
		* \endcode
		*/
		INCREASE_VALUE = "increaseValue";

		/**
		* @brief Decreases the current value of the slider by the specified amount.
		*
		* @validvalue An int that specifies the amount by which the slider value must be decreased.
		*
		* @setonly
		*
		* @par Example
		* \code
        *   maWidgetSetProperty(sliderHandle, MAW_SLIDER_DECREASE_VALUE, "20");
		* \endcode
		*/
		DECREASE_VALUE = "decreaseValue";
	}
	} // end of WidgetSliderProperties

	/**
	* The available widget properties for a #MAW_DATE_PICKER. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetDatePickerProperties "Date Picker properties" {
	constset MAString MAW_DATE_PICKER_ {
		/**
		* @brief Sets or gets  maximal date supported by this DatePicker in milliseconds since January 1, 1970 00:00:00.
		* NOTE: On Android the default maximal date is 12/31/2100.
		* NOTE: The property can be set on iOS only.
		* @validvalue A long int that specifies the upper range of this date picker.
		*
		* @setandget
		*
		* @par Example
		* \code
        *   maWidgetSetProperty(datePickerHandle, MAW_DATE_PICKER_MAX_DATE, "101220100000");
		*   // Now the maximum date is  the 10th of December 2010.
		* \endcode
		*/
		MAX_DATE = "maxDate";

		/**
		* @brief Sets or gets  minimal date supported by this DatePicker in milliseconds since January 1, 1970 00:00:00
		* Note: On Android the default minimal date is 01/01/1900.
		* NOTE: The property can be set on iOS only.
		* @validvalue A long int that specifies the minimal supported date.
		*
		* @setandget
		*
		* @par Example
		* \code
        *   maWidgetSetProperty(datePickerHandle, MAW_DATE_PICKER_MIN_DATE, "0101200000");
		*   // Now the minimum date is the 1st of January 2000.
		* \endcode
		*/
		MIN_DATE = "minDate";

		/**
		* @brief Sets or gets the currently displayed year.
		*
		* @validvalue An int that specifies a valid year.
		*
		* @setandget
		*
		* @par Example
		* \code
		*   char yearBuffer[BUFFER_SIZE];
        *   int getStatus = maWidgetGetProperty(datePickerHandle, MAW_DATE_PICKER_YEAR, yearBuffer, BUFFER_SIZE);
		*   if(getStatus == MAW_RES_OK)
		*   {
		*       // Do something with the year.
		*   }
		* \endcode
		*/
		YEAR = "year";

		/**
		* @brief Sets or gets the currently displayed month.
		*
		* @validvalue An int that specifies a valid month.
		*
		* @setandget
		*
		* @par Example
		* \code
		*   char monthBuffer[BUFFER_SIZE];
        *   int getStatus = maWidgetGetProperty(datePickerHandle, MAW_DATE_PICKER_MONTH, monthBuffer, BUFFER_SIZE);
		*   if(getStatus == MAW_RES_OK)
		*   {
		*       // Do something with the month.
		*   }
		* \endcode
		*/
		MONTH = "month";

		/**
		* @brief Sets or gets the currently displayed day of month.
		*
		* @validvalue An int that specifies a valid day of month.
		*
		* @setandget
		*
		* @par Example
		* \code
		*   char dayBuffer[BUFFER_SIZE];
        *   int getStatus = maWidgetGetProperty(datePickerHandle, MAW_DATE_PICKER_DAY_OF_MONTH, dayBuffer, BUFFER_SIZE);
		*   if(getStatus == MAW_RES_OK)
		*   {
		*       // Do something with the day.
		*   }
		* \endcode
		*/
		DAY_OF_MONTH = "dayOfMonth";
	}
	} // end of WidgetDatePickerProperties

	/**
	* The available widget properties for a #MAW_TIME_PICKER. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetTimePickerProperties "Time Picker properties" {
	constset MAString MAW_TIME_PICKER_ {
		/**
		* @brief Sets or gets the current hour in 24h mode( in the range: 0-23 ).
		*
		* @validvalue An int that specifies the current hour.
		*
		* @setandget
		*
		* @par Example
		* \code
		*   // Set hour to 20, that is 8PM.
        *   maWidgetSetProperty(timePickerHandle, MAW_TIME_PICKER_CURRENT_HOUR, "20");
		* \endcode
		*/
		CURRENT_HOUR = "currentHour";

		/**
		* @brief Sets or gets the current minute (0-59).
		*
		* @validvalue An int that specifies the current minute.
		*
		* @setandget
		*
		* @par Example
		* \code
		*   char buf[BUFFER_SIZE];
        *   maWidgetGetProperty(timePickerHandle, MAW_TIME_PICKER_CURRENT_MINUTE, buf, BUFFER_SIZE);
		*   // Do something with the minute.
		* \endcode
		*/
		CURRENT_MINUTE = "currentMinute";
	}
	} // end of WidgetTimePickerProperties

	/**
	* The available widget properties for a #MAW_NUMBER_PICKER. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetNumberPickerProperties "Number Picker properties" {
	constset MAString MAW_NUMBER_PICKER_ {
		/**
		* @brief Sets or gets the current value for the number picker.
		* If the value is less than MAW_NUMBER_PICKER_MIN_VALUE property value, the current value is set to min.
		* If the value is greater than MAW_NUMBER_PICKER_MAX_VALUE value, the current value is set to max.
		*
		* @validvalue A valid int.
		*
		* @setandget
		*
		* @par Example
		* \code
        *   maWidgetSetProperty(numberPickerHandle, MAW_NUMBER_PICKER_VALUE, "50");
		* \endcode
		*/
		VALUE = "value";

		/**
		* @brief Sets or gets the min value of the picker.
		*
		* @validvalue An int that specifies the minimum value.
		*
		* @setandget
		*
		* @par Example
		* \code
        *   maWidgetSetProperty(numberPickerHandle, MAW_NUMBER_PICKER_MIN_VALUE, "0");
		* \endcode
		*/
		MIN_VALUE = "minValue";

		/**
		* @brief Sets or gets the max value of the picker.
		*
		* @validvalue An int that specifies the maximum value.
		*
		* @setandget
		*
		* @par Example
		* \code
        *   maWidgetSetProperty(numberPickerHandle, MAW_NUMBER_PICKER_MAX_VALUE, "100");
		* \endcode
		*/
		MAX_VALUE = "maxValue";
	}
	} // end of WidgetNumberPickerProperties

	/**
	* The available widget properties for a #MAW_VIDEO_VIEW. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetVideoViewProperties "Video View properties" {
	constset MAString MAW_VIDEO_VIEW_ {
		/**
		* @brief Sets the video path.
		* Note: available only for Android.
		* @validvalue Any valid path.
		*
		* @setonly
		*
		* @par Example
		* \code
		*   // Set the video path.
        *   maWidgetSetProperty(videoViewHandle, MAW_VIDEO_VIEW_PATH, "\data\Video1.wav");
		* \endcode
		*/
		PATH = "path";

		/**
		* @brief Sets the video url.
		*
		* @validvalue Any valid streaming url.
		*
		* @setonly
		*
		* @par Example
		* \code
		*   // Set the video path.
        *   maWidgetSetProperty(videoViewHandle, MAW_VIDEO_VIEW_URL, "www.example.com/play.m3u8");
		* \endcode
		*/
		URL = "url";

		/**
		* @brief Start,pause or stop the video playback.
		*
		* @validvalue MAW_VIDEO_WIDGET_ACTION_PLAY, MAW_VIDEO_WIDGET_ACTION_PAUSE or MAW_VIDEO_WIDGET_ACTION_STOP constants.
		*
		* @setonly
		*
		* @par Example
		* \code
		*   // Start the playback.
        *   maWidgetSetProperty(videoViewHandle, MAW_VIDEO_WIDGET_ACTION, toString(MAW_VIDEO_WIDGET_ACTION_PLAY));
		* \endcode
		*/
		ACTION = "action";

		/**
		* @brief Seeks into the video.
		*
		* @validvalue A valid integer for milliseconds.
		*
		* @setonly
		*
		* @par Example
		* \code
        *   maWidgetSetProperty(videoViewHandle, MAW_VIDEO_VIEW_SEEK_TO, "10000");
		* \endcode
		*/
		SEEK_TO = "seekTo";

		/**
		* @brief Gets the video file duration.
		*
		* NOTE: On Android this value can be retrieved after MAW_VIDEO_VIEW_STATE_SOURCE_READY is received.
		*       On iOS this value can be retrieved after MAW_VIDEO_STATE_PLAYING is received.
		* @validvalue An int.
		*
		* @getonly
		*
		* @par Example
		* \code
		*   char buf[BUFFER_SIZE];
        *   maWidgetGetProperty(videoViewHandle, MAW_VIDEO_VIEW_DURATION, buf, BUFFER_SIZE);
		*   // Do something with the duration.
		* \endcode
		*/
		DURATION = "duration";

		/**
		* @brief Gets the buffer percentage of the played video file.
		*
		* @validvalue An int.
		*
		* @getonly
		*
		* @par Example
		* \code
		*   char buf[BUFFER_SIZE];
        *   maWidgetGetProperty(videoViewHandle, MAW_VIDEO_VIEW_BUFFER_PERCENTAGE, buf, BUFFER_SIZE);
		*   // Do something with the percentage.
		* \endcode
		*/
		BUFFER_PERCENTAGE = "bufferPercentage";

		/**
		* @brief Gets the current position in the video file.
		*
		* @validvalue An int.
		*
		* @getonly
		*
		* @par Example
		* \code
		*   char buf[BUFFER_SIZE];
        *   maWidgetGetProperty(videoViewHandle, MAW_VIDEO_VIEW_CURRENT_POSITION, buf, BUFFER_SIZE);
		*   // Do something with the position.
		* \endcode
		*/
		CURRENT_POSITION = "currentPosition";
	}
	} // end of WidgetVideoViewProperties

	/**
	* The available widget properties for a #MAW_NAV_BAR. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetNavBarProperties "Navigation Bar properties" {
	constset MAString MAW_NAV_BAR_ {
		/**
		* @brief Sets or gets the title.
		*
		* @validvalue A null-terminated string.
		*
		* @setandget
		*
		* @par Example
		* \code
        *   maWidgetSetProperty(navBarHandle, MAW_NAV_BAR_TITLE, "MyScreen");
		* \endcode
		*/
		TITLE = "title";

		/**
		* Sets the icon of the nav bar. This won't be scaled at all.
		*
		* @validvalue MoSync handle to an uncompressed image resource. The size of the image should be small enough to fit in the nav bar.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(navBarHandle, MAW_NAV_BAR_ICON, toString(R_MY_IMAGE));
		* \endcode
		*/
		ICON = "icon";

		/**
		* @brief Sets the text for the back button.
		* This can be set only when the navigation bar was
		* attached to a screen that is not part of a stack screen.
		* Note: this is available only on iOS.
		* On Android the back behavior is handled by the device's back button.
		*
		* @validvalue A null-terminated string.
		*
		* @setandget
		*
		* @par Example
		* \code
        *   maWidgetSetProperty(navBarHandle, MAW_NAV_BAR_BACK_BTN, "Home");
		* \endcode
		*/
		BACK_BTN = "backBtn";

		/**
		* @brief Sets the font color of the title.
		*
		* @validvalue A hexadecimal value 0xRRGGBB, where R, G and B are the red, green and blue components respectively.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(navBarHandle, MAW_NAV_BAR_TITLE_FONT_COLOR, "0xff0000");
		* \endcode
		*/
		TITLE_FONT_COLOR = "titleFontColor";

		/**
		* @brief Sets the font size in points of the title.
		*
		* @validvalue A float that specifies the number of points.
		*
		* @setonly
		*
		* @par Example
		* \code
		*	maWidgetSetProperty(navBarHandle, MAW_NAV_BAR_TITLE_FONT_SIZE, "13.0");
		* \endcode
		*/
		TITLE_FONT_SIZE = "titleFontSize";

		/**
		* @brief Sets the typeface and style in which the title should be displayed.
		*
		* @validvalue A font handle received from loading fonts using
		* #maFontGetName and #maFontLoadWithName syscalls.
		*
		* @setonly
		*
		* @par Example
		* \code
		*   int nrFonts = maFontGetCount();
		*    char buf[256];
		*    // Get first font name.
		*    maFontGetName(1, buf, 256);
		*    // Load that font for size 10.
		*    int fontHandle = maFontLoadWithName(buf, 10);
		*    // Set that font to the label.
		*	maWidgetSetProperty(navBarHandle, MAW_NAV_BAR_TITLE_FONT_HANDLE, toString(fontHandle));
		* \endcode
		*/
		TITLE_FONT_HANDLE = "titleFontHandle";
	}
	} // end of WidgetNavBarProperties

	/**
	* The available widget properties for a #MAW_MODAL_DIALOG. See \ref WidgetProperties "Widget properties" for more properties.
	*/
	group WidgetModalDialogProperties "Modal Dialog properties" {
	constset MAString MAW_MODAL_DIALOG_ {
		/**
		* @brief Sets or gets the title.
		* If the property receives am empty string then the title bar becomes invisible.
		* @validvalue A null-terminated string.
		*
		* @setandget
		*
		* @par Example
		* \code
		*   maWidgetSetProperty(dialogHandle, MAW_MODAL_DIALOG_TITLE, "MyDialog");
		* \endcode
		*/
		TITLE = "title";

		/**
		* @brief Sets the origin arrow position for a popover dialog.
		* Note: This property is only available on the iPad.
		*
		* @validvalue One of the five MAW_CONSTANT_ARROW_ values, or a bitwise or combination of them.
		*
		* @setonly
		*
		* @par Example
		* \code
		*   // Allow the popover to use any arrow
		*   maWidgetSetProperty(dialogHandle, MAW_MODAL_DIALOG_ARROW_POSITION, MAW_CONSTANT_ARROW_ANY);
		* \endcode
		*/
		ARROW_POSITION = "arrowPosition";

		/**
		* @brief Allow or prohibits the user from dismissing a popover dialog by tapping outside of it.
		* Note: This property is only available on the iPad.
		*
		* @validvalue "true"or "false".
		*
		* @setonly
		*
		* @par Example
		* \code
		*   // Prohibit the user from dismissing the popover
		*   maWidgetSetProperty(dialogHandle, MAW_MODAL_DIALOG_USER_CAN_DISMISS, "false");
		* \endcode
		*/
		USER_CAN_DISMISS = "userCanDismiss";

	}
	} // end of WidgetmodalDialogProperties
	} // end of WidgetProperties

	typedef int MAWidgetHandle;

	/**
	* The set of functions available for the Widget API.
	*/
	group WidgetAPIFunctions "Widget functions" {

	/**
	* Creates a new widget of the specified type.
	*
	* \note See \ref WidgetTypes "Widget types" for the available widget types.
	*
	* \param widgetType A String representing the type of the widget to create.
	*
	* \returns A handle to the widget, or any of the following result codes:
	* - #MAW_RES_ERROR if the widget could not be created.
	* - #MAW_RES_INVALID_TYPE_NAME if the widget type was not available.
	* - #MAW_RES_FEATURE_NOT_AVAILABLE if the widget type is not supported by the curent framework version.

	*/
	MAWidgetHandle maWidgetCreate(in MAString widgetType);

	/**
	* Frees the memory and resources held by the given widget. Destryoing a widget
	* with children will also cause its children to be destroyed. Once a handle has
	* been destroyed it cannot be referenced by the maWidget* functions.
	*
	* \note If the given widget has a parent, the widget will be removed from its
	* parent.
	*
	* \param widget A handle to the widget to be destroyed.
	*
	* \returns Any of the following result codes:
	* - #MAW_RES_OK if the widget was destroyed.
	* - #MAW_RES_INVALID_HANDLE if the handle was invalid.
	*/
	int maWidgetDestroy(in MAWidgetHandle widget);

	/**
	* Adds a widget to the given parent as a child. Letting the
	* parent widget layout the child.
	*
	* \param parent The widget layout to which the child will be added.
	* \param child The widget that will be added to the parent.
	*
	* \returns Any of the following result codes:
	* - #MAW_RES_OK if the child could be added to the parent.
	* - #MAW_RES_INVALID_HANDLE if any of the handles were invalid.
	* - #MAW_RES_INVALID_LAYOUT if the widget was added to a non-layout.
	* - #MAW_RES_CANNOT_INSERT_DIALOG if the child is a modal dialog.
	* - #MAW_RES_ERROR if it could not be added for some other reason.
	*/
	int maWidgetAddChild(in MAWidgetHandle parent, in MAWidgetHandle child);

	/**
	* Inserts a widget to the given parent as a child at an index. Letting the
	* parent widget layout the child.
	*
	* \param parent The widget layout in which the child will be inserted.
	* \param child The widget that will be added to the parent.
	* \param index The index where the widget should be inserted (-1 means last)
	*
	* \returns Any of the following result codes:
	* - #MAW_RES_OK if the child could be added to the parent.
	* - #MAW_RES_INVALID_HANDLE if any of the handles were invalid.
	* - #MAW_RES_INVALID_INDEX if the index was out of bounds.
	* - #MAW_RES_INVALID_LAYOUT if the widget was added to a non-layout.
	* - #MAW_RES_CANNOT_INSERT_DIALOG if the child is a modal dialog.
	* - #MAW_RES_ERROR if it could not be added for some other reason.
	*/
	int maWidgetInsertChild(in MAWidgetHandle parent, in MAWidgetHandle child, in int index);

	/**
	* Removes a child widget from its parent (but does not destroy it).
	* Removing a currently visible top-level widget causes the MoSync view to become visible.
	*
	* \returns Any of the following result codes:
	* - #MAW_RES_OK if the child could be removed from the parent.
	* - #MAW_RES_INVALID_HANDLE if the handle was invalid.
	* - #MAW_RES_ERROR otherwise.
	*/
	int maWidgetRemoveChild(in MAWidgetHandle child);

	/**
	* Shows a dialog widget.
	* \param dialogHandle The handle of the dialog that will be shown.
	*
	* \returns Any of the following result codes:
	* - #MAW_RES_OK if the child could be removed from the parent.
	* - #MAW_RES_INVALID_HANDLE if the handle was invalid.
	* - #MAW_RES_ERROR otherwise.
	*/
	int maWidgetModalDialogShow(in MAWidgetHandle dialogHandle);

	/**
	* Hides/Dismisses a currently displayed dialog.
	* \param dialogHandle The handle of the dialog that will be hidden.
	*
	* \returns Any of the following result codes:
	* - #MAW_RES_OK if the child could be removed from the parent.
	* - #MAW_RES_INVALID_HANDLE if the handle was invalid.
	* - #MAW_RES_ERROR otherwise.
	*/
	int maWidgetModalDialogHide(in MAWidgetHandle dialogHandle);

	/**
	* Shows a screen. If native UI hasn't been initialized, it is also initialized
	* and disables regular MoSync drawing.
	*
	* \param screenHandle The handle to the screen.
	*
	* \returns Any of the following result codes:
	* - #MAW_RES_OK if the screen could be shown.
	* - #MAW_RES_INVALID_SCREEN if the \a screenHandle is not a handle to a screen.
	*/
	int maWidgetScreenShow(in MAWidgetHandle screenHandle);

	/**
	 * Pushes a screen to the given screen stack, hides the current screen and
	 * shows the pushed screen it. Pushing it to the stack will make it
	 * automatically go back to the previous screen when popped.
	 *
	 * \param stackScreen A handle to a #MAW_STACK_SCREEN.
	 * \param newScreen A handle to either a #MAW_SCREEN or a #MAW_TAB_SCREEN.
	 *                  The handle cannot exist in the stack already.
	 *
	 * \return Any of the following result codes:
	 * - #MAW_RES_OK if the given screen could be pushed.
	 * - #MAW_RES_INVALID_HANDLE if either the screenStack or newScreen handle
	 *                           was invalid.
	 * - #MAW_RES_ERROR if something else than a screen stack was passed, or if
	 *                  the handle already exists in the stack.
	 */
	int maWidgetStackScreenPush(in MAWidgetHandle stackScreen, in MAWidgetHandle newScreen);

	/**
	 * Pops a screen from a screen stack, hides the current screen and shows
	 * the popped screen before the If there is no previous screen in the screen
	 * stack, an empty screen will be shown.
	 *
	 * \param stackScreen A handle to a #MAW_STACK_SCREEN to pop from.
	 *
	 * \return Any of the following result codes:
	 * - #MAW_RES_OK if the given screen could be popped.
	 * - #MAW_RES_INVALID_HANDLE if the screen stack does not exist.
	 * - #MAW_RES_ERROR if something else than a screen stack was passed.
	 */
	int maWidgetStackScreenPop(in MAWidgetHandle stackScreen);

	/**
	* Sets a specified property on the given widget.
	*
	* \param widget Handle to the widget.
	* \param property A string representing which property to set.
	* \param value The value which will be assigned to the property.
	*
	* \note May be synchronous or asynchronous depending on the property.
	* \note See \ref WidgetProperties "Widget properties" for the available properties.
	*
	* \returns Any of the following result codes:
	* - #MAW_RES_OK if the property could be set.
	* - #MAW_RES_INVALID_HANDLE if the handle was invalid.
	* - #MAW_RES_INVALID_PROPERTY_NAME if the property name was invalid.
	* - #MAW_RES_INVALID_PROPERTY_VALUE if the property value was invalid.
	* - #MAW_RES_FEATURE_NOT_AVAILABLE if the property is not supported by the curent framework version.
	* - #MAW_RES_ERROR otherwise.
	*/
	int maWidgetSetProperty(in MAWidgetHandle widget, in MAString property, in MAString value);

	/**
	* Retrieves a specified property from the given widget.
	*
	* \param widget Handle to the widget.
	* \param property A string representing which property to set.
	* \param value A buffer that will hold the value of the property, represented as a string.
	* \param bufSize Size of the buffer.
	*
	* \returns The number of bytes copied on success, or any of the following result codes:
	* - #MAW_RES_INVALID_HANDLE if the handle was invalid.
	* - #MAW_RES_INVALID_PROPERTY_NAME if the property name was invalid.
	* - #MAW_RES_INVALID_PROPERTY_VALUE if the property value was invalid.
	* - #MAW_RES_INVALID_STRING_BUFFER_SIZE if the buffer size was to small.
	* - #MAW_RES_FEATURE_NOT_AVAILABLE if the property is not supported by the curent framework version.
	* - #MAW_RES_ERROR otherwise.
	*/
	int maWidgetGetProperty(in MAWidgetHandle widget, in MAString property, out MAString value range("bufSize"), in int bufSize);

	} // end of group WidgetAPIFunctions

} // end of group WidgetAPI
#endif //IX_WIDGET

group CameraAPI "Camera API" {

	constset int MA_CAMERA_CONST_ {
		/**
		* @brief A constant that represents the flash being on.
		*/
		BACK_CAMERA = 0;

		/**
		* @brief A constant that represents the flash being in the automatic mode.
		*/
		FRONT_CAMERA = 1;

	} //end MA_CAMERA_CONST

group CameraResultCodes "Camera Result Codes" {
	constset int MA_CAMERA_RES_ {
		/**
		* @brief A constant that represents successful camera operation.
		*/
		OK = 1;

		/**
		* @brief A constant that represents a failed camera operation.
		*/
		FAILED = -2;

		/**
		* @brief A constant that represents a camera failing to start.
		*/
		NOT_STARTED = -3;

		/**
		* @brief A constant that represents a property not supported by the device.
		*/
		PROPERTY_NOTSUPPORTED = -4;

		/**
		* @brief A constant that represents an invalid value for that property.
		*/
		INVALID_PROPERTY_VALUE = -5;

		/**
		* @brief A constant that represents a property value not supported by the device.
		*/
		VALUE_NOTSUPPORTED = -6;

	}
} //end CameraResultCodes


group FlashModes "Flash Modes" {
	constset MAString MA_CAMERA_FLASH_ {
		/**
		* @brief A constant that represents the flash being on.
		*/
		ON = "on";

		/**
		* @brief A constant that represents the flash being in the automatic mode.
		*/
		AUTO = "auto";

		/**
		* @brief A constant that represents the flash being off.
		*/
		OFF = "off";

		/**
		* @brief A constant that represents the flash being in the torch mode.
		*/
		TORCH = "torch";

	} //end MA_CAMERA_FLASH_
}// end of FlashMode

group FocusModes "Focus Modes" {
	constset MAString MA_CAMERA_FOCUS_ {
		/**
		* @brief A constant that represents the focus mode being automatic.
		*/
		AUTO = "auto";

		/**
		* @brief A constant that turns the camera to focus to infinity.
		*/
		INFINITY = "infinity";

		/**
		* @brief A constant that turns the camera to macro mode.
		*/
		MACRO = "macro";

		/**
		* @brief A constant that sets the camera to fixed focus mode.
		*/
		FIXED = "fixed";

	} //end MA_CAMERA_FOCUS_
} //end of FocusMode

group ImageFormat "Image Formats" {
	constset MAString MA_CAMERA_IMAGE_ {
		/**
		* @brief A constant that represents JPEG image format.
		*/
		JPEG = "jpeg";

		/**
		* @brief A constant that represents RAW image format.
		*/
		RAW = "raw";

	} //end MA_CAMERA_IMAGE_
} //end ImageFormats

group CameraProperties "Camera Properties" {

	constset MAString MA_CAMERA_ {

		/**
		* @brief Sets the flash mode for the camera.
		*
		* @validvalue can be one of the #MA_CAMERA_FLASH_ON, #MA_CAMERA_FLASH_OFF, #MA_CAMERA_FLASH_AUTO, #MA_CAMERA_FLASH_TORCH constants
		*
		* @par Example
		* \code
		*	maCameraSetProperty(MAW_CAMERA_FLASH_MODE, MA_CAMERA_FLASH_AUTO);
		* \endcode
		*/
		FLASH_MODE = "flash-mode";

		/**
		* @brief Sets the focus mode for the camera.
		*
		* @validvalue can be one of the #MA_CAMERA_FOCUS_AUTO, #MA_CAMERA_FOCUS_INFINITY, #MA_CAMERA_FOCUS_MACRO, #MA_CAMERA_FOCUS_FIXED constants
		*
		* @par Example
		* \code
		*	maCameraSetProperty(MAW_CAMERA_FOCUS_MODE, MA_CAMERA_FOCUS_AUTO);
		* \endcode
		*/
		FOCUS_MODE = "focus-mode";

		/**
		* @brief Sets the image format for the camera.
		*
		* @validvalue can be one of the #MA_CAMERA_IMAGE_JPEG, #MA_CAMERA_IMAGE_RAW constants
		*
		* @par Example
		* \code
		*	maCameraSetProperty(MAW_CAMERA_IMAGE_FORMAT, MA_CAMERA_IMAGE_JPEG);
		* \endcode
		*/
		IMAGE_FORMAT = "image-format";


		/**
		* @brief Sets the zoom level for the camera.
		*
		* @validvalue an int string that can be between 0 and #MA_CAMERA_MAX_ZOOM
		*
		* @par Example
		* \code
		*	maCameraSetProperty(MAW_CAMERA_ZOOM, "1");
		* \endcode
		*/
		ZOOM = "zoom";

		/**
		* @brief Provides the information about the maximum supported zoom level on the device.
		*
		* @getonly
		*
		*/
		MAX_ZOOM = "max-zoom";

		/**
		* @brief Indicates that if the device supports zoom or not.
		*
		* @validvalue the returned value is "true" for support and "false" for lack of support.
		*
		* @getonly
		*/
		ZOOM_SUPPORTED = "zoom-supported";

		/**
		* @brief Indicates that if the device has a flash or not.
		*
		* @validvalue the returned value is "true" for support and "false" for lack of support.
		*
		* @getonly
		*/
		FLASH_SUPPORTED = "flash-supported";

	} //end of MAC_
} // end of CameraProperties

group CameraFunctions "Camera Functions" {
		/**
		* \brief The camera format, in pixels.
		*/
		struct MA_CAMERA_FORMAT {
			//in pixels.
			int width;
			int height;
		}

		/**
		* Returns the number of different output formats supported by the current device's camera.
		* \< 0 if there is no camera support.
		* 0 if there is camera support, but the format is unknown.
		*/
		int maCameraFormatNumber();

		/**
		* Stores an output format in \a fmt.
		* \a index must be \>= 0 and \< the number returned by maCameraFormatNumber().
		* \returns 0.
		*/
		int maCameraFormat(in int index, out MA_CAMERA_FORMAT fmt);

		/**
		* Starts a fullscreen viewfinder.
		* Returns 1 if the viewfinder was started, 0 if it was already running or \< 0 on error.
		*/
		// can be varied, but for now, we're keeping it simple.
		int maCameraStart();

		/**
		* Stops the viewfinder.
		* Returns 1 if the viewfinder was stopped, 0 if it was not running or \< 0 on error.
		*/
		int maCameraStop();

		/**
		* Adds a previewWidget to the camera controller in devices that support native UI.
		* Returns 1 for success, \< 0 on error.
		*/
		int maCameraSetPreview(in MAHandle widgetHandle);

		/**
		* Selects a Camera from the available ones.
		* Returns 1 for success, \< 0 on error.
		*/
		int maCameraSelect(in int cameraNumber);


		/**
		* Returns the number of available Camera on the device.
		* Returns 1 for success, \< 0 on error.
		*/
		int maCameraNumber();

		/**
		* Requires the viewfinder to be active.
		* Takes a snapshot using the specified format. The snapshot is
		* stored as a new data object in the supplied placeholder.
		* Returns 0 on success, or \< 0 on error.
		*/
		int maCameraSnapshot(in int formatIndex, in MAHandle placeholder);

		/**
		* Starts or stops recording video.
		* \a stopStartFlag indicates the operation.
		* 1 for start recording and 0 for stop recording.
		* Returns 1 for success, \< 0 on error.
		*/
		int maCameraRecord(in int stopStartFlag);


		/**
		* Sets a specified property on the Selected Camera.
		*
		* \param property A string representing which property to set.
		* \param value The value which will be assigned to the property.
		*
		* \returns 1 for success and <0 for failure.
		*/
		int maCameraSetProperty(in MAString property, in MAString value);

		/**
		* retrives a specified property on the Selected Camera.
		*
		* \param property A string representing which property to set.
		* \param value A buffer that will hold the value of the property, represented as a string.
		* \param bufSize Size of the buffer.
		*
		* \returns 1 for success and <0 for failure.
		*/
		int maCameraGetProperty( in MAString property, out MAString value range("bufSize"), in int bufSize);

	} // end of CameraFunctions

	} //end of CameraAPI

		/**
		* Shows the virtual keyboard.
		*/
		int maShowVirtualKeyboard();

		/**
		* Displays a NativeUI text box, with
		* "OK" and "Cancel" buttons (or equivalent command items
		* if the OS uses other input methods).
		* The user can enter text using the native input system.
		*
		* This function returns immediately, leaving the text box on-screen.
		* While the text box is active, it will consume all key events.
		* Other events, like networking, will still be handled normally.
		*
		* When the user activates one of the command items ("OK" or "Cancel"),
		* a number of things will happen in order:
		*
		* The box's text will be copied to the buffer specified by \a outText.
		* The text box will disappear.
		* An event (#EVENT_TYPE_TEXTBOX) will be posted.
		*
		* The text box will allow input of up to (\a maxSize - 1) characters, but no more.
		* Additional keypresses at that point may be ignored, or may cause an error message,
		* at the discretion of the underlying implementation.
		*
		* \returns \>= 0 on success, \< 0 on error.
		*
		* \param title The box's title.
		* \param inText When the text box is created, it is populated with this string.
		* \param outText Pointer to a buffer. When the text box closes, the contents
		* are copied to this buffer.
		* \param maxSize The size of the buffer, in characters. Includes the terminating zero.
		* \param constraints Rules for how text is entered into the box.
		* Must be exactly one of the \link #MA_TB_TYPE_ANY MA_TB_TYPE \endlink constants, or'd with zero or more of the
		* \link #MA_TB_FLAG_PASSWORD MA_TB_FLAG \endlink constants.
		* \note Some combinations of constraint types and flags are useless or invalid.
		*/
		int maTextBox(in MAWString title, in MAWString inText,
			out MAWString outText range("maxSize * sizeof(wchar)"),
			in int maxSize, in int constraints);

		constset int MA_TB_TYPE_ {
			/// The user is allowed to enter any text, including line breaks.
			ANY = 0;
			/// The user is allowed to enter an e-mail address.
			EMAILADDR = 1;
			/// The user is allowed to enter an integer value.
			NUMERIC = 2;
			/// The user is allowed to enter a phone number.
			PHONENUMBER = 3;
			/// The user is allowed to enter a URL.
			URL = 4;
			/// The user is allowed to enter a real number value.
			/// This extends #MA_TB_TYPE_NUMERIC by allowing a decimal point.
			DECIMAL = 5;
			/** \brief The user is allowed to enter any text, except for line breaks.
			* Unavailable on some platforms.
			* In that case, maTextBox() will return #MA_TB_RES_TYPE_UNAVAILABLE.
			* You can use #MA_TB_TYPE_ANY instead.
			*/
			SINGLE_LINE = 100;

			/** Use this to separate types from flags in the \a constraints parameter.
			* This is not a valid type value.
			*/
			MASK = 0xFFFF;
		}
		constset int MA_TB_RES_ {
			/// The user chose OK.
			OK = 1;
			/// The user chose Cancel.
			CANCEL = 2;
			/// The specified type is unavailable on this platform.
			TYPE_UNAVAILABLE = -3;
		}
		constset int MA_TB_FLAG_ {
			/// Indicates that the text entered is confidential data that should be
			/// obscured whenever possible.
			/// This implies #MA_TB_FLAG_SENSITIVE.
			PASSWORD = 0x10000;
			/// Indicates that editing is disallowed.
			UNEDITABLE = 0x20000;
			/// Indicates that the text entered is sensitive data that the implementation
			/// must never store into a dictionary or table for use in predictive, auto-completing,
			/// or other accelerated input schemes. A credit card number is an example of sensitive data.
			SENSITIVE = 0x40000;
			/// Indicates that the text entered does not consist of words that are likely
			/// to be found in dictionaries typically used by predictive input schemes.
			NON_PREDICTIVE = 0x80000;
			/// This flag is a hint to the implementation that during text editing,
			/// the initial letter of each word should be capitalized.
			INITIAL_CAPS_WORD = 0x100000;
			/// This flag is a hint to the implementation that during text editing,
			/// the initial letter of each sentence should be capitalized.
			INITIAL_CAPS_SENTENCE = 0x200000;
		}

		/**
		* Make MoSync send key-events for the specified key, even when
		* the application does not have focus.
		* Can only capture one key at a time.
		* @param keyCode The \link #MAK_UNKNOWN MAK \endlink code for the key to capture.
		* @return \< 0 on error.
		* \see maKeyCaptureStop()
		*/
		int maKeyCaptureStart(in int keyCode);

		/**
		* Stops any key capture in progress.
		* @returns \< 0 on error.
		* \see maKeyCaptureStart()
		*/
		int maKeyCaptureStop();

		/**
		 * Turn on sending of HomeScreen events. Off by default.
		 * @return \< 0 on error.
		 * \see #EVENT_TYPE_HOMESCREEN_SHOWN
		 * \see #EVENT_TYPE_HOMESCREEN_HIDDEN
		 * \see maHomeScreenEventsOff()
		 */
		int maHomeScreenEventsOn();

		/**
		 * Turn off sending of HomeScreen events. Off by default.
		 * @return \< 0 on error.
		 */
		int maHomeScreenEventsOff();

		/**
		* Add shortcut icon to the device home screen.
		* Available on Android only.
		* @param name The name (label) of the shortcut to add.
		* @return \< 0 on error.
		*/
		int maHomeScreenShortcutAdd(in MAString name);

		/**
		* Remove shortcut icon from the device home screen.
		* Available on Android only.
		* @param name The name (label) of the shortcut to remove.
		* @return \< 0 on error.
		*/
		int maHomeScreenShortcutRemove(in MAString name);

		/**
		 * Add a notification item.
		 *
		 * Note that there can only be one notification of type
		 * #NOTIFICATION_TYPE_APPLICATION_LAUNCHER. Additional notification
		 * types may be added in the future. This syscall is available
		 * on Android only.
		 *
		 * @param type The #NOTIFICATION_TYPE_APPLICATION_LAUNCHER constant.
		 * @param id The id of the notification. The id must be unique within
		 * the application.
		 * @param title Title of the notification.
		 * @param text String to be displayed as part of the notification.
		 * @return \< 0 on error or if the syscall is not available on the
		 * current platform.
		 */
		int maNotificationAdd(
			in int type,
			in int id,
			in MAString title,
			in MAString text);

		/**
		 * Remove a notification item.
		 * Currently implemented only on Android.
		 * @param id The id of the notification.
		 * @return \< 0 on error.
		 */
		int maNotificationRemove(in int id);

		constset int NOTIFICATION_TYPE_ {
			/// A persistent notification that will launch the
			/// application when selected.
			APPLICATION_LAUNCHER = 1;
		}

		/**
		 * Set the screen orientation.
		 * Currently implemented only on Android.
		 * @param orientation One of the \link #SCREEN_ORIENTATION_LANDSCAPE
		 * #SCREEN_ORIENTATION_PORTRAIT #SCREEN_ORIENTATION_DYNAMIC \endlink
		 * constants.
		 * @return \< 0 on error.
		 */
		int maScreenSetOrientation(in int orientation);

		constset int SCREEN_ORIENTATION_ {
			/// Landscape screen orientation.
			LANDSCAPE = 1;
			/// Portrait screen orientation.
			PORTRAIT = 2;
			/// Screen orientation is based on device sensor.
			DYNAMIC = 3;
		}

		/**
		 * Enable/disable fullscreen mode.
		 * Currently implemented only on Android.
		 * @param fullscreen 1 for fullscreen on, 0 for fullscreen off.
		 * @return \< 0 on error.
		 */
		int maScreenSetFullscreen(in int fullscreen);

		/**
		 * Turn on sending of screen state events. Off by default.
		 * Currently implemented only on Android.
		 * @return \< 0 on error.
		 * \see #EVENT_TYPE_SCREEN_STATE_ON
		 * \see #EVENT_TYPE_SCREEN_STATE_OFF
		 * \see maHomeScreenEventsOff()
		 */
		int maScreenStateEventsOn();

		/**
		 * Turn off sending of screen state events. Off by default.
		 * Currently implemented only on Android.
		 * @return \< 0 on error.
		 */
		int maScreenStateEventsOff();

group OpenGLES "OpenGLES" {
#include "opengl_non_generated.idl"
#include "opengl_generated.idl"
}
		/**
		 * Logs information about the state of all current resources.
		 */
		void maReportResourceInformation();

		/**
		 * @deprecated use #maAlert instead.
		 * Displays a message to the user.
		 * \param title The title of the message box shown
		 * \param message The message should be short, not more than 40 characters,
		 * to ensure its visibility on all screen sizes.
		 */
		void maMessageBox(in MAString title, in MAString message);

		/**
		* Displays a message to the user.
		* It contains optional title, message and 3 buttons for selection.
		* On Android the buttons point to a positive, negative or neutral action.
		* When one of the buttons are clicked the alert is automatically dismissed.
		* When a selection is made a #EVENT_TYPE_ALERT event is sent with the button index.
		* \param title The title of the message box shown.
		* \param message The message should be short, not more than 40 characters,
		* to ensure its visibility on all screen sizes.
		* \button1 The text on the first button. On Android it indicates a positive selection.
		* \button2 The text on the second button. On Android it indicates a neutral selection.
		* \button3 The text on the third button. On Android it indicates that a negative selection.
		*/
		void maAlert(in MAString title, in MAString message, in MAString button1, in MAString button2, in MAString button3);

		/**
		* Displays an image picker to the user.
		* It's display depends on the platform.
		* Note: when a selection is made a #EVENT_TYPE_IMAGE_PICKER event is sent.
		*/
		void maImagePickerOpen();

		/**
		* Displays a special kind of dialog that has a list of possible choices.
		* The list of options is displayed as buttons on iOS, and as text views on Android.
		* By clicking any option the dialog gets dismissed and a #EVENT_TYPE_OPTIONS_BOX_BUTTON_CLICKED event is sent back.
		*
		* \param title The dialog title.
		* \param destructiveButtonTitle The destructive button text. This is an iOS specific feature: it has different color than the other options,
		* and it indicates that it's action has destructive behaviour. On Android it is treated and it looks like a normal option.
		* \param cancelButtonTitle The dialog's Cancel button text. If left empty, the dialog is not cancelable.
		* \param otherButtonTitles The address to the buffer that stores the list of options.
		* \param otherButtonTitlesSize The size of the buffer, in bytes.
		*/
		void maOptionsBox(in MAWString title,in MAWString destructiveButtonTitle, in MAWString cancelButtonTitle,
								 in MAAddress otherButtonTitles, in int otherButtonTitlesSize);

group SensorAPI "Sensor API" {
		group SensorTypes "Sensor Types" {
		constset int SENSOR_TYPE_ {
			// A constant describing an accelerometer sensor type.
			ACCELEROMETER = 1;
			// A constant describing a magnetic field sensor type.
			MAGNETIC_FIELD = 2;
			// A constant describing an orientation sensor type.
			ORIENTATION = 3;
			// A constant describing a gyroscope sensor type.
			GYROSCOPE = 4;
			// A constant describing an proximity sensor type.
			PROXIMITY = 5;
		}

		} // end of sensor types

		group SensorConsts "Sensor Constants" {
		constset int SENSOR_RATE_ {
			// Get sensor data as fast as possible.
			FASTEST = 0;
			// A rate suitable for games.
			GAME = -1;
			// The default rate. Suitable for screen orientation changes.
			NORMAL = -2;
			// A rate suitable for the user interface.
			UI = -3;
		}

		constset int SENSOR_ERROR_ {
			NONE = 0;
			// Errors for maSensorStart
			NOT_AVAILABLE = -1;
			INTERVAL_NOT_SET = -2;
			ALREADY_ENABLED = -3;
			// Errors for maSensorStop
			NOT_ENABLED = -4;
			CANNOT_DISABLE = -5;
		}

		constset int UIDEVICE_ORIENTATION_ {
		    // The orientation of the device cannot be determined.
			UNKNOWN = 0;
			// The device is in portrait mode, with the device held upright and the home button at the bottom.
			PORTRAIT = 1;
			// The device is in portrait mode but upside down, with the device held upright and the home button at the top.
			PORTRAIT_UPSIDE_DOWN = 2;
			// The device is in landscape mode, with the device held upright and the home button on the right side.
			LANDSCAPE_LEFT = 3;
			// The device is in landscape mode, with the device held upright and the home button on the left side.
			LANDSCAPE_RIGHT = 4;
			// The device is held parallel to the ground with the screen facing upwards.
			FACE_UP = 5;
			// The device is held parallel to the ground with the screen facing downwards.
			FACE_DOWN = 6;
		}

		constset int SENSOR_PROXIMITY_VALUE_ {
			// the device is not close to the user
			FAR = 0;
			// the device is close to the user
			NEAR = 1;
		}

		} //end of sensor constants

	group SensorFunctions "Sensor Functions" {
		/**
		* \brief Enables a sensor and starts sending events if the sensor is available.
		* If the sensor is already enabled this call will have no effect.
		* \param sensor       The sensor which should be enabled.
		* One of the \link #SENSOR_TYPE_ACCELEROMETER SENSOR_TYPE \endlink constants.
		* \param interval     Time interval in which a sensor update shall be triggered.
		* Can be one of the \link #SENSOR_RATE_FASTEST SENSOR_RATE \endlink constants or a time interval in milliseconds.
		* \return    #SENSOR_ERROR_NONE  on success.
		*            #SENSOR_ERROR_NOT_AVAILABLE if this sensor wasn't available.
		*            #SENSOR_ERROR_INTERVAL_NOT_SET if the interval wasn't set, could be due to platform limitations.
		*            #SENSOR_ERROR_ALREADY_ENABLED if the sensor already was enabled.
		* \see #EVENT_TYPE_SENSOR
		*/
		int maSensorStart(in int sensor, in int interval);

		/**
		* \brief Disables a sensor so that it doesn't send any further events.
		* \param sensor    The sensor which should be disabled.
		* One of the \link #SENSOR_TYPE_ACCELEROMETER SENSOR_TYPE \endlink constants.
		* \return    #SENSOR_ERROR_NONE on success.
		*            #SENSOR_ERROR_NOT_ENABLED if this sensor wasn't enabled.
		*            #SENSOR_ERROR_CANNOT_DISABLE if there was a problem disabling the sensor.
		* \see #EVENT_TYPE_SENSOR
		*/
		int maSensorStop(in int sensor);

	}//End of Sensor Functions
} //End of Sensor API group

group NFCAPI "NFC API" {
		/**
		* Start listening to NFC events.
		* \return MA_NFC_NOT_ENABLED if NFC is not enabled on this device,
		* MA_NFC_NOT_AVAILABLE if NFC is not at all available, or
		* 0 otherwise. If the proper permissions (NFC) are not set, a panic will
		* be raised.
		*/
		int maNFCStart();

		/**
		* Stop listening to NFC events.
		*/
		void maNFCStop();

		/**
		* Reads the next available tag.
		* @return A zero handle if no tag currently available
		*/
		MAHandle maNFCReadTag(in MAHandle nfcContext);

		/**
		* Destroys the tag. Clients are responsible for calling
		* this function for every corresponding maNFCReadTag.
		*/
		void maNFCDestroyTag(in MAHandle tagHandle);

		/**
		* Connects to a tag, enabling further I/O operations to be
		* performed on it.
		*/
		void maNFCConnectTag(in MAHandle tagHandle);

		/**
		* Closes I/O operations for a tag, disabling further I/O operations to be
		* performed on it.
		*/
		void maNFCCloseTag(in MAHandle tagHandle);

		/**
		* Determines whether a tag is of a certain type.
		* Use the constants prefixed with MA_NFC_TAG_TYPE_ to
		* see the available tag types.
		* \return > 0 if the tag is a the specified type, 0 if it is not,
		* and MA_NFC_INVALID_TAG_TYPE if the tag type is not supported
		* by this platform.
		*/
		int maNFCIsType(in MAHandle tagHandle, in int type);

		/**
		* To be able to call functions tag require the tag to be of
		* a certain type (see maNFCIsType), the tag received
		* must be converted to the proper type (see MA_NFC_TAG_TYPE_*
		* constants).
		* All typed tags returned by this function will be destroyed
		* when the tag used to produce them is destroyed. Ie no
		* explicit destruction of typed tags is necessary (but allowed).
		* \return A handle if the type was convertable to the specified
		* type.
		*/
		MAHandle maNFCGetTypedTag(in MAHandle tagHandle, in int type);

		/**
		* Starts a batch operation. No NFC I/O operations will be performed
		* until maBatchCommit has been called.
		* Note that only one active batch per tag is allowed.
		* \param The tag on which to perform the batch operation.
		* \return A non-zero value if a batch is already started for this tag or if a batch
		* could not be started, 0 otherwise.
		*/
		int maNFCBatchStart(in MAHandle tagHandle);

		/**
		* Asynchronously performs all operations since the last call to maNFCBatchStart. The event
		* delivered will be of the EVENT_TYPE_NFC_BATCH_OP type and
		* with an MANFCEventData containing the tag's handle.
		* \param The handle to the tag that is in batch mode.
		*/
		void maNFCBatchCommit(in MAHandle tagHandle);

		/**
		* Cancels all operations of the current batch.
		* \param The handle to the tag that is in batch mode.
		*/
		void maNFCBatchRollback(in MAHandle tagHandle);

		/**
		* Sends a message to a tag. The response will come as
		* an EVENT_TYPE_NFC_TAG_DATA_READ event, with the
		* handle set to the handle passed into this method
		* and the result field set to the number of bytes
		* actually read.
		* \param tag The tag to communicate with.
		* \param src The data to send.
		* \param len The length of the data to send.
		* \return 0 if the tag can be transceived to, < 0 otherwise.
		*/
		int maNFCTransceive(in MAHandle tag, in MAAddress src, in int srcLen, out MAAddress dst, out int dstLen);

		/**
		* Makes a tag read-only (this operation cannot be reverted).
		* The response will come as an EVENT_TYPE_NFC_TAG_READ_ONLY event, with the
		* handle set to the handle passed into this method.
		* \param tag The tag to make read only.
		* \return MA_NFC_INVALID_TAG_TYPE if the handle given as argument
		* cannot be made read-only.
		*/
		int maNFCSetReadOnly(in MAHandle tag);

		/**
		* Checks whether a tag is read-only.
		* \param tag The tag to check for read/write permissions.
		* \return MA_NFC_INVALID_TAG_TYPE if this operation is
		* not applicable, a value > 0 if it is read-only, or
		* 0 if it is read-only.
		*/
		int maNFCIsReadOnly(in MAHandle tag);

		/**
		* Returns the capacity/size of a tag,
		* or -1 if unknown.
		*/
		int maNFCGetSize(in MAHandle tag);

		/**
		* Reads an NDEF message from the given tag, which must
		* be of the MA_NFC_TAG_TYPE_NDEF type.
		* The response will come a an EVENT_TYPE_NFC_TAG_DATA_READ
		* event with the handle set to the handle passed into this method
		* and the result field set to 0 on success and a value < 0 on error.
		* After receiving the event, clients may call
		* maNFCGetNDEFMessage() to get the actual message.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCReadNDEFMessage(in MAHandle tag);

		/**
		* Writes an NDEF message to the given tag, which must
		* be of the MA_NFC_TAG_TYPE_NDEF or MA_NFC_TAG_TYPE_NDEF_FORMATTABLE type.
		* The response will come a an EVENT_TYPE_NFC_TAG_DATA_WRITE
		* event with the handle set to the handle passed into this method,
		* the result field set to 0 on success and a value < 0 on error,
		* and the dstId field set to the ndefMessage written.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		* \param tag The tag handle to write to
		* \param ndefMessage The message to write
		*/
		int maNFCWriteNDEFMessage(in MAHandle tag, in MAHandle ndefMessage);

		/**
		* Creates a new NDEF message, to be used primarily by
		* \code maNFCWriteDefMessage.
		* \param recordCount The number of records in the created message
		* \return The handle to the created NDEF message; clients are
		* responsible for destroying the message.
		*/
		MAHandle maNFCCreateNDEFMessage(in int recordCount);

		/**
		* Gets the NDEF message from a tag, which must
		* be of the MA_NFC_TAG_TYPE_NDEF type.
		* * If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		* \return The handle to the NDEF message, which
		* may be subsequently used in NDEF specfic functions,
		* or the zero handle if the tag has no NDEF message
		* associated with it (in which case, clients may call
		* maNFCReadNDEFMessage).
		* IMPORTANT: Once the tag has been destroyed OR if
		* maNFCReadNDEFMessage is called, any NDEF messages
		* previously returned by this function
		* will be destroyed with it and cannot
		* be used.
		*/
		int maNFCGetNDEFMessage(in MAHandle tag);

		/**
		* \return A handle to the ith NDEF record of an NDEF message.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		MAHandle maNFCGetNDEFRecord(in MAHandle ndef, in int ix);

		/**
		* \return The number of NDEF records in an NDEF message.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCGetNDEFRecordCount(in MAHandle ndef);

		/**
		* Reads the variable length id of an NDEF record.
		* \param ndefRecord the handle to the record to read from.
		* \param dst Where the result should be written to.
		* \param len The maximum length to write.
		* \return The number of bytes written.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCGetNDEFId(in MAHandle ndefRecord, out MAAddress dst, in int len);

		/**
		* Reads the variable length payload of an NDEF record.
		* \param ndefRecord the handle to the record to read from.
		* \param dst Where the result should be written to.
		* \param len The maximum length to write.
		* \return The number of bytes written.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCGetNDEFPayload(in MAHandle ndefRecord, out MAAddress dst, in int len);

		/**
		* Returns the 3-bit TNF of an NDEF record.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCGetNDEFTnf(in MAHandle ndefRecord);

		/**
		* Returns the variable length type field of an NDEF record.
		* \param ndefRecord the handle to the record to read from.
		* \param dst Where the result should be written to.
		* \param len The maximum length to write.
		* \return The number of bytes written.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCGetNDEFType(in MAHandle ndefRecord, out MAAddress dst, in int len);

		/**
		* Sets the variable length id of an NDEF record.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCSetNDEFId(in MAHandle ndefRecord, in MAAddress dst, in int len);

		/**
		* Sets the variable length payload of an NDEF record.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCSetNDEFPayload(in MAHandle ndefRecord, in MAAddress dst, in int len);

		/**
		* Sets the 3-bit TNF of an NDEF record,
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCSetNDEFTnf(in MAHandle ndefRecord, in int tnf);

		/**
		* Returns the variable length type field of an NDEF record.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCSetNDEFType(in MAHandle ndefRecord, in MAAddress dst, in int len);

		/**
		* Authenticates a MIFARE Classic tag using the A or B key. Authentication must take place
		* before reading/writing to a certain sector.
		* The operation is asyncronous and will result in an EVENT_TYPE_NFC_TAG_AUTH_COMPLETE
		* event, unless part of a batch operation.
		* \param tagHandle The tag to authenticate
		* \param keyType Either MA_NFC_MIFARE_KEY_A or MA_NFC_MIFARE_KEY_B.
		* \param sectorIndex The sector to authenticate
		* \param keySrc The address to the key to authenticate with
		* \param keyLen The length of the key to authenticate with
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCAuthenticateMifareSector(in MAHandle tagHandle, in int keyType, in int sectorIndex, in MAAddress keySrc, in int keyLen);

		/**
		* \return The number of sectors of a MIFARE Classic tag.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCGetMifareSectorCount(in MAHandle tagHandle);

		/**
		* Returns the number of blocks in a sector of a MIFARE Classic tag.
		* \param sector The sector to get the number of blocks in.
		* \return The number of blocks in a given sector.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCGetMifareBlockCountInSector(in MAHandle tagHandle, in int sector);

		/**
		* Returns the first block of a sector of a MIFARE Classic tag.
		* \param sector The sector of which to get the first block.
		* \return The index of the first block of the sector is returned.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCMifareSectorToBlock(in MAHandle tagHandle, in int sector);

		/**
		* Reads a number of blocks of a MIFARE Classic tag.
		* The operation is asyncronous and will result in an EVENT_TYPE_NFC_TAG_READ
		* event, unless part of a batch operation.
		* \param firstBlock The first block to read from.
		* \param dst The memory address to write to.
		* \param len The number of bytes to read. Several blocks may be read, depending
		* on len (A block is 16 bytes).
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCReadMifareBlocks(in MAHandle tagHandle, in int firstBlock, out MAAddress dst, in int len);

		/**
		* Writes a number of blocks to a MIFARE Classic tag.
		* The operation is asyncronous and will result in an EVENT_TYPE_NFC_TAG_WRITE
		* event, unless part of a batch operation.
		* \param firstBlock The first block to write to.
		* \param dst The memory address to read from.
		* \param len The number of bytes to write. Several blocks may be written, depending
		* on len (A block is 16 bytes).
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCWriteMifareBlocks(in MAHandle tagHandle, in int firstBlock, in MAAddress dst, in int len);

		/**
		* Reads a number of blocks of a MIFARE Ultralight tag.
		* The operation is asyncronous and will result in an EVENT_TYPE_NFC_TAG_READ
		* event, unless part of a batch operation.
		* \param firstBlock The first block to read from.
		* \param dst The memory address to write to.
		* \param len The number of bytes to read. Several pages may be read, depending
		* on len (A page is 16 bytes).
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCReadMifarePages(in MAHandle tagHandle, in int firstPage, out MAAddress dst, in int len);

		/**
		* Writes a number of blocks of a MIFARE Ultralight tag.
		* The operation is asyncronous and will result in an EVENT_TYPE_NFC_TAG_WRITE
		* event, unless part of a batch operation.
		* \param firstBlock The first block to write to.
		* \param dst The memory address to read from.
		* \param len The number of bytes to write. Several pages may be written, depending
		* on len (A page is 16 bytes).
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCWriteMifarePages(in MAHandle tagHandle, in int firstPage, in MAAddress dst, in int len);

		constset int MA_NFC_ {
			/**
			* A constant indicating there is no NFC support on the device.
			*/
			NOT_AVAILABLE = -1;

			/**
			* A constant indicating NFC is not enabled on the device. (But there is hardware support).
			*/
			NOT_ENABLED = -2;

			/**
			* A constant indicating an invalid tag type.
			*/
			INVALID_TAG_TYPE = -2;

			/**
			* An error code if tag connection is lost.
			*/
			TAG_CONNECTION_LOST = -3;

			/**
			* An error code if trying to perform I/O on an unconnected
			* tag.
			*/
			TAG_NOT_CONNECTED = -4;

			/**
			* An error code used by maNFCWriteNDEF if maNFCWriteNDEF was
			* performed on an NDEF_FORMATTABLE tag and failed.
			*/
			FORMAT_FAILED = -5;

			/**
			* An error code if some general I/O error occurred,
			* other than the special case of tag connection being lost.
			*/
			TAG_IO_ERROR = -127;

		}

		constset int MA_NFC_TAG_TYPE_ {

			/**
			* Represents an NDEF (NFC Data Exchange Format) tag.
			*/
			NDEF = 1;

			/**
			* Represents a Mifare Classic tag.
			*/
			MIFARE_CL = 2;

			/**
			* Represents a Mifare Ultralight tag.
			*/
			MIFARE_UL = 3;

			/**
			* Represents an NfcA tag (ISO 14443-3A).
			*/
			NFC_A = 4;

			/**
			* Represents an NfcB tag (ISO 14443-3B).
			*/
			NFC_B = 5;

			/**
			* Represents an ISO-DEP tag (ISO 14443-4).
			*/
			ISO_DEP = 6;

			/**
			* Represents an 'abstract' tag that can
			* accept requests for formatting it into
			* an NDEF tag.
			*/
			NDEF_FORMATTABLE = 128;
		}

		constset int MA_NFC_NDEF_TNF_ {

			/**
			* Indicates the NDEF message is empty.
			*/
			EMPTY = 0;

			/**
			* Indicates the NDEF message is of a 'well-known' type;
			* it may be further identified using the MA_NFC_NDEF_RTD_*
			* constants.
			*/
			WELL_KNOWN = 1;

			/**
			* Indicates the NDEF message contains mime media;
			* use maNFCGetType() to get the mime type.
			*/
			MIME_MEDIA = 2;

			/**
			* Indicates the NDEF message contains an absolute URI,
			* the type conforming to RFC 3986.
			*/
			ABSOLUTE_URI = 3;

			/**
			* Indicates the type of the NDEF message being 'external'.
			*/
			EXTERNAL_TYPE = 4;

			/**
			* Indicates the contents of the NDEF message to be of
			* an unknown type. The type of the NDEF message should
			* be empty.
			*/
			UNKNOWN = 5;

			/**
			* Constant for chunked NDEF messages.
			*/
			UNCHANGED = 6;

			/**
			* Reserved constant.
			*/
			RESERVED = 7;
		}

		constset int MA_NFC_MIFARE_ {

			/**
			* The A key for MiFare Classic authentication
			*/
			KEY_A = 1;

			/**
			* The B key for MiFare Classic authentication
			*/
			KEY_B = 2;

		}
	}//end of NFC API

	group DBAPI "DB API" {
		struct MADBBlob {
			MAAddress data;
			int size;
		}
		struct MADBText {
			MAString addr;
			/// Length in bytes of the string pointed to by \a addr.
			/// May be \< 0, in which case the string is null-terminated.
			int length;
		}

		constset int MA_DB_TYPE_ {
			NULL = 1;
			INT = 2;
			INT64 = 3;
			DOUBLE = 4;
			BLOB = 5;
			DATA = 6;
			TEXT = 7;
		}

		/// Input value for maDBExecSQLParams().
		struct MADBValue {
			union {
				int i;
				double d;
				MADBBlob blob;
				MAHandle dataHandle;
				MADBText text;
				longlong i64;
			}
			// has to be last. otherwise this struct would get an alignment mismatch
			// due to the double union member, which has to be 8-byte-aligned on x86 platforms.
			/// One of the MA_DB_TYPE_ constants.
			int type;
		}

		/**
		 * Open a database file. The database is created if it does not exist.
		 * \note The application needs file read/write permissions to
		 * access database files.
		 * @param path Absolute path to the database file.
		 * @return Handle to the database >0 on success, #MA_DB_ERROR on error.
		 */
		MAHandle maDBOpen(in MAString path);

		/**
		 * Close a database.
		 * @param databaseHandle Handle to the database.
		 * @return #MA_DB_OK on success, #MA_DB_ERROR on error.
		 */
		int maDBClose(in MAHandle databaseHandle);

		/**
		 * Executes an SQL statement. If the statement returns a
		 * query result, a cursor handle is returned.
		 * @param databaseHandle Handle to the database.
		 * @param sql The SQL statement.
		 * @return #MA_DB_ERROR on error, #MA_DB_OK on success,
		 * > 0 if there is a cursor to a query result, in this
		 * case the return value is the cursor handle.
		 */
		MAHandle maDBExecSQL(in MAHandle databaseHandle, in MAString sql);

		/**
		 * @copydoc maDBExecSQL()
		 * @param params Array of values to bind to parameters.
		 * Parameters are specified by question marks (?)
		 * in the SQL statement.
		 *
		 * If this function returns a cursor,
		 * any text or blob values being pointed to by elements of the array must remain valid until
		 * the cursor has been destroyed by maDBCursorDestroy().
		 * The array itself does not need to remain valid after this function returns.
		 *
		 * @param paramCount Number of elements in the array pointed to by \a params.
		 */
		MAHandle maDBExecSQLParams(in MAHandle databaseHandle, in MAString sql,
			in MADBValue params, in int paramCount);

		/**
		 * Destroys a cursor. You must call this function
		 * when you are done with the cursor to release
		 * its resources.
		 * @param cursorHandle Handle to the cursor.
		 * @return #MA_DB_OK on success, #MA_DB_ERROR on error.
		 */
		int maDBCursorDestroy(in MAHandle cursorHandle);

		/**
		 * Move the cursor to the next row in the result set.
		 * Note that you must call this function before retrieving
		 * column data. The initial position of the cursor is
		 * before the first row in the result set. If the result
		 * set is empty, this function will return #MA_DB_NO_ROW.
		 * @param cursorHandle Handle to the cursor.
		 * @return #MA_DB_OK if successfully moved to next row,
		 * #MA_DB_NO_ROW if there are no more rows in the result set,
		 * #MA_DB_ERROR on error.
		 */
		int maDBCursorNext(in MAHandle cursorHandle);

		/**
		 * Get the column value at the current row pointed to
		 * by the cursor as a data object. Use this function for
		 * blob data or text data.
		 * @param cursorHandle Handle to the cursor.
		 * @param columnIndex Index of the column to retrieve value from.
		 * First column has index zero.
		 * @param placeholder Handle created with maCreatePlaceholder.
		 * A data object will be created with the column data, and the handle
		 * will refer to that data.
		 * @return #MA_DB_OK on success, #MA_DB_NULL if the column value
		 * is NULL, #MA_#MA_DB_ERROR on error.
		 */
		int maDBCursorGetColumnData(
			in MAHandle cursorHandle,
			in int columnIndex,
			in MAHandle placeholder);

		/**
		 * Get the column value at the current row pointed to
		 * by the cursor as a text data buffer. Use this function for
		 * text data.
		 * @param cursorHandle Handle to the cursor.
		 * @param columnIndex Index of the column to retrieve value from.
		 * First column has index zero.
		 * @param buffer Pointer to buffer to receive the data.
		 * The result is NOT zero terminated.
		 * @param bufferSize Max size of the buffer.
		 * @return The actual length of the data, if the actual length
		 * returned is > bufferSize, data was not copied (buffer too small),
		 * returns #MA_DB_ERROR on other errors, returns #MA_DB_NULL if the
		 * column value is NULL.
		 */
		int maDBCursorGetColumnText(
			in MAHandle cursorHandle,
			in int columnIndex,
			out MAAddress buffer,
			in int bufferSize);

		/**
		 * Get the column value at the current row pointed to
		 * by the cursor as an int value.
		 * @param cursorHandle Handle to the cursor.
		 * @param columnIndex Index of the column to retrieve value from.
		 * First column has index zero.
		 * @param value Pointer to int to receive the value.
		 * @return #MA_DB_OK on success, #MA_DB_NULL if the column value
		 * is NULL, #MA_#MA_DB_ERROR on error.
		 */
		int maDBCursorGetColumnInt(
			in MAHandle cursorHandle,
			in int columnIndex,
			out int value);

		// todo: maDBCursorGetColumnInt64

		/**
		 * Get the column value at the current row pointed to
		 * by the cursor as a double value.
		 * @param cursorHandle Handle to the cursor.
		 * @param columnIndex Index of the column to retrieve value from.
		 * First column has index zero.
		 * @param value Pointer to double to receive the value.
		 * @return #MA_DB_OK on success, #MA_DB_NULL if the column value
		 * is NULL, #MA_#MA_DB_ERROR on error.
		 */
		int maDBCursorGetColumnDouble(
			in MAHandle cursorHandle,
			in int columnIndex,
			out double value);

		/**
		 * Status codes returned by the maDB functions.
		 */
		constset int MA_DB_ {
			/**
			 * Success return value.
			 */
			OK = 0;

			/**
			 * Error return value (-1 reserved for IOCtl not implemented).
			 */
			ERROR = -2;

			/**
			 * The cursor is beyond the last row
			 * when calling #maDBCursorNext.
			 */
			NO_ROW = -3;

			/**
			 * A database field value was NULL when calling
			 * the maDBCursorGetColumn* functions.
			 */
			NULL = -4;
		}
	} // End of DB API

#if IX_AUDIO
	group AudioAPI "Audio API" {
		typedef int MAAudioData;
		typedef int MAAudioInstance;

		group AudioAPIConsts "Audio API Constants" {
			constset int MA_AUDIO_DATA_ {
				// Bit in maAudioDataCreate flags to specify if the sound should be streamed instead of fully decoded to memory.
				STREAM = 1;
			}

			constset int MA_AUDIO_ERR_ {
				OK = 0;
				INVALID_INSTANCE = -2;
				INVALID_DATA = -3;
				INVALID_FILENAME = -4;
				INVALID_FILE = -5;
				STREAMING_NOT_SUPPORTED = -6;
				VOLUME_OUT_OF_RANGE = -7;
				POSITION_OUT_OF_RANGE = -8;
				INVALID_SOUND_FORMAT = -9;
				OUT_OF_MEMORY = -10;
			}
		} // end of Audio API constants

		group AudioAPIFunctions "Audio API Functions" {
			MAAudioData maAudioDataCreateFromResource(in MAString mime, in MAHandle data, in int offset, in int length, in int flags);
			MAAudioData maAudioDataCreateFromFile(in MAString mime, in MAString filename, in int flags);
			int maAudioDataDestroy(in MAAudioData audioData);
			MAAudioInstance maAudioInstanceCreate(in MAAudioData audioData);
			int maAudioInstanceDestroy(in MAAudioInstance audioInstance);
			int maAudioGetLength(in MAAudioInstance audio);
			int maAudioSetNumberOfLoops(in MAAudioInstance audio, in int loops);
			int maAudioPlay(in MAAudioInstance audio);
			int maAudioSetPosition(in MAAudioInstance audio, in int milliseconds);
			int maAudioGetPosition(in MAAudioInstance audio);
			int maAudioSetVolume(in MAAudioInstance audio, in float volume);
			int maAudioStop(in MAAudioInstance audio);
		}// End of Audio API Functions
	} // End of Audio API group
#endif // IX_AUDIO

	/**
	* Enable panics for programmer errors.
	* Such panics are enabled by default, but can be disabled by maSyscallPanicsDisable().
	* If a panic is raised a message will be displayed to the user and the program will be shut down.
	* \return #RES_OK.
	*/
	int maSyscallPanicsEnable();

	/**
	* Disable panics for programmer errors.
	* Some errors, such as feeding invalid parameters to certain syscalls,
	* can be prevented by the programmer. By default, these errors cause a MoSync Panic.
	* After this function is called,
	* if such an error occurs in a syscall, an error code will be returned by the syscall and the
	* program will continue running.
	* Panics can be re-enabled by maSyscallPanicsEnable().
	* \return #RES_OK.
	*/
	int maSyscallPanicsDisable();
}
	constset int IOCTL_ {
		UNAVAILABLE = -1;
	}

}
