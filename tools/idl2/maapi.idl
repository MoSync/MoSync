/*
Copyright (C) 2009 MoSync AB

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License,
version 2, as published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
MA 02110-1301, USA.
*/

/** \file maapi.h
* \brief Syscall declarations. These system calls and low-level
* functions provide access to the basic features of a device. They are
* implemented by the MoSync runtimes in code native to the device.
*


* With these syscalls it should be possible to do most things, although,
* there may still be some functionality missing. If you
* would like a specific function added, please send us a
* <a href="mailto:info@mobilesorcery.com">mail</a>.

* In future versions of MoSync an extension API will be provided
* that will allow you to create your own custom syscalls.


* Some Caveats:
*

* The Runtime expects alignment rules to be followed.
* Writing or reading to unaligned memory will cause a MoSync Panic.

* Some functions may also cause a panic if they are passed incorrect parameters.
* A complete reference of these panics can be found <a href="../panics.html">here</a>.

* The codepage for functions that use strings is platform-dependent beyond 7-bit ASCII.
* Most use Latin-1, but you should still be wary.


* Additional notes:


* There are different types of handles: Connection, Store and Resource.
* They are all represented as positive signed integers.
* When a handle is passed to a function, it must have the proper type.

* Each MoSync program has a Resource array. It is acccessed and manipulated by certain
*  syscalls, but it cannot be accessed directly.
* Each resource (aka Object) is represented by a
* handle. There are different types of resources, for example
* Image, Binary data, Sound or Placeholder. A placeholder object is not a real object, but
* just a handle which you can use to construct new objects dynamically.
* Resources can also be defined at compile time, by using MoSync's resource compiler.
* Placeholders can either be defined at compile time using a resource compiler directive
* or created dynamically at runtime using maCreatePlaceholder().
* See the tutorials, examples and the resource compiler reference documentation for more
* information.

* There is an event queue which contains keypad events and results from asynchronous operations.
* Use maWait() and maGetEvent() to handle it.

* MoSync socket/Bluetooth/HTTP connections are asynchronous. Read all about it \link connApiOverview here\endlink.
*/

interface MAAPI {

	typedef char* MAString;
	typedef wchar* MAWString;
	typedef void* MAAddress;
	typedef int MAHandle;
	typedef int MAExtent;
	typedef unsigned char byte;
	typedef unsigned long ulong;
	typedef long long longlong;

	/// Returns the height of an MAExtent.
#define EXTENT_Y(e) ((short)(e))

	/// Returns the width of an MAExtent.
#define EXTENT_X(e) ((short)((e) >> 16))

	/// Creates an MAExtent.
#define EXTENT(x, y) ((MAExtent)((((int)(x)) << 16) | ((y) & 0xFFFF)))

	// These three functions are at the top,
	// to ensure their numeric identifiers do not change in the future.

	/**
	* Compares the runtime's interface version with yours,
	* using a hash of the interface's contents.
	*
	* If the versions do not match, a MoSync Panic is generated.
	*
	* This function returns the runtime's hash. However, if there is
	* a version mismatch, syscall and IOCTL numbers may differ between the runtime and
	* your version of the header files, causing a different function than this to be called.
	*
	* The hash appears as a 32-bit random number, so it is very unlikely that the return
	* value from any other function is the same as the runtime's hash.
	*
	* Therefore, you should always compare the return value from this function to your hash
	* and exit your program, preferably using maPanic(), if they don't match.
	*
	* \param hash Your hash. Pass #MAIDL_HASH.
	* \returns The runtime's hash.
	*/
	int maCheckInterfaceVersion(in int hash);

	/**
	* Shuts down the system. This function does not return.
	* \param result Passed to the operating system, where applicable. Ignored otherwise.
	*/
	noreturn maExit(in int result);

	/**
	* Displays a message to the user, then shuts down the system.
	* This function does not return.
	* \param result Passed to the operating system, where applicable. Ignored otherwise.
	* \param message The message should be short, not more than 40 characters,
	* to ensure its visibility on all screen sizes.
	* \see MAPanicReport
	*/
	noreturn maPanic(in int result, in MAString message);


	/**
	* Sets \a size bytes, starting at \a dst, to the specified value, interpreted as an unsigned char.
	* \returns \a dst.
	*/
	MAAddress memset(out MAAddress dst, in int val, in ulong size);

	/**
	* Copies the values of \a size bytes from the location pointed by \a src directly to the memory
	* block pointed by \a dst.
	*
	* The underlying type of the objects pointed by both the source and destination pointers are
	* irrelevant for this function; The result is a binary copy of the data.
	*
	* The function does not check for any terminating null character in source - it always copies
	* exactly \a size bytes.
	*
	* To avoid overflows, the size of the arrays pointed by both the destination and source
	* parameters, shall be at least \a size bytes, and should not overlap (for overlapping memory
	* blocks, memmove() is a safe approach).
	* \returns \a dst.
	*/
	MAAddress memcpy(out MAAddress dst, in MAAddress src, in ulong size);

	/**
	* Compares the C string \a str1 to the C string \a str2.
	*
	* This function starts comparing the first character of each string.
	* If they are equal to each other, it continues with the following pairs until the
	* characters differ or until a terminanting null-character is reached.
	*
	* \returns An integral value indicating the relationship between the strings:
	* A zero value indicates that both strings are equal.
	* A value greater than zero indicates that the first character that does not match
	* has a greater value in \a str1 than in \a str2. A value less than zero indicates the opposite.
	*/
	int strcmp(in MAString str1, in MAString str2);

	/**
	* Copies the C string pointed by \a src into the array pointed by \a dst,
	* including the terminating null character.
	*
	* To avoid overflows, the size of the array pointed by \a dst shall be long
	* enough to contain the same C string as \a src (including the terminating null
	* character), and should not overlap in memory with \a src.
	* \returns \a dst.
	*/
	MAString strcpy(out NCString dst, in NCString src);

	/**
	* Returns \a a + \a b.
	*/
	double __adddf3(in double a, in double b);
	/**
	* Returns \a a - \a b.
	*/
	double __subdf3(in double a, in double b);
	/**
	* Returns \a a * \a b.
	*/
	double __muldf3(in double a, in double b);
	/**
	* Returns \a a / \a b.
	* If \a b == 0, a <a href="../panics.html">MoSync Panic</a> is thrown.
	*/
	double __divdf3(in double a, in double b);
	/**
	* Returns -\a a.
	*/
	double __negdf2(in double a);
	/**
	* Returns the integer part of \a a.
	*/
	int __fixdfsi(in double a);
	/**
	* Returns the unsigned integer part of \a a. Negative values become zero.
	*/
	uint __fixunsdfsi(in double a);
	/**
	* Returns the double representation of \a a.
	*/
	double __floatsidf(in int a);
	/**
	* Returns the double representation of \a a.
	*/
	double __extendsfdf2(in float a);
	/**
	* Returns \>0 if \a a \> \a b, 0 if \a a == \a b and \<0 if \a a \< \a b.
	* If either argument is Not a Number, the result is undefined.
	*/
	int dcmp(in double a, in double b);


	/**
	* Returns \a a + \a b.
	*/
	float __addsf3(in float a, in float b);
	/**
	* Returns \a a - \a b.
	*/
	float __subsf3(in float a, in float b);
	/**
	* Returns \a a * \a b.
	*/
	float __mulsf3(in float a, in float b);
	/**
	* Returns \a a / \a b.
	* If \a b == 0, a <a href="../panics.html">MoSync Panic</a> is thrown.
	*/
	float __divsf3(in float a, in float b);
	/**
	* Returns -\a a.
	*/
	float __negsf2(in float a);
	/**
	* Returns the integer part of \a a.
	*/
	int __fixsfsi(in float a);
	/**
	* Returns the unsigned integer part of \a a. Negative values become zero.
	*/
	uint __fixunssfsi(in float a);
	/**
	* Returns the float representation of \a a.
	*/
	float __floatsisf(in int a);
	/**
	* Returns the float representation of \a a.
	*/
	float __truncdfsf2(in double a);
	/**
	* Returns \>0 if \a a \> \a b, 0 if \a a == \a b and \<0 if \a a \< \a b.
	* If either argument is Not a Number, the result is undefined.
	*/
	int fcmp(in float a, in float b);

	/**
	* Returns the sine of \a x.
	* \param x An angle in radians.
	*/
	double sin(in double x);
	/**
	* Returns the cosine of \a x.
	* \param x An angle in radians.
	*/
	double cos(in double x);
	/**
	* Returns the tangent of \a x.
	* \param x An angle in radians.
	*/
	double tan(in double x);
	/**
	* Returns the square root of \a x.
	*/
	double sqrt(in double x);

	/**
	 * \brief A structure representing a two-dimensional point, with coordinates 'x' and 'y'.
	 */
	struct MAPoint2d {
		int x;
		int y;
	}

	/**
	 * \brief A structure representing a rectangle.
	 *
	 * The x and y coordinate of the top-left corner are defined by 'left' and 'top'.
	 * The dimensions of the rectangle are defined by 'width' and 'height'.
	 */
	struct MARect {
		int left;
		int top;
		int width;
		int height;
	}

	/**
	* Sets the color used by drawing functions. Returns previous color. Initial color is 0 (black).
	* \param rgb A color in RGB8 format (0xRRGGBB). The top byte is ignored.
	*/
	int maSetColor(in int rgb);

	/**
	* Sets the clipping rectangle for the current draw target.
	* The screen and every drawable image each maintains a clipping rectangle.
	* Drawing operations have no effect outside the clipping rectangle.
	* The default clipping rectangle covers the entire draw target, so that
	* clipping occurs at the draw target's edges.
	*/
	void maSetClipRect(in int left, in int top, in int width, in int height);

	/**
	* Returns the clipping rectangle for the current draw target.
	*/
	void maGetClipRect(out MARect out);

	/**
	* Draws a single pixel using the current color.
	* \see maSetColor()
	*/
	void maPlot(in int posX, in int posY);
	/**
	* Draws a line using the current color.
	* \see maSetColor()
	*/
	void maLine(in int startX, in int startY, in int endX, in int endY);
	/**
	* Draws a filled rectangle using the current color.
	* Width and height must be greater than zero.
	* \see maSetColor()
	*/
	void maFillRect(in int left, in int top, in int width, in int height);
	/**
	* Draws a filled triangle strip using the current color.
	* \param points A pointer to an array of \a count MAPoint2d:s representing the
	* vertices of the strip.
	* \param count The count of vertices in the strip. Must be at least 3.
	* \see maSetColor()
	*/
	void maFillTriangleStrip(in MAPoint2d points, in int count);
	/**
	* Draws a filled triangle fan using the current color.
	* \param points A pointer to an array of \a count MAPoint2d:s representing the
	* vertices of the fan.
	* \param count The count of vertices in the fan. Must be at least 3.
	* \see maSetColor()
	*/
	void maFillTriangleFan(in MAPoint2d points, in int count);

	/**
	* Returns the size in pixels of Latin-1 text as it would appear on-screen.
	*/
	MAExtent maGetTextSize(in MAString str);

	/**
	* Returns the size in pixels of Unicode text as it would appear on-screen.
	*/
	MAExtent maGetTextSizeW(in MAWString str);

	/**
	* Draws Latin-1 text using the current color.
	* The coordinates are the top-left corner of the text's bounding box.
	* \see maSetColor()
	*/
	void maDrawText(in int left, in int top, in MAString str);

	/**
	* Draws Unicode text using the current color.
	* The coordinates are the top-left corner of the text's bounding box.
	* \see maSetColor()
	*/
	void maDrawTextW(in int left, in int top, in MAWString str);

	/**
	* Copies the back buffer to the physical screen.
	*/
	void maUpdateScreen();

	/**
	* Normally, a phone's backlight turns itself off after
	* a few seconds of the user not pressing any keys.
	* To avoid this behaviour, call this function periodically.
	* As the timeout period is different for every device, and sometimes even user-configurable,
	* it's recommended that you call this function at least once every 500 milliseconds
	* to ensure that the light stays on at all times.
	*/
	void maResetBacklight();

	/**
	* Returns the screen size.
	* Returns the screen size.
	*/
	MAExtent maGetScrSize();

	/**
	* Draws an image.
	* It it placed on the draw target with the top left corner according to the parameters.
	*/
	void maDrawImage(in MAHandle image, in int left, in int top);

	/**
	* Draws an image.
	* The source is an array of ints that represent pixels in ARGB format.
	* \param dstPoint The top-left point on the draw target.
	* \param src The address to the source image.
	* \param srcRect The portion of the source image to be drawn.
	* \param scanlength The width, in pixels, of the image represented by the source array.
	*/
	void maDrawRGB(in MAPoint2d dstPoint, in MAAddress src, in MARect srcRect, in int scanlength);

	// The JavaMe runtime requires that these constans have these values. Do not change.
	constset int TRANS_ {
		/// The image is copied unchanged.
		NONE = 0;
		/// The image is rotated clockwise by 90 degrees.
		ROT90 = 5;
		/// The image is rotated clockwise by 180 degrees.
		ROT180 = 3;
		/// The image is rotated clockwise by 270 degrees.
		ROT270 = 6;
		/// The image is reflected about its vertical center.
		MIRROR = 2;
		/// The image is reflected about its vertical center, then rotated clockwise by 90 degrees.
		MIRROR_ROT90 = 7;
		/// The image is reflected about its vertical center, then rotated clockwise by 180 degrees.
		MIRROR_ROT180 = 1;
		/// The image is reflected about its vertical center, then rotated clockwise by 270 degrees.
		MIRROR_ROT270 = 4;
	}

	/**
	* Draws a portion of an image using a transformation.
	* \param image The source image.
	* \param srcRect The portion of the source image to be drawn.
	* Must not exceed the bounds of the source image.
	* \param dstPoint The top-left point on the draw target.
	* \param transformMode One of the \link #TRANS_NONE TRANS \endlink constants.
	* \see maDrawImage
	*/
	void maDrawImageRegion(in MAHandle image, in MARect srcRect, in MAPoint2d dstPoint,
		in int transformMode);

	/**
	* Returns the size of an image.
	*/
	MAExtent maGetImageSize(in MAHandle image);

	/**
	* Copies an image into an array of ints that represent pixels in little-endian ARGB format.
	* The destination rectangle is defined as { 0,0, \a srcRect.width, \a srcRect.height }.
	* Parts of the destination array that are outside the destination rectangle are not modified.
	* If \a srcRect is outside the bounds of the source image,
	* or if \a srcRect.width is greater than \a scanlength, a MoSync Panic is thrown.
	* \param image The handle to the source image.
	* \param dst The address of the destination array.
	* \param scanlength The width of the image, in pixels, represented by the destination array.
	* \param srcRect The portion of the source image to be copied.
	*/
	void maGetImageData(in MAHandle image, out MAAddress dst, in MARect srcRect, in int scanlength);

	/**
	* Sets the current draw target.
	* The handle must be a drawable image or #HANDLE_SCREEN, which represents the back buffer.
	* The initial draw target is the back buffer.
	* If an image is set as draw target, its object handle goes into flux, which prevents
	* its destruction or use as a source in maDrawImage. When a different draw target is set,
	* the image's handle is restored. Returns the the previously set draw target.
	* \see maCreateDrawableImage()
	*/
	//Graphics.copyArea could be used to allow an image to be drawn to itself.
	MAHandle maSetDrawTarget(in MAHandle image);

	constset int HANDLE_ {
		/// This handle refers to the back buffer, which is initially black.
		SCREEN = 0;

		LOCAL = 0;
	}

	/**
	 * Finds the label resource with the specified \a name and returns its index.
	 * If it is not found, -1 is returned.
	 */
	int maFindLabel(in MAString name);

	// TODO: Should we change RES_OK to be zero? Many
	constset int RES_ {
		OUT_OF_MEMORY = -1;
		BAD_INPUT = -2;
		OK = 1;
	}

	/**
	* Creates an image object using encoded data from a data object.
	* All platforms support the PNG format. Some platforms may also support JPEG and/or GIF.
	* \param placeholder The placeholder for the image object that is to be created.
	* \param data The data object that holds the encoded data.
	* \param offset The offset in the data object where the encoded data begins.
	* \param size The size in bytes of the encoded data.
	* \returns #RES_OK if succeded and #RES_OUT_OF_MEMORY or #RES_BAD_INPUT if failed.
	*/
	int maCreateImageFromData(in MAHandle placeholder, in MAHandle data, in int offset, in int size);

	/**
	* Creates an image object using raw ARGB data.
	* \param placeholder The placeholder for the image object that is to be created.
	* \param src Address of the raw data. 4 bytes per pixel, format 0xAARRGGBB.
	* \param size The size in pixels of the image, constructed using the EXTENT() macro.
	* \param alpha Non-zero if the resulting image should have an alpha channel, zero otherwise.
	* \returns #RES_OK if succeded and #RES_OUT_OF_MEMORY if failed.
	*/
	int maCreateImageRaw(in MAHandle placeholder, in MAAddress src, in MAExtent size, in int alpha);

	/**
	* Creates a drawable image of the specified size. A drawable image has no alpha channel,
	* which is to say, no transparency.
	* Its initial contents are undefined, so you should draw onto the entire surface to
	* be sure what will happen when you draw this image onto something else.
	* \param placeholder The resource handle of the new image.
	* \param width Width, in pixels, of the new image. Must be \> 0.
	* \param height Height, in pixels, of the new image. Must be \> 0.
	* \see maSetDrawTarget()
	* \returns #RES_OK if succeded and #RES_OUT_OF_MEMORY if failed.
	*/
	int maCreateDrawableImage(in MAHandle placeholder, in int width, in int height);

	/**
	* Creates a data object of the specified \a size, in bytes. Its initial contents are undefined.
	* \returns #RES_OK if succeded and #RES_OUT_OF_MEMORY if failed.
	*/
	int maCreateData(in MAHandle placeholder, in int size);

	/**
	*	Creates a new placeholder and returns the handle to it.
	*/
	MAHandle maCreatePlaceholder();

	/**
	* Releases a handle returned by maCreatePlaceholder().
	* If the handle refers to an object, such as an image or a data object,
	* that object is destroyed, as if maDestroyObject() had been called.
	*
	* The released handle may be reused by the system
	* and returned by future calls to maCreatePlaceholder(),
	* or by other system functions that allocate resources dynamically.
	*
	* This function is preferred to maDestroyObject(), unless you need
	* to reuse the handle.
	*
	* Attempting to destroy a handle that has already been released,
	* or was not returned by maCreatePlaceholder(), will cause a MoSync Panic.
	*
	* @param handle The handle to be released.
	*/
	void maDestroyPlaceholder(in MAHandle handle);

	/**
	* Destroys an object of any type. The handle becomes a placeholder.
	*/
	void maDestroyObject(in MAHandle handle);

	/**
	* Returns the size, in bytes, of a data object.
	*/
	int maGetDataSize(in MAHandle data);

	/**
	* Reads \a size bytes from a data object, starting at \a offset,
	* into memory pointed to by \a dst.
	* \warning Do not attempt to read zero bytes or out of bounds;
	* it is not supported and will result in a MoSync Panic.
	*/
	void maReadData(in MAHandle data, out MAAddress dst, in int offset, in int size);

	/**
	* Writes \a size bytes to a data object, starting at \a offset,
	* from memory pointed to by \a src.
	*/
	void maWriteData(in MAHandle data, in MAAddress src, in int offset, in int size);

	/**
	* \brief Parameters for the maCopyData() function.
	*/
	struct MACopyData {
		MAHandle dst;
		int dstOffset;
		MAHandle src;
		int srcOffset;
		int size;
	}

	/**
	* Copies \a size bytes from data object \a src to \a dst, at the specified offsets.
	*/
	void maCopyData(in MACopyData params);

	constset int MAS_ {
		CREATE_IF_NECESSARY = 1;
		//SHARED 2
		//SHARED_WRITE 4
	}

	constset int STERR_ {
		/// Generic error.
		GENERIC = -2;
		/// The storage medium is full.
		FULL = -3;
		/// The store does not exist.
		NONEXISTENT = -5;
	}

	/**
	* Opens a permanent data store, optionally creates one if it doesn't exist already.
	*
	* Returns a Store MAHandle on success.
	* Returns #STERR_NONEXISTENT if !(flags & #MAS_CREATE_IF_NECESSARY) and the store does not exist.
	* Returns another \link #STERR_GENERIC STERR \endlink code if the store could not be opened
	* for another reason.
	*
	* \param name The name of the store. A store name must have from 1 to 32 characters,
	* and must not contain any of the following characters: "/\\:;?*'
	* \param flags A combination of \link #MAS_CREATE_IF_NECESSARY MAS \endlink flags, or zero.
	*/
	MAHandle maOpenStore(in MAString name, in int flags);
	/**
	* Writes the contents of a data object to a store. Destroys any data previously in the store.
	* Returns \> 0 on success, #STERR_FULL if the storage system is full,
	* or another \link #STERR_GENERIC STERR \endlink code if the write failed for another reason.
	* \param store The store to write to.
	* \param data The data object to read from.
	*/
	int maWriteStore(in MAHandle store, in MAHandle data);
	/**
	* Creates a data object and copies the contents of a store to it.
	* Use maGetDataSize to get the size of the data.
	* \param store The store to read from.
	* \param placeholder The placeholder handle where a data object will be created.
	* \returns RES_OK if succeded and RES_OUT_OF_MEMORY if failed.
	*/
	int maReadStore(in MAHandle store, in MAHandle placeholder);
	/**
	* Closes a store. Also deletes that store if \a _delete is non-zero.
	*/
	void maCloseStore(in MAHandle store, in int _delete);

	constset int CONNERR_ {
		/// Generic error.
		GENERIC = -2;
		/// The maximum number of open connections allowed has been reached.
		MAX = -3;
		/// DNS resolution error.
		DNS = -4;
		/// Internal error. Please report any occurrences.
		INTERNAL = -5;

		/** \brief The connection was closed by the remote peer.
		*
		* Happens when HTTP servers finish sending data.
		*/
		CLOSED = -6;

		/// You attempted to write to a read-only connection.
		READONLY = -7;
		/// The OS does not trust you enough to let you open this connection.
		FORBIDDEN = -8;
		/// No operation has been started yet.
		UNINITIALIZED = -9;
		/// The Content-Length header could not be found.
		CONLEN = -10;
		/// You supplied a malformed URL.
		URL = -11;
		/// The protocol is not available.
		/// If a Bluetooth function returns this, the Bluetooth chip is turned off.
		UNAVAILABLE = -12;
		/// You canceled the operation.
		CANCELED = -13;
		/// The server gave an invalid response.
		PROTOCOL = -14;
		/// The network connection could not be established.
		NETWORK = -15;
		/// The requested header could not be found.
		NOHEADER = -16;
		/// The requested object could not be found.
		NOTFOUND = -17;
		/// An error occurred during SSL negotiation.
		SSL = -18;
		/// A download is already in progress.
		DOWNLOAD_IN_PROGRESS = -19;
		/// There is no active download.
		NO_ACTIVE_DOWNLOAD = -20;
		// Downloader has no available reader. This happens after the connection is closed.
		READER_UNAVAILABLE = -21;
		/// Redirection failed. This occurs when the server does not provide alternative url
		/// or if the maximum number of attempts to redirect was exceeded.
		REDIRECT = -22;
		/**
		* If you wish to share the CONNERR codespace,
		* use values below this for your own error codes.
		*/
		USER = -1000000;
	}
	constset int CONNOP_ {
		READ = 1;
		WRITE = 2;
		CONNECT = 7;	//READ | WRITE | 4
		FINISH = 11;	//READ | WRITE | 8
		ACCEPT = 16;
	}
	constset int CONN_ {
		/// The maximum number of open connections allowed.
		MAX = 32;
	}

	/**
	* Asynchronously opens a connection using the specified URL.
	* A URL takes the following form:
	* <tt>\<protocol\>://\<address\>[:\<port\>]\<parameters\></tt>\n
	* The following protocols are supported:
	*
	* <tt>socket</tt>, which is TCP. It has no parameters.
	*
	* <tt>datagram</tt>, which is UDP. It has no parameters.
	* Datagrams may arrive corrupted, out-of-order, duplicated, or not at all.
	*
	* <tt>ssl</tt>, which is an encrypted TCP connection. It has no parameters.
	*
	* <tt>http</tt>, which is HTTP/1.0 GET. When using HTTP, you need not specify the port;
	* it defaults to port 80.
	*
	* Its parameters is the document path (for example, "/index.html").
	* You must specify a path, or this function will fail with #CONNERR_URL.
	* The minimal path ("/") is acceptable.
	*
	* Writing to a http connection is not allowed.
	*
	* <tt>https</tt>, which is an encrypted HTTP GET. It has the same parameters as <tt>http</tt>.
	*
	* <tt>btspp</tt>, which is Bluetooth Serial Port. It has no parameters.
	*\n
	*\n
	* For the <tt>socket</tt> and <tt>http</tt> protocols, \a \<address\> can be either a decimal,
	* dot-delimited (.) IPv4 address or a standard Domain Name,
	* while \a \<port\> is a decimal number from 1 to 65535.
	*
	* In the <tt>socket</tt> protocol, certain ports are protected on certain platforms and
	* cannot be used, most notably port 80 on Java ME. In this case, use http instead.
	*
	* On a few devices, using ports numbered below 1024 may cause system crashes.
	* Therefore, it is advisable to use ports above 1024 if you can choose.
	*
	* On some J2ME devices, connections to port 443 (except from https) is not
	* allowed and might cause a system exception.
	*
	* For the <tt>btspp</tt> protocol, \a \<address\> is 12 hexadecimal digits and
	* \<port\> is a decimal number from 1 to 30.
	*
	* Example TCP url: <tt>socket://www.example.com:23</tt>
	*
	* Example UDP url: <tt>datagram://www.example.com:53</tt>
	*
	* Example SSL url: <tt>ssl://www.example.com:22</tt>
	*
	* Example HTTP url: <tt>http://www.example.com/directory/document.html</tt>
	*
	* Example HTTPS url: <tt>https://www.google.com</tt>
	*
	* Example Bluetooth url: <tt>btspp://001dbe15e455:9</tt>
	*
	* You can also use MAUtil::BluetoothConnection to connect via Bluetooth service uuid.
	*
	* To find useful Bluetooth addresses, use the Bluetooth discovery API.
	* See maBtStartDeviceDiscovery().
	*
	*
	* The result of the operation will be delivered in a CONN event, with
	* MAConnEventData::opType set to #CONNOP_CONNECT.
	*
	* The success value is \> 0. For the <tt>http</tt> protocol,
	* the success value is the HTTP response code.
	*
	*
	* When you're done with the connection, maConnClose() must be called to free
	* the resources associated with the handle. This must be done even if
	* the connect operation failed.
	*
	* There is a limit of #CONN_MAX open connection handles at any time, so if you keep
	* opening connections without closing them, you'll eventually receive the
	* #CONNERR_MAX error code instead of new connection handles.
	*
	*
	* Alternatively, this function can be called with one of these url types to
	* create a Server Connection:\n
	* <tt>socket://[:\<port\>]</tt>, for TCP.\n
	* <tt>btspp://localhost:\<uuid\>[;name=\<YourServiceName\>]</tt>, for Bluetooth.\n
	* \<uuid\> is a 32-digit hexadecimal number. It will be used to create the
	* service record. Its MAUUID representation can be used by clients to search for
	* this service.
	*
	* Example Bluetooth server url:
	* <tt>btspp://localhost:0000110100001000800000805F9B34FB;name=Serial Port</tt>
	*
	* Server connections are created synchronously; no CONN event is generated,
	* and as soon as this function returns, it's done.
	*
	* A server connection can not be read from or written to, but it can be closed.
	* You can also use it in calls to maAccept() and maConnGetAddr().
	*
	*
	* Alternatively, you can use this url type to create an unbound UDP connection:
	* <tt>datagram://[:\<port\>]</tt>\n
	*
	* Such connections must use maConnReadFrom() and maConnWriteTo().
	* None of the other Read or Write functions will work, because they require a binding to a remote socket.
	*
	* Like server connections, unbound UDP connections are created synchronously; no CONN event is generated.
	*
	*
	* \returns The connecting handle \>0, or one of the \link #CONNERR_GENERIC CONNERR \endlink values.
	* \see maGetEvent()
	* \see \ref connApiOverview
	*/
	MAHandle maConnect(in MAString url);

	/**
	* Closes a connection, freeing any resources associated with the handle.
	*
	* Cancels any active operations on the connection.
	* Such operations will finish with #CONNERR_CANCELED.
	*/
	void maConnClose(in MAHandle conn);

	/**
	* Asynchronously reads at least one and at most \a size bytes from a connection to memory.
	*
	* The result of the operation will be delivered in a CONN event, with
	* MAConnEventData::opType set to #CONNOP_READ.
	* The success value is the number of bytes read.
	*
	* Datagrams may be bigger than the receiving buffer. In that case,
	* \todo #CONNERR_MSGSIZE will be signaled, and the buffer is filled with
	* the first part of the datagram. The rest of the datagram is lost.
	*
	* \see maGetEvent
	* \see \ref connApiOverview
	*/
	void maConnRead(in MAHandle conn, out MAAddress dst, in int size);

	/**
	* Asynchronously writes \a size bytes to a connection from memory.
	*
	* The result of the operation will be delivered in a CONN event, with
	* MAConnEventData::opType set to #CONNOP_WRITE.
	* The success value is \> 0.
	*
	* \warning The source data must remain available until the operation is complete,
	* so if it was dynamically allocated, don't free it too early.
	* \see maGetEvent
	* \see \ref connApiOverview
	*/
	void maConnWrite(in MAHandle conn, in MAAddress src, in int size);

	/**
	* Asynchronously reads at least one and at most \a size bytes from a connection to
	* a data object, starting at the specified offset.
	* During the read, the data object being written to will be in flux.
	* Any attempt to access it will result in a Panic.
	*
	* The result of the operation will be delivered in a CONN event, with
	* MAConnEventData::opType set to #CONNOP_READ.
	* The success value is is the number of bytes read.
	*
	* \see maGetEvent
	* \see \ref connApiOverview
	*/
	void maConnReadToData(in MAHandle conn, in MAHandle data, in int offset, in int size);

	/**
	* Asynchronously writes \a size bytes to a connection from a data object,
	* starting at the specified offset.
	* During the write, the data object being read from will be in flux.
	* Any attempt to access it will result in a Panic.
	*
	* The result of the operation will be delivered in a CONN event, with
	* MAConnEventData::opType set to #CONNOP_WRITE.
	* The success value is \> 0.
	*
	* \see maGetEvent
	* \see \ref connApiOverview
	*/
	void maConnWriteFromData(in MAHandle conn, in MAHandle data, in int offset, in int size);

	/**
	* Like maConnRead(), except it only works for unbound datagram connections,
	* it can read messages from any sender,
	* and it will save the source address.
	*
	* \param src When the read operation completes, the address of the sender will be written here.
	* Therefore, the object being pointed to must remain valid for the duration of the operation.
	* Don't use a local variable.
	*
	* \see maConnRead
	*/
	void maConnReadFrom(in MAHandle conn, out MAAddress dst, in int size, out MAConnAddr src);

	/**
	* Like maConnWrite(), except it only works for unbound datagram connections,
	* and it can send messages to any address.
	*
	* \param dst The destination address of the datagram being sent.
	* The object being pointed to is NOT required to remain valid after this function returns.
	* You may use a local variable.
	*
	* \see maConnWrite
	*/
	void maConnWriteTo(in MAHandle conn, in MAAddress src, in int size, in MAConnAddr dst);

	/**
	* \brief An address for the protocols TCP or UDP over IPv4.
	*/
	struct MAConnAddrInet4 {
		int addr;
		int port;
	}

	/**
	* \brief An address for the protocols TCP or UDP over IPv6.
	*/
	struct MAConnAddrInet6 {
		int port;
		byte addr[16];
	}

	constset int BTADDR_ {
		LEN = 6;
	}

	/**
	* \brief A Bluetooth device address.
	*/
	struct MABtAddr {
		byte a[BTADDR_LEN];
	}


	/**
	* \brief An address for the Bluetooth Serial Port protocol.
	*/
	struct MAConnAddrBt {
		int port;
		MABtAddr addr;
	}

	constset int CONN_FAMILY_ {
		INET4 = 1;
		BT = 2;
		INET6 = 3;
	}

	/**
	* \brief A connection address.
	*/
	struct MAConnAddr {
		/// One of the CONN_FAMILY constants
		int family;
		union {
			MAConnAddrInet4 inet4;
			MAConnAddrBt bt;
			MAConnAddrInet6 inet6;
		}
	}

	/**
	* Retrieves the address of a connection. On server connections,
	* you'll get the local address. On normal connections, you'll get the remote address.
	*
	* You can pass #HANDLE_LOCAL to retrieve the local address.
	* In that case, you must set MAConnAddr::family before calling this function,
	* to tell it which address to retrieve. Also, the port member is not set.
	*
	* \returns \< 0 on error.
	*/
	int maConnGetAddr(in MAHandle conn, out MAConnAddr addr);

	constset int HTTP_ {
		GET = 1;
		POST = 2;
		HEAD = 3;
		PUT = 4;
		DELETE = 5;
	}

	/**
	* Creates an unfinished HTTP/1.0 connection. You cannot read from this connection
	* until it's been Finished. Before then, you can set request headers. After,
	* you can get response headers.

	* POST connections are special; they let you write to the connection before
	* it's Finished. The first write causes the underlying TCP connection to be
	* established and request headers transmitted. After the first write has
	* begun, you may no longer set request headers.

	* \param url An HTTP or HTTPS URL. See maConnect() for the exact form.
	* \param method #HTTP_GET, #HTTP_POST, #HTTP_HEAD, #HTTP_PUT or #HTTP_DELETE.
	* \returns An unfinished HTTP connection handle \>0, or a
	* \link #CONNERR_GENERIC CONNERR \endlink value.
	* \see maHttpFinish
	*/
	MAHandle maHttpCreate(in MAString url, in int method);

	/**
	* Sets a request header of an HTTP connection.
	*
	* Overwrites any existing header with the same key. The keys is case-insensitive.
	*
	* If the connection's method is #HTTP_POST, it must not have been written to.
	* \param conn An unfinished HTTP connection handle.
	* \param key The name of the header.
	* \param value The new value of the header.
	*/
	void maHttpSetRequestHeader(in MAHandle conn, in MAString key, in MAString value);

	/**
	* Stores an HTTP response header in the specified buffer.
	*
	* The buffer may be too small to contain the header and the terminating zero;
	* in that case, the buffer will not be filled
	* and you should create a bigger buffer and call this function again.
	* Use the return value to determine how long the buffer needs to be.
	*
	* \param conn A finished HTTP connection handle.
	* \param key The name of the header. Case-insensitive.
	* \param buffer A string buffer.
	* \param bufSize The size of the buffer, in bytes.
	* \returns The length of the header value, excluding the terminating zero, or
	* #CONNERR_NOHEADER if the header doesn't exist.
	*/
	int maHttpGetResponseHeader(in MAHandle conn, in MAString key,
		out MAString buffer range("bufSize"), in int bufSize);


	//not needed yet
	//int maHttpGetResponseMessage(in MAHandle conn, out MAString buffer, in int bufSize);
	//int maHttpGetRequestHeader(in MAHandle conn, in MAString key, out MAString buffer, in int bufSize);


	/**
	* Asynchronously finishes an HTTP connection. This entails making the
	* underlying TCP connection and sending request headers, unless that has
	* already been done by a #HTTP_POST write, and receiving the response headers.
	*
	* The result of the operation will be delivered in a CONN event, with
	* MAConnEventData::opType set to #CONNOP_FINISH.
	* The success value is the HTTP response code.
	*
	* \param conn An unfinished HTTP connection handle.
	* \see maGetEvent
	* \see \ref connApiOverview
	*/
	void maHttpFinish(in MAHandle conn);

	/**
	* Loads a new object array from the a data object. The old object array is overwritten,
	* except where the new array has SKIP objects. In those cases, the old objects are saved.
	* Returns zero on error, \>0 on success. On error, the old object array remains unchanged.
	* \param data The data object containing new resources, in the format of a MoSync
	* compiled resource file.
	* \note There must not be any UBIN objects in the new array,
	* except those of the old array that were SKIP'd.
	*/
	int maLoadResources(in MAHandle data);

	constset int MA_RESOURCE_ {
		OPEN = 0x1;
		CLOSE = 0x2;
	}
	/**
	* Loads a specific resource in the given placeholder.
	* \param handle The handle of the resource that needs to be loaded
	* \param placeholder The placeholder where to load the resource from handle.
	* \param flag One of the MA_RESOURCE_OPEN, MA_RESOURCE_CLOSE,
	* MA_RESOURCE_OPEN|MA_RESOURCE_CLOSE to control the resource binary.
	*/
	int maLoadResource(in MAHandle handle, in MAHandle placeholder, in int flag);

	/*
	* Returns the number of available resources.
	*/
	int maCountResources();

	/**
	* Loads a new program from the a data object, closes the running program, and starts the new one.
	* The format of the data object is a MoSync program file concatenated with a resource file.
	* If this function returns, there was an error.
	*
	* \param data The data object containing the new program.
	* \param reload If non-zero, the original program will be reloaded after the new program has
	* exited. If zero, MoSync will exit when the loaded program exists, unless that program,
	* or one of its sub-programs, calls this function with \a reload set to non-zero.
	*
	* \note A program that was loaded with this function cannot be reloaded; instead, it will
	* always be the very first program in the chain that is reloaded.
	* \note The stored reload flag is or'd with the one provided to each call to this function.
	* It is also reset when the reload occurs.
	* \note Thus, if one program loads another with reload on, and the loaded program loads another
	* with reload off, the original program will still be reloaded when the last one exits.
	* Should the original program decide to exit after being reloaded, it will not be reloaded again.
	*
	* \note The \link #EVENT_TYPE_CLOSE close event \endlink will disable the reload mechanism.
	*/
	void maLoadProgram(in MAHandle data, in int reload);

	constset int MAK_ {	//MobileAuthor Keys

		// start of ascii mapped key codes

		UNKNOWN			= 0;
		FIRST			= 0;
		BACKSPACE		= 8;
		TAB				= 9;
		CLEAR			= 12;
		RETURN			= 13;
		PAUSE			= 19;
		ESCAPE			= 27;
		SPACE			= 32;
		EXCLAIM			= 33;
		QUOTEDBL		= 34;
		POUND			= 35;
		HASH			= 35;
		GRID			= 35;
		DOLLAR			= 36;
		AMPERSAND		= 38;
		QUOTE			= 39;
		LEFTPAREN		= 40;
		RIGHTPAREN		= 41;
		ASTERISK		= 42;
		STAR			= 42;
		PLUS			= 43;
		COMMA			= 44;
		MINUS			= 45;
		PERIOD			= 46;
		SLASH			= 47;

		//Warning: do not disrupt the sequence of number keys!
		0				= 48;
		1				= 49;
		2				= 50;
		3				= 51;
		4				= 52;
		5				= 53;
		6				= 54;
		7				= 55;
		8				= 56;
		9				= 57;

		COLON			= 58;
		SEMICOLON		= 59;
		LESS			= 60;
		EQUALS			= 61;
		GREATER			= 62;
		QUESTION		= 63;
		AT				= 64;

		LEFTBRACKET		= 91;
		BACKSLASH		= 92;
		RIGHTBRACKET	= 93;
		CARET			= 94;
		UNDERSCORE		= 95;
		BACKQUOTE		= 96;

		// lower case ascii codes

		A				= 97;
		B				= 98;
		C				= 99;
		D				= 100;
		E				= 101;
		F				= 102;
		G				= 103;
		H				= 104;
		I				= 105;
		J				= 106;
		K				= 107;
		L				= 108;
		M				= 109;
		N				= 110;
		O				= 111;
		P				= 112;
		Q				= 113;
		R				= 114;
		S				= 115;
		T				= 116;
		U				= 117;
		V				= 118;
		W				= 119;
		X				= 120;
		Y				= 121;
		Z				= 122;

		// eof lower case ascii codes

		DELETE			= 127;

		// eof ascii mapped key codes

		// Numeric keypad
		//Warning: do not disrupt the sequence of number keys!
		KP0				= 256;
		KP1				= 257;
		KP2				= 258;
		KP3				= 259;
		KP4				= 260;
		KP5				= 261;
		KP6				= 262;
		KP7				= 263;
		KP8				= 264;
		KP9				= 265;

		KP_PERIOD		= 266;
		KP_DIVIDE		= 267;
		KP_MULTIPLY		= 268;
		KP_MINUS		= 269;
		KP_PLUS			= 270;
		KP_ENTER		= 271;
		KP_EQUALS		= 272;

		UP				= 273;
		DOWN			= 274;
		RIGHT			= 275;
		LEFT			= 276;
		INSERT			= 277;
		HOME			= 278;
		END				= 279;
		PAGEUP			= 280;
		PAGEDOWN		= 281;

		FIRE			= 284;
		SOFTLEFT		= 285;
		SOFTRIGHT		= 286;

		PEN				= 291;
		BACK = 292;
		MENU = 293;

		RSHIFT			= 303;
		LSHIFT			= 304;
		RCTRL			= 305;
		LCTRL			= 306;
		RALT			= 307;
		LALT			= 308;

		SEARCH			 = 309;
	}

	constset int MAKB_ { // Key Bits
		LEFT		= 0x00001;
		UP			= 0x00002;
		RIGHT		= 0x00004;
		DOWN		= 0x00008;
		FIRE		= 0x00010;
		SOFTLEFT	= 0x00020;
		SOFTRIGHT	= 0x00040;

		//Warning: do not disrupt the sequence of number keys!
		0			= 0x00080;
		1			= 0x00100;
		2			= 0x00200;
		3			= 0x00400;
		4			= 0x00800;
		5			= 0x01000;
		6			= 0x02000;
		7			= 0x04000;
		8			= 0x08000;
		9			= 0x10000;

		ASTERISK	= 0x20000;
		STAR		= 0x20000;
		HASH		= 0x40000;
		POUND		= 0x40000;
		GRID		= 0x40000;
		CLEAR		= 0x80000;
	}

	/**
	* Returns a bitmask consisting of \link #MAKB_LEFT MAKB \endlink flags describing the current
	* key state.
	*/
	int maGetKeys();

	constset int EVENT_ {
		BUFFER_SIZE = 256;
		/// In milliseconds
		CLOSE_TIMEOUT = 2000;
	}
	constset int EVENT_TYPE_ {
		/**
		* This event is posted when the operating system sends MoSync a command to exit.
		* Causes include the OS shutting down and OS-controlled user commands.
		* \see maGetEvent()
		*/
		CLOSE = 1;

		KEY_PRESSED = 2;
		KEY_RELEASED = 3;
		/// Connection
		CONN = 4;
		/// Bluetooth discovery
		BT = 5;
#if IX_GUIDO
		/// Has MAEvent::ked::key be the identifier for the TTS session, as returned by maStartSpeaking().
		TTS = 6;
#endif	//IX_GUIDO
#if IX_WLAN
		/// Uses MAEvent::state.
		WLAN = 7;
#endif	//IX_WLAN

		POINTER_PRESSED = 8;
		POINTER_RELEASED = 9;
		POINTER_DRAGGED = 10;

#if IX_CALL
		/// Has MAEvent::state be one of the \link #CALLSTATE_UNKNOWN CALLSTATE \endlink constants.
		CALL = 11;
#endif	//IX_CALL

		/**
		 * While MoSync doesn't have focus, no key events will arrive and the screen will not be updated.
		 * If the keypad is locked, no application will have focus.
		 * \see maLockKeypad
		 */
		FOCUS_LOST = 13;
		FOCUS_GAINED = 14;

#if IX_STREAMING
		/**
		* Has MAEvent::data point to a MAStreamEventData.
		*/
		STREAM = 15;
#endif	//IX_STREAMING
//#if IX_LOCATION
		/// Has MAEvent::data point to an MALocation.
		LOCATION = 16;

		/// MAEvent::state is one of the \link #MA_LPS_AVAILABLE MA_LPS \endlink constants.
		LOCATION_PROVIDER = 17;
//#endif	//IX_LOCATION
#if IX_AUDIOBUFFER
		/// MAEvent::state is \> 0 when the audio stream is waiting for more data,
		/// or \< 0 on error.
		AUDIOBUFFER_FILL = 18;
#endif
		/**
		* \brief Event which is triggered when an audio has been asychronous prepared
		* The MAEvent::audioInstance contains the prepared MAAudioInstance,
		* or <0 if a problem happened while preparing.
		*/
		AUDIO_PREPARED = 19;

		/**
		* \brief Event which is triggered when a streaming audio has finished playing
		* The MAEvent::audioInstance contains the MAAudioInstance which finished
		*/
		AUDIO_COMPLETED = 20;

		/** \brief The size of the screen has changed.
		* Use maGetScrSize() to get the new size.
		*
		* If the screen is the current draw target, the clipping rectangle is removed.
		* Use maSetClipRect() to reset it.
		*/
		SCREEN_CHANGED = 21;

		/// Character input. Uses MAEvent::character.
		CHAR = 22;

		/** \brief The text box created by maTextBox() was just closed.
		* Uses MAEvent::textboxResult and MAEvent::textboxLength.
		*/
		TEXTBOX = 23;

		/** \brief The home screen became visible.
		 * Currently implemented only on Android and Symbian.
		 * \see maHomeScreenEventsOn()
		 */
		HOMESCREEN_SHOWN = 24;

		/** \brief The home screen was hidden because an
		 * application came to front.
		 * Currently implemented only on Android and Symbian.
		 * \see maHomeScreenEventsOn()
		 */
		HOMESCREEN_HIDDEN = 25;

		/** \brief The screen was turned on (the device
		 * went out of sleep state).
		 * Currently implemented only on Android.
		 * \see maScreenActivateEventsOn()
		 */
		SCREEN_STATE_ON = 26;

		/** \brief The screen was turned off (the device
		 * went into sleep state).
		 * Currently implemented only on Android.
		 * \see maScreenActivateEventsOn()
		 */
		SCREEN_STATE_OFF = 27;

		/**
		* \brief An event sent from a native widget.
		* \par The application can use the MAEvent.data field to access
		* widget event data, which is of type MAWidgetEventData.
		* For example: \n
		* \code MAWidgetEventData* widgetEventData = (MAWidgetEventData*) event.data; \endcode
		* \see MAWidgetEventData
		*/
		WIDGET = 28;

		/** \brief The bluetooth chip was turned off.
		* Bluetooth functions will return #CONNERR_UNAVAILABLE.
		* Currently implemented only on Android.
		*/
		BLUETOOTH_TURNED_OFF = 29;

		/** \brief The bluetooth chip was turned on.
		* Bluetooth functions will now work normally again.
		* Currently implemented only on Android.
		*/
		BLUETOOTH_TURNED_ON = 30;

		/**
		* \brief The ImagePicker dialog was dismissed either by Cancel, either by OK.
		*/
		IMAGE_PICKER = 31;

		/** \brief SMS result message.
		* The field status contains one of the
		* This event is sent on Android and iOS.
		*/
		SMS = 32;

		/**
		* \brief Provides data from active sensors.
		* \see MAEvent::sensor
		* \see maSensorStart()
		*/
		SENSOR = 33;

		/**
		* \brief The maAlert message box was dismissed by one of the available buttons.
		* See #EVENT_TYPE_ALERT for the event.
		*/
		ALERT = 34;

		/** \brief A new NFC tag was received
		* A new tag has been received, use maGetNextTag to
		* retreive it.
		*/
		NFC_TAG_RECEIVED = 35;

		/** \brief New tag data was read
		* An asynchronous NFC tag read operation was
		* completed.
		*/
		NFC_TAG_DATA_READ = 36;

		/** \brief New tag data was written
		* An asynchronous NFC tag write operation was
		* completed.
		*/
		NFC_TAG_DATA_WRITTEN = 37;

		/** \brief A batch operation was performed
		*/
		NFC_BATCH_OP = 38;

		/** \brief Tag authentication was performed
		* An asynchronous NFC tag authentication read was
		* completed.
		*/
		NFC_TAG_AUTH_COMPLETE = 39;

		/**
		* \brief Tag was made read only
		*  An asynchronous NFC tag read only operation was completed.
		*/
		NFC_TAG_READ_ONLY = 40;

		/**
		* Send by maOptionsBox dialog when one of the option buttons is clicked.
		*/
		OPTIONS_BOX_BUTTON_CLICKED = 41;

		/**
		* \brief Send by a banner ad.
		*/
		ADS_BANNER = 42;

		/**
		* \brief Send when the application receives a local notification.
		*/
		LOCAL_NOTIFICATION = 43;

		/**
		* \brief Send when the application receives a registration result.
		* The application tries to register to Apple Push Service, or Google GCM/C2DM Service,
		* and the received result ( either success, either fail) is sending this event.
		* After this event is received, get the result of the registration request by
		* calling maNotificationPushGetRegistration.
		*/
		PUSH_NOTIFICATION_REGISTRATION = 44;

		/**
		* \brief Send when the application receives an unregistration result.
		* The application unregistered from Google GCM/C2DM Service, and will not
		* receive anymore push messages.
		* Platform: Android only.
		*/
		PUSH_NOTIFICATION_UNREGISTRATION = 45;

		/**
		* \brief Send when the application receives a push notification.
		*/
		PUSH_NOTIFICATION = 46;

		/**
		* \brief Send before the Native Image Picker is dismissed.
		* This event will contain a MACaptureEventData struct.
		*/
		CAPTURE = 47;

		/**
		* \brief Send by the Purchase API.
		* This event will contain a MAPurchaseEventData struct.
		*/
		PURCHASE = 48;

		/**
		* \brief A camera event fired when you get any of the camera preview events
		*/
		CAMERA_PREVIEW = 49;

		/** \brief The telephone network status changed.
		* MAEvent::state is the new state,
		* one of the \link #MA_NETWORK_UNKNOWN MA_NETWORK \endlink constants.
		*/
		NETWORK = 50;

		/**
		* \brief Sent when the current screen orientation has changed.
		* MAEvent::orientation is the new screen orientation. One of the constants
		* \link #MA_SCREEN_ORIENTATION_PORTRAIT MA_SCREEN_ORIENTATION \endlink.
		*/
		ORIENTATION_DID_CHANGE = 51;

		/**
		* \brief Sent just before the current screen orientation starts changing.
		* Platform: iOS only.
		*/
		ORIENTATION_WILL_CHANGE = 52;

		/**
		* \brief Used to notify when the snapshot taken via #maCameraSnapshotAsync,
		* is completed.
		* The events of this type contain the handler for the image data,
		* the image size, the \link #MA_IMAGE_REPRESENTATION_UNKNOWN data representation \endlink
		* and a return code.
		*/
		CAMERA_SNAPSHOT = 53;

		/**
		* \brief Send by maAlert dialog being canceled by user dimissing it.
		*/
		ALERT_DISMISSED = 54;

		/**
		* \brief Used to notify when an operation of exporting files, from the
		* application to the device storages, reached the finish point.
		*/
		MEDIA_EXPORT_FINISHED = 55;
	}

	/**
	* \brief Data for a connection event, including an indicator or success or failure.
	*/
	struct MAConnEventData {
		/// The handle to the connection associated with the event.
		MAHandle handle;
		/// One of the \link #CONNOP_READ CONNOP \endlink constants.
		int opType;
		/// A success value \> 0 or a \link #CONNERR_GENERIC CONNERR \endlink code.
		int result;
	}

	/**
	* \brief A structure containing the sensor type and the data sent to the event.
	*/
	struct MASensor {
		int type;
		float values[3];
	}

	/**
	* \brief An event containing the result of an NFC asynchronous operation
	*/
	struct MANFCEventData {
		/// The handle this event pertains to.
		MAHandle handle;
		/// The result of the asynchronous operation, usually a length if >= 0,
		/// or an error code of < 0.
		int result;
		/// The destination of any read or write operation. Could be a memory
		/// address, a block number, or some other value depending on the operation.
		int dstId;
	}

	/**
	* \brief An event send by a banner widget.
	*/
	struct MAAdsEventData {
		/// Banner's handle that send the event.
		MAHandle bannerHandle;
		/// One of the \link #MA_ADS_EVENT_FAILED MA_ADS_EVENT \endlink constants.
		int bannerEventType;
		/// If bannerEventType is #\link #MA_ADS_EVENT_FAILED MA_ADS_EVENT_FAILED \endlink
		/// this variable will contain the error code.
		/// One of the \link #MA_ADS_ERROR_INTERNAL MA_ADS_ERROR \endlink constants.
		int bannerErrorCode;
	}

	/**
	* \brief An event send by the Native Image Picker(Capture API).
	*/
	struct MACaptureEventData {
		/// One of the \link #MA_CAPTURE_EVENT_TYPE_IMAGE MA_CAPTURE_EVENT_TYPE \endlink constants.
		int type;
		/// Handle to a video/image data object.
		/// This value is set only if the event type is MA_CAPTURE_EVENT_TYPE_IMAGE or MA_CAPTURE_EVENT_TYPE_VIDEO.
		MAHandle handle;
	}

	/**
	* \brief An puchase event struct.
	* A MoSync event will contain an struct object of this type only if event type
	* is #EVENT_TYPE_PURCHASE.
	*/
	struct MAPurchaseEventData {
		/**
		* \brief Type of the purchase event.
		* One of the \link MA_PURCHASE_EVENT_REQUEST MA_PURCHASE_EVENT \endlink constants.
		*/
		int type;

		/**
		* \brief State of the purchase.
		* One of the \link MA_PURCHASE_STATE_FAILED MA_PURCHASE_STATE \endlink constants.
		*/
		int state;

		/**
		* \brief Handle to the product that sent the event.
		*/
		MAHandle productHandle;

		/**
		* \brief Reason why the puchase failed.
		* Valid only if the state is #MA_PURCHASE_STATE_FAILED, #MA_PURCHASE_STATE_RECEIPT_INVALID,
		* #MA_PURCHASE_STATE_RECEIPT_ERROR or #MA_PURCHASE_STATE_RESTORE_ERROR.
		* One of the \link MA_PURCHASE_ERROR_INVALID_HANDLE MA_PURCHASE_ERROR \endlink constants.
		*/
		int errorCode;
	}

	/**
	* \brief An event; a message indicating that something has happened, e.g. that a key has been pressed.
	*/
	struct MAEvent {
		/**
		* One of the \link #EVENT_TYPE_CLOSE EVENT_TYPE \endlink constants.
		*/
		int type;
		union {
			struct {
				/**
				* In KEY events, this will be one of the \link #MAK_UNKNOWN MAK \endlink constants.
				*/
				int key;
				/**
				* In KEY events, this will be the native keycode.
				*/
				int nativeKey;
			} ked;

			/**
			* In CHAR events, this is the Unicode character that was received.
			*/
			uint character;

			struct {
				/**
				* In POINTER events, this will be the location of the pointer.
				*/
				MAPoint2d point;

				/**
				* In POINTER events, this will be the finger triggering the event.
				*/
				int touchId;
			} pointer;

			/**
			* In \link #EVENT_TYPE_BT BT \endlink events, this will be a value \>= 0 or
			* one of the \link #CONNERR_GENERIC CONNERR \endlink constants.
			*/
			int state;

			/**
			* Valid only in CONN events.
			*/
			MAConnEventData conn;

			struct {
				/**
				* One of the \link #MA_TB_RES_OK MA_TB_RES \endlink codes.
				*/
				int textboxResult;
				/**
				* The length, in characters, of the finished text.
				* Does not include the terminating zero.
				*/
				int textboxLength;
			} textbox;

			struct {
				/**
				 * #EVENT_TYPE_IMAGE_PICKER events, this will be 0 if canceled or 1 if Ok was pressed.
				 */
				int imagePickerState;

				/**
				* #EVENT_TYPE_IMAGE_PICKER event, contains the new handle to the selected image if the image picker
				* event return type was set to @link #MA_IMAGE_PICKER_ITEM_EVENT_RETURN_TYPE_IMAGE_HANDLE @endlink
				* (default value) or the handle to the binary image data if the return type was set to
				* @link #MA_IMAGE_PICKER_ITEM_EVENT_RETURN_TYPE_IMAGE_DATA @endlink.
				* Note: Android VM has some limitations when it comes to creating high resolution images. Therefore, if
				* the user needs to handle the image itself locally and maCreateImageFromData(dataHandle) returns a
				* RES_OUT_OF_MEMORY, use #MA_IMAGE_PICKER_ITEM_EVENT_RETURN_TYPE_IMAGE_HANDLE instead.
				*/
				MAHandle imagePickerItem;

				/**
				* The encoding used for the image. One of the values
				* @link #MA_IMAGE_PICKER_ITEM_ENCODING_PNG MA_IMAGE_PICKER_ITEM_ENCODING_* @endlink
				*/
				int imagePickerEncodingType;
			} imagePicker;

			struct {
				/**
				 * Used in #EVENT_TYPE_CAMERA_SNAPSHOT events.
				 * Holds the place holder for the data object representing the camera snapshot.
				 */
				MAHandle snapshotImageDataHandle;

				/**
				 * Used in #EVENT_TYPE_CAMERA_SNAPSHOT events.
				 * Holds the snapshot size.
				 */
				int snapshotSize;

				/**
				 * Used in #EVENT_TYPE_CAMERA_SNAPSHOT events.
				 * Holds the snapshot data representation.
				 * Possible values are found \link #MA_IMAGE_REPRESENTATION_UNKNOWN here \endlink.
				 */
				int snapshotImageDataRepresentation;

				/**
				 * Used in #EVENT_TYPE_CAMERA_SNAPSHOT events.
				 * Holds the return code of the camera snapshot operation.
				 * It #MA_CAMERA_RES_OK on success, or #MA_CAMERA_RES_FAILED on error
				 */
				int snapshotReturnCode;
			} cameraSnapshot;

			struct {
				/**
				 * Used in #EVENT_TYPE_MEDIA_EXPORT_FINISHED.
				 *
				 * Reprezents the media type.
				 * It can have a value from this set #MA_MEDIA_TYPE_UNKNOWN
				 */
				int mediaType;

				/**
				 * Used in #EVENT_TYPE_MEDIA_EXPORT_FINISHED.
				 *
				 * Reprezents the media handle.
				 */
				MAHandle mediaHandle;

				/**
				 * Used in #EVENT_TYPE_MEDIA_EXPORT_FINISHED.
				 *
				 * The result code of the operation. The possible values belong
				 * to this set #MA_MEDIA_RES_OK
				 */
				int operationResultCode;
			} mediaExportOperation;

			/**
			* #EVENT_TYPE_OPTIONS_BOX_BUTTON_CLICKED event, contains the index of the selected option.
			*/
			int optionsBoxButtonIndex;

			/**
			* #EVENT_TYPE_ALERT event. The index of the selected button.
			* If button1 is pressed, the value is 1.
			* If button2 is pressed, the value is 2.
			* If button3 is pressed, the value is 3.
			*/
			int alertButtonIndex;

			/**
			* In #EVENT_TYPE_SMS events, this will be one of the
			* @link #MA_SMS_RESULT_SENT MA_SMS_RESULT_* @endlink constants.
			*/
			int status;

			/**
			* Valid in \link #EVENT_TYPE_SENSOR SENSOR \endlink events.
			*/
			MASensor sensor;

			/**
			* NFC event data
			*/
			MANFCEventData nfc;

			/**
			* Ads event data.
			*/
			MAAdsEventData adsData;

			/**
			* Local notification's handle that send the event.
			* Valid only if the event type is \link #EVENT_TYPE_LOCAL_NOTIFICATION LOCAL_NOTIFICATION \endlink.
			*/
			MAHandle localNotificationHandle;

			/**
			* Push notification's handle that send the event.
			* Valid only if the event type is \link #EVENT_TYPE_PUSH_NOTIFICATION PUSH_NOTIFICATION \endlink.
			*/
			MAHandle pushNotificationHandle;

			/**
			* Store the result for a capture action.
			* Valid only if the event type is \link #EVENT_TYPE_CAPTURE CAPTURE \endlink.
			*/
			MACaptureEventData captureData;

			/**
			* Used by custom events. See invididual event descriptions.
			*/
			void* data;

			/**
			* Contains the prepared audio instance.
			* Valid only if the event type is \link #EVENT_TYPE_AUDIO_PREPARED AUDIO_PREPARED \endlink
			* or \link #EVENT_TYPE_AUDIO_COMPLETED AUDIO_COMPLETED \endlink.
			*/
			MAAudioInstance audioInstance;

			/**
			* Contains purchase related data.
			* Valid only if the event type is \link #EVENT_TYPE_PURCHASE PURCHASE \endlink.
			*/
			MAPurchaseEventData purchaseData;

			/**
			* Contains the new orientation when a #EVENT_TYPE_ORIENTATION_DID_CHANGE event is sent.
			*/
			int orientation;
			}
	}

	/**
	* There is a FIFO buffer that contains up to #EVENT_BUFFER_SIZE events.
	* Each event has a type. Some types have additional data.
	*
	* This function retrieves the next event, unless the queue is empty.
	* Use maWait() to wait until more events are available.
	* \param event Pointer to an MAEvent struct that will be filled with the next event.
	*
	* When the \link #EVENT_TYPE_CLOSE Close event \endlink is posted,
	* you must call maExit as soon as possible, or
	* your program will be forcibly terminated. The timeout is device-dependent, but
	* never longer than #EVENT_CLOSE_TIMEOUT milliseconds.
	*
	* After the Close event has been posted, most syscalls will stop working,
	* returning default values and doing nothing.
	* Only the following groups of functions are guaranteed to remain operational:
	* Memory management, math, Resource management, Store, time, logging, maExit() and maPanic().
	*
	* \note Not all platforms have the capability to generate a Close event.
	* You must always provide another way for the user to exit your application.
	*
	* \returns \> 0 on success, or zero if the buffer is empty.
	*/
	int maGetEvent(out MAEvent event);

	/**
	* Suspends execution until there is an event in the buffer,
	* or \a timeout milliseconds have passed. A timeout <= 0 is considered infinite.
	* Timer accuracy is platform-specific, but should be better than 20 ms.
	*
	* Use this function rather than idle loops to save CPU/battery power.
	* \see maGetEvent()
	*/
	void maWait(in int timeout);

	/**
	* Returns the number of seconds that have passed since
	* 00:00:00, Jan 1st, 1970, UTC, according to the device clock.
	*/
	int maTime();
	/**
	* Returns the number of seconds that have passed since
	* 00:00:00, Jan 1st, 1970, local time, according to the device clock.
	*/
	int maLocalTime();
	/**
	* Returns the number of milliseconds that has passed since some unknown point in time.
	* Accuracy is platform-specific, but should be better than 20 ms.
	*/
	int maGetMilliSecondCount();

	/**
	* Returns an approximation to the amount of memory currently available for
	* allocating new objects, measured in bytes.
	*
	* There may be more memory available than reported by this function. Conversely,
	* in the time between calling this function and allocating an object, another program
	* may have allocated an object of its own, decreasing the available memory.
	*
	* The amount of memory required to allocate any specific object is device-dependent.
	*
	* When using this function to determine whether or not to allocate an object, always
	* leave some memory alone for use by the system,
	* preferably about 10% of the device's total memory, as reported by maTotalObjectMemory().
	*/
	int maFreeObjectMemory();

	/**
	* Returns the total amount of memory available to MoSync, measured in bytes.
	* May change over time, even as the program is running.
	*/
	int maTotalObjectMemory();

	/**
	* Switches on the vibrator for the requested number of milliseconds,
	* or switches it off if the requested duration is zero.
	* A call to this function will override the previous call.
	* Returns non-zero if the operation was allowed, zero if it wasn't.\n
	* \n
	* On devices which has no vibrator, this function will always return zero.
	* The user may turn vibration off in phone settings. In that case, calling this function
	* with a duration of zero may return non-zero, but a non-zero duration will return zero.
	* In any case, the only way to conclusively determine if vibration is currently supported
	* or not is to call this function with a duration of at least 1(one) ms.
	* On iPhone the argument won't be taken into account.
	*/
	int maVibrate(in int ms);

	constset int RUNTIME_ {
		/// The MoSync Reference Environment, also known as the Emulator.
		MORE = 1;
		/// Java ME
		JAVA = 2;
		/// Symbian
		SYMBIAN = 3;
		/// Windows CE, also known as Windows Mobile.
		WINCE = 4;
	}

	constset int REPORT_ {
		/// Caused by a MoSync Panic. MAPanicReport::code is the panic code.
		PANIC = 1;
		/// Caused by a native exception. MAPanicReport::string describes the exception.
		EXCEPTION = 2;
		/// Caused by a platform-specific error. MAPanicReport::code is valid.
		PLATFORM_CODE = 3;
		/// Caused by a call to maPanic(). MAPanicReport::code and MAPanicReport::string are the
		/// parameters from the call.
		USER_PANIC = 4;
		/// Caused by the Close event timeout. Neither code or string are valid.
		TIMEOUT = 5;
	}

	/**
	* \brief A MoSync Panic or other unrecoverable error.
	*
	* In MoSync Debug builds, when such an error occurs, the runtime writes
	* an instance of this structure to a Store named "panic.report".
	*
	* The length of that instance may be greater than sizeof(MAPanicReport),
	* because of the variable-length string that may appear at its end.
	* The member \a string can, then, be longer than the one byte that is declared.
	*
	* To properly read an instance of this struct from a store, you should allocate a
	* chunk of memory whose size is equal to the size of the store, then read the entire store
	* into that chunk of memory. Then you should make a pointer of type MAPanicReport and point it
	* to the chunk. Then you can read normally, using that pointer.
	*
	* \see maOpenStore()
	* \see maPanic()
	* \see malloc()
	*/
	struct MAPanicReport {
		/// The type of MoSync runtime that wrote the report. A \link #RUNTIME_MORE RUNTIME \endlink constant.
		int runtimeId;
		/**
		* The type report. Specifies whether the members \a code and \a string are valid.
		* A \link #REPORT_PANIC REPORT \endlink constant.
		*/
		int reportType;
		/// The time the report was generated. The format is unix time. \see maTime()
		int time;
		/**
		* The value of the MoSync instruction pointer at the time the report was generated.
		* \< 0 if the MoSync core was inaccessible.
		*/
		int ip;

		int code;
		char string[1];
	}

	/**
	* Starts playing a sound.
	*
	* If a sound was already playing, it is stopped.
	*
	* The sound data is formatted as follows: \<mime type\>\<null terminator byte\>\<encoded data\>.
	*
	* The .media directive in the MoSync resource compiler creates this formatting.
	*
	* If you download or generate sound clips dynamically, you'll have to take care
	* of the formatting yourself, or use a library that does it for you,
	* for example MAUtil::AudioDownloader.
	*
	* To play .media resources, use offset 0 and maGetDataSize().
	*
	* Do not touch the resource while it's playing, or there will be... trouble.
	*
	* \returns \>= 0 on success and \< 0 on failure.
	*
	* \param sound_res The data object in which the sound is stored.
	* \param offset The offset in the data object where the mime type and sound data is stored.
	* \param size The size of mime type string and sound data.
	*/
	//TODO: make the sound resource go into flux while playing.
	int maSoundPlay(in MAHandle sound_res, in int offset, in int size);

	/**
	* Stops any sound started with maSoundPlay().
	*/
	void maSoundStop();

	/**
	* Returns \> 0 if sound is playing, zero if it's not.
	*/
	int maSoundIsPlaying();

	/**
	* Returns the volume, in the range 0-100, used by the sound engine.
	* The initial volume is 100.
	*/
	int maSoundGetVolume();

	/**
	* Sets the volume, which is a value in the range 0-100. All other values will be clamped
	* to the allowed range.
	*/
	void maSoundSetVolume(in int vol);

	typedef int MAExtensionModule;
	typedef int MAExtensionFunction;

	constset int MA_EXTENSION_ {
		MODULE_UNAVAILABLE = -1;
		FUNCTION_UNAVAILABLE = -1;
	}

	/**
	* Invokes an extension function. Normally you don't call this function directly.
	*/
	ioctl maExtensionFunctionInvoke {}

	/**
	* These functions are available only on certain platforms.
	* Returns -1 if the function is not available.
	*/
	ioctl maIOCtl {

	/**
	* Loads an extension module. Normally you don't call this function directly.
	*/
	MAExtensionModule maExtensionModuleLoad(in MAString id, in int hash);

	/**
	* Loads an extension function. Normally you don't call this function directly.
	*/
	MAExtensionFunction maExtensionFunctionLoad(in MAExtensionModule module, in int index);

	int maExtensionFunctionInvoke2(in MAExtensionFunction fn, in int numargs, in int ptrs);

#if IX_RESOURCE_TYPES
	constset int RT_ {  //WARNING: must match the resource compiler.
		PLACEHOLDER = 1;
		IMAGE = 2;
		SPRITE = 3;
		BINARY = 4;
		UBIN = 5;
		SKIP = 6;
		LABEL = 9;
		NIL = 10; // Placeholder that is not used.
		FLUX = 127;
	}

#endif	//IX_RESOURCE_TYPES

		constset int FONT_TYPE_{
			SERIF = 0;
			SANS_SERIF = 1;
			MONOSPACE = 2;
		}

		constset int FONT_STYLE_{
			NORMAL = 0;
			BOLD = 1;
			ITALIC = 2;
		}

		/**
		* The available result codes for fonts.
		*/
		constset int RES_FONT_{
			/**
			* \brief Indicates that the call to a font syscall was successful.
			*/
			OK = 1;

			/**
			* \brief Indicates that an invalid font handle was passed.
			*/
			INVALID_HANDLE = -1;

			/**
			* \brief Indicates that the index was off the list size.
			*/
			INDEX_OUT_OF_BOUNDS = -2;

			/**
			* \brief Indicates that a default font with that combination does not exist.
			*/
			NO_TYPE_STYLE_COMBINATION = -3;

			/**
			* \brief Indicates that there is no font with that name on the device.
			*/
			NAME_NONEXISTENT = -4;

			/**
			* \brief Indicates that maFontGetCount() was not called first.
			*/
			LIST_NOT_INITIALIZED = -5;

			/**
			* \brief Indicates that the buffer is not big enough to store the font name.
			*/
			INSUFFICIENT_BUFFER = -6;

			/**
			* \brief Indicates that an invalid size was passed.
			*/
			INVALID_SIZE = -7;

			/**
			* \brief Indicates that the font cannot be deleted because it is in use.
			*  maFontDelete(handle)  fails with this return code.
			*/
			DELETE_DENIED = -8;
		}

		/**
		* Returns a handle to one of the default fonts of the device, in the style and size you specify.
		* \param 'type' The type of the font, can be FONT_TYPE_[SANS_SERIF,SERIF,MONOSPACE].
		* \param 'style' The style of the font, can be FONT_STYLE_[NORMAL,BOLD,ITALIC].
		* \param 'size' The size of the font.
		* \return The handle to the font, RES_FONT_NO_TYPE_STYLE_COMBINATION, or RES_FONT_INVALID_SIZE.
		*/
		MAHandle maFontLoadDefault(in int type, in int style, in int size);

		/**
		* Sets the font to be used with maDrawText and maDrawTextW, and returns the handle
		* to the previous font.
		* \param 'font' an MAHandle for a font object.
		* \return The handle to the previous font, or RES_FONT_INVALID_HANDLE.
		*/
		MAHandle maFontSetCurrent(in MAHandle font);

		/**
		* Returns the number of fonts that are available in the system.
		* \return Number of fonts.
		* \see maFontGetName.
		*/
		int maFontGetCount();

		/**
		* Copies the font postscript name of the given index to the buffer.
		* You must have first called maFontGetCount() at least once before calling this function.
		* \param 'index' A 0-based index to the font.
		* \param 'buffer' An empty char buffer that will receive the font name.
		* \param 'bufferLen' The size of the buffer.
		* \return The number of bytes copied (with terminating NULL) or RES_FONT_INDEX_OUT_OF_BOUNDS
		* 		or RES_FONT_INSUFFICIENT_BUFFER or RES_FONT_LIST_NOT_INITIALIZED.
		* \see maFontGetCount, maFontLoadWithName.
		*/
		int maFontGetName(in int index, out MAString buffer range("bufferLen"), in int bufferLen);

		/**
		* Returns a handle to a font with the specific postscript name and size.
		* \param 'postScriptName' The postscript name of the font.
		* \param 'size' The size of the font.
		* \return Handle to the font, RES_FONT_NAME_NONEXISTENT, or RES_FONT_INVALID_SIZE.
		*/
		MAHandle maFontLoadWithName(in char* postScriptName, in int size);

		/**
		* Deletes a loaded font
		* \param 'font' A font handle
		* \return RES_FONT_OK, RES_FONT_INVALID_HANDLE, or RES_FONT_DELETE_DENIED.
		*/
		int maFontDelete(in MAHandle font);

		/**
		 * Sends the current call stack to the report pipe. Returns 0 if succeeded.
		 */
		int maReportCallStack();

		/**
		* Dumps a string, an int, and the current call stack to the log file. Returns 0 if succeeded.
		*/
		int maDumpCallStackEx(in MAString str, in int data);

		/**
		* Protects a piece of the data memory.
		* Any attempt to write to that piece of memory will raise a panic.
		* \param 'start' The start address of the memory piece to protect.
		* \param 'length' The length of the memory piece to protect.
		*/
		void maProtectMemory(in MAAddress start, in int length);

		/**
		* Unprotects a piece of the data memory.
		* \param 'start' The start address of the memory piece to unprotect.
		* \param 'length' The length of the memory piece to unprotect.
		*/
		void maUnprotectMemory(in MAAddress start, in int length);

		/**
		* Toggles memory protection.
		* \param 'enable' If 1 turns on memory protection, if 0 turns of memory protection.
		*/
		void maSetMemoryProtection(in int enable);

		/**
		* Returns if memory protection is enabled or not.
		* \returns '1' if memory protection is turned on, '0' if it is turned off.
		*/
		int maGetMemoryProtection();

		/**
		* Returns the percentage of battery power remaining. This is an integer between 0 and 100.
		* Currently only available on some Symbian and Windows Mobile phones.
		*/
		int maGetBatteryCharge();

#if IX_GUIDO
		/**
		* Starts reading a text using TextToSpeech. If TTS is already active,
		* the old text is aborted.
		*
		* The system copies the text; it doesn't have to be kept in memory
		* for the duration of the speech.
		*
		* Only the Gui-Do platform supports TTS.
		*
		* \warning Bug: Do not call this immediately when the program starts.
		* The sound stream takes some time to initialize,
		* and if this is called before the initialization is done,
		* an Unhandled Symbian Error (-11) will occur.
		*
		* \returns A unique identifier for the TTS session.
		* TTS events will have a copy of this identifier.
		*/
		int maStartSpeaking(in MAString text);
		/**
		* Aborts TTS.
		*/
		int maStopSpeaking();
		/**
		* Returns \> 0 if TTS is active, zero otherwise.
		*/
		int maIsSpeaking();
		/**
		* Sets the volume of TTS. Returns the previous volume.
		* The volume ranges from 0 to 100. Illegal input values will be capped.
		* The default volume is 100.
		*/
		int maSetSpeechVolume(in int volume);

		/**
		* I'm guessting these range from 0 to 100, but I'm not sure.
		* Try-see if the original values reflect anything interesting.
		*/
		int maSetSpeechSpeed(in int speed);
		int maSetSpeechPitch(in int pitch);

		/**
		* Returns the hyperbolic sine of x.
		* \param x An angle in radians.
		*/
		double sinh(in double x);
		/**
		* Returns the hyperbolic cosine of x.
		* \param x An angle in radians.
		*/
		double cosh(in double x);
		/**
		* Returns the hyperbolic arc tangent of x.
		*/
		double atanh(in double x);
#endif	//IX_GUIDO

		/**
		* Calls on the operating system to lock the phone's keypad.
		* Returns \> 0 if successful.
		*/
		int maLockKeypad();
		/**
		* Calls on the operating system to unlock the phone's keypad.
		* Returns \> 0 if successful.
		*/
		int maUnlockKeypad();
		/**
		* Returns \> 0 if the phone's keypad is locked by the operating system, zero otherwise.
		*/
		int maKeypadIsLocked();

		/**
		* Writes data to the MoSync system log file.
		* Useful only for debugging purposes.
		*/
		int maWriteLog(in MAAddress src, in int size);

		/**
		* \brief Information about a Bluetooth device.
		*/
		struct MABtDevice {
			///in (pointer), out (buffer)
			char* name;
			///in, the length of the buffer pointed to by a name.
			int nameBufSize;
			///out, the length of the name, excluding the terminating zero.
			int actualNameLength;
			///out
			MABtAddr address;
		}

		/**
		* \brief A Universally Unique Identifier.
		*
		* Common Bluetooth UUID values can be found in MAUtil/mauuid.h.
		*/
		struct MAUUID {
			int i[4];
		}

		/**
		* \brief Information about an MABtService object.
		*/
		struct MABtServiceSize {
			/**
			* The buffer size neccesary to contain the full name,
			* or <0 if the service has no name.
			*/
			int nameBufSize;
			/**
			* The number of UUIDs associated with the service.
			*/
			int nUuids;
		}

		/**
		* \brief Information about a Bluetooth service.
		*/
		struct MABtService {
			/**
			* The port number for the service.
			* \see maConnect()
			*/
			int port;
			/**
			* Pointer to a buffer that receives the service's human-readable name.
			*/
			char* name;
			/**
			* The size of the buffer being pointed to by \a name.
			*/
			int nameBufSize;
			/**
			* Pointer to a buffer that receives the UUIDs associated with the service.
			* The buffer must be large enough to contain the number of UUIDs reported
			* by the last call to maBtGetNextServiceSize().
			*/
			MAUUID* uuids;
		}

		/**
		* Starts a device discovery operation.
		*
		* \param names Set this to non-zero to retrieve the names of remote devices.
		* This takes extra time, so set it to zero for faster scanning.
		*
		* \note On Windows, due to a bug in the Microsoft Bluetooth stack,
		* newly discovered devices may appear without names.
		* Re-scanning should make the devices' names appear properly.
		* A workaround is planned for a future release of MoSync.
		*
		* \returns 0 on success, \< 0 on failure.
		*
		* \see maBtGetNewDevice
		* \see maBtCancelDiscovery
		* \see EVENT_TYPE_BT
		*/
		int maBtStartDeviceDiscovery(in int names);

		/**
		* Fills an MABtDevice structure with information about a device.
		* Removes the data from an internal queue filled by maBtStartDeviceDiscovery().
		*
		* If the \a names parameter of maBtStartDeviceDiscovery() was zero,
		* all members of \a d except \a address are ignored and unchanged.
		*
		* The space needed to store the device name and its terminating zero
		* may be greater than a nameBufSize. In that case, the copy is truncated.
		* The maximum length of a device name according to the Bluetooth 2.0 specification
		* is 248 bytes, excluding the terminating zero. However, it's recommended that you
		* don't provide buffers larger than what your application has a use for.
		*
		* Note that you need to fill the MABtDevice structure before passing it
		* as a parameter, otherwise you will get memory access problems.
		*
		* \returns 1 if successful, zero if the queue is empty.
		*/
		int maBtGetNewDevice(out MABtDevice d);

		/**
		* Starts a service discovery operation.
		* Takes a device address and the UUID of the service class to search for.
		* For example, pass #RFCOMM_PROTOCOL_MAUUID and you'll get all connectable services.
		* Pass #SerialPort_Service_MAUUID and you'll get only that type of service.
		*
		* \see maBtGetNextServiceSize
		* \see maBtGetNewService
		* \see maBtCancelDiscovery
		* \see EVENT_TYPE_BT
		*
		* \returns 0 on success, \< 0 on failure.
		*
		* \note Service discovery is not supported on Android. Use MAUtil::BluetoothConnection
		* to connect via service UUID. That method is cross-platform.
		*/
		int maBtStartServiceDiscovery(in MABtAddr address, in MAUUID uuid);

		/**
		* Fills an MABtServiceSize structure with meta-data about the next service.
		* Does not remove the service from the queue.
		* \returns \> 0 on success, or zero if the queue is empty.
		* \see maBtStartServiceDiscovery
		* \see maBtGetNewService
		*/
		int maBtGetNextServiceSize(out MABtServiceSize dst);

		/**
		* Fills an MABtService structure with information about the next service.
		* Removes the data from the internal queue filled by maBtStartServiceDiscovery().
		* \returns \> 0 on success, or zero if the queue is empty.
		* \see maBtGetNextServiceSize
		*/
		int maBtGetNewService(out MABtService dst);

		/**
		* Cancels any active discovery operation.
		* If an operation was canceled, its last BT event will have the state #CONNERR_CANCELED.
		* This is an asynchronous operation. If this function returns 1,
		* it is not safe to start another discovery before
		* you've received the #CONNERR_CANCELED event.
		* \see maBtStartDeviceDiscovery
		* \see maBtStartServiceDiscovery
		* \see EVENT_TYPE_BT
		* \returns 0 if there was no active operation, 1 if there was.
		*/
		int maBtCancelDiscovery();

		/**@}*/

#if IX_WLAN
		constset int WLAN_ADDR_ {
			LEN = 6;
		}
		/**
		* \brief A WLAN address.
		*/
		struct MAWlanAddr {
			byte a[WLAN_ADDR_LEN];
		}

		/**
		* \brief A WLAN access point.
		*/
		struct MAWlanAp {
			/// out
			MAWlanAddr address;
			/// in(ptr), out(content)
			char* name;
			/// in
			int nameBufSize;
			/// out. dBm?
			int signalStrength;
		}

		/**
		* Causes EVENT_TYPE_WLAN. Returns \<0 on failure.
		* WLAN events' state are \>0 when the discovery is complete,
		* 0 when it's still going on, \<0 on error.
		*/
		int maWlanStartDiscovery();

		/**
		* Returns strlen(name) + 1 on success, 0 if no new AP is available, \<0 on failure.
		*
		* If \a dst.nameBufSize is less than the return value, the name is not copied.
		*
		* The IEEE 802.11 WLAN standard specifies that a name may be up to 32 characters long.
		* Your buffer should therefore be at least 33 bytes long,
		* in order to contain a maximum-length name and terminating zero.
		*/
		int maWlanGetNewAp(out MAWlanAp dst);
#endif	//IX_WLAN

		/**
		* \brief A geographical location specified by latitude and longitude, horizontal and vertical accuracy, and altitude.
		*
		* Only if \a state equals #MA_LOC_QUALIFIED do the other members contain valid data.
		*
		* Coordinates are in the WGS84 datum.
		*
		* The horizontal accuracy is the RMS (root mean square) of east accuracy
		* (latitudinal error in meters, 1-sigma standard deviation), north accuracy
		* (longitudinal error in meters, 1-sigma).
		*
		* The vertical accuracy is in meters in vertical direction
		* (orthogonal to ellipsoid surface, 1-sigma standard deviation).
		*
		* Accuracy values may be NaN, if accuracy is unknown.
		*
		* \see maLocationStart()
		*/
		struct MALocation {
			/**
			* The validity of the coordinates.
			* One of the \link #MA_LOC_NONE MA_LOC \endlink constants.
			*/
			int state;
			/*	//disabled
			* The time at which the location was collected.
			* This is the number of seconds that have passed since
			* 00:00:00, Jan 1st, 1970, local time.
			*/
			//int time;
			/*	//disabled
			* The millisecond component of \a time.
			*/
			//int timeMillis;

			double lat;
			double lon;
			double horzAcc;
			double vertAcc;
			float alt;
		}

		constset int MA_LOC_ {
			NONE = 1;
			INVALID = 2;
			UNQUALIFIED = 3;
			QUALIFIED = 4;
		}

		constset int MA_LPS_ {
			/**
			* Availability status code: the location provider is available.
			*/
			AVAILABLE = 1;

			/**
			* Availability status code: the location provider is temporarily unavailable.
			* Temporary unavailability means that the method is unavailable due to reasons
			* that can be expected to possibly change in the future and the provider to
			* become available. An example is not being able to receive the signal because
			* the signal used by the location method is currently being obstructed,
			* e.g. when deep inside a building for satellite based methods.
			* However, a very short transient obstruction of the signal should not cause
			* the provider to toggle quickly between TEMPORARILY_UNAVAILABLE and AVAILABLE.
			*/
			TEMPORARILY_UNAVAILABLE = 2;

			/**
			* Availability status code: the location provider is out of service.
			* Being out of service means that the method is unavailable and the implementation
			* is not able to expect that this situation would change in the near future.
			* An example is when using a location method implemented in an external device and
			* the external device is detached.
			*/
			OUT_OF_SERVICE = 3;
		}

		/**
		* Starts collecting location information.
		* Does nothing if collection is already active.
		* May cause a system popup asking for the user's permission.
		*
		* \link #EVENT_TYPE_LOCATION LOCATION events \endlink will be generated as the
		* estimated location is updated.
		*
		* \link #EVENT_TYPE_LOCATION_PROVIDER LOCATION_PROVIDER events \endlink will be generated
		* when the location provider state changes.
		*
		* \returns MA_LPS_AVAILABLE on success, 0 if collection was already active, or
		* MA_LPS_OUT_OF_SERVICE if the location provider is out of service, or
		* \< 0 on error.
		*
		* \note <b>The location API is experimental, not fully tested.
		* It may not work as advertised.</b>
		*
		* In particular, it is unsupported on the MoSync Emulator.
		* Implementation details are likely to change in the future.
		*/
		int maLocationStart();

		/**
		* Stops collecting location information, and stops generating events.
		* Does nothing if collection is not active.
		*
		* \note \link #EVENT_TYPE_LOCATION Location events \endlink that are generated before
		* this function returns may remain in the event queue afterwards.
		*
		* \returns 0.
		*/
		int maLocationStop();

		/**
		* Requests that the operating system handle (for example, display or install) the indicated URL.
		*
		* If the platform has the appropriate capabilities and resources available,
		* it SHOULD bring the appropriate application to the foreground and let the user
		* interact with the content, while keeping the MoSync application running in the background.
		* If the platform does not have appropriate capabilities or resources available,
		* it MAY wait to handle the request until after the MoSync application exits.
		* In this case, when the requesting MoSync application exits, the platform MUST then bring
		* the appropriate application (if one exists) to the foreground to let the user
		* interact with the content.
		*
		* The URL can be of the form <tt>http://\<address\></tt>, in which case the usual response is
		* to launch the built-in web browser.
		*
		* The URL can also be of the form <tt>tel:\<number\></tt>, in which case the request is
		* interpreted as a request to initiate a voice call to the specified number.
		*
		* If the URL refers to a packaged application
		* (a .JAR file on Java platforms, .SIS on Symbian or .CAB on Windows Mobile),
		* the request is interpreted as a request to install that application.
		*
		* The application being requested can be an update of the calling application.
		* In that case, the calling application must always exit before the request can be processed.
		*
		* \param url The URL for the platform to load.
		* An empty string or NULL cancels any pending requests.
		*
		* \returns \> 0 if maExit() must be called before the request can be processed.
		* 0 if the request is being processed.
		* \< 0 if the request could not be processed.
		* Specifically, the error code #IOCTL_UNAVAILABLE means that the protocol
		* of the request is not supported on the platform.
		*/
		int maPlatformRequest(in MAString url);

		constset int MA_ACCESS_ {
			READ = 1;
			READ_WRITE = 3;
		}

		/**
		* Opens a file handle.
		* If the file exists, the file will be accessible according to the mode specified.
		* If the file does not exist, a handle will still be returned and
		* maFileExists() will return false.
		* The file may then be created by calling maFileCreate().
		*
		* Directories may be opened with this function. They cannot be read or written,
		* but they can be created and deleted, and their existence can be queried.
		* Directory paths must end with a slash('/').
		*
		* Attempting to open an existing directory without ending its path with a slash will fail.
		* Likewise, attempting to open an existing file while ending its path with a slash will also fail.
		* Either case will return #MA_FERR_WRONG_TYPE.
		*
		* \note To avoid memory leaks, all opened handles should be closed using maFileClose().
		*
		* \note To find valid file paths, use maFileListStart().
		*
		* \param path The absolute path to the file.
		* \param mode The access mode. Either #MA_ACCESS_READ or #MA_ACCESS_READ_WRITE.
		* Directories also use these access modes. #MA_ACCESS_READ lets you see if the directory exists.
		* #MA_ACCESS_READ_WRITE also lets you create or delete it.
		* \returns The new file handle, or \< 0 on error.
		*
		* \note If any maFile function other than maFileOpen() fails,
		* the state of the file handle becomes boundedly undefined.
		* This means that any operation on it, other than maFileClose(), may fail.
		*/
		MAHandle maFileOpen(in MAString path, in int mode);

		/**
		* Returns 1 if the file exists, 0 if it doesn't, or \< 0 on error.
		*/
		int maFileExists(in MAHandle file);

		/**
		* Closes a file handle. Returns 0. Panics on error.
		*/
		int maFileClose(in MAHandle file);

		/**
		* Creates a file or directory, given an file handle opened with #MA_ACCESS_READ_WRITE.
		* The file must not exist prior to calling this function.
		* After creation, the file will be accessible for writing and reading.
		* Returns 0 on success, or \< 0 on error.
		*/
		int maFileCreate(in MAHandle file);

		/**
		* Deletes a file or directory.
		* The file must exist prior to calling this function.
		* If it's a directory, it must be empty.
		* Returns 0 on success, or \< 0 on error.
		*/
		int maFileDelete(in MAHandle file);

		/**
		* Returns the size of the file, or \< 0 on error.
		* \note MoSync cannot handle files larger than 2 GiB (2^31 - 1 bytes).
		* \param file A file handle. The file must exist and must not be a directory.
		*/
		int maFileSize(in MAHandle file);

		/**
		* Returns the number of free bytes on the file system on which \a file resides.
		* Note that due to file system overhead, it is not possible to use all of
		* this space for file data.
		* Returns \< 0 on error.
		*/
		int maFileAvailableSpace(in MAHandle file);

		/**
		* Returns the total size, in bytes, of the file system on which \a file resides.
		* Returns \< 0 on error.
		*/
		int maFileTotalSpace(in MAHandle file);

		/**
		* Returns the date/time when the file was last modified, or \< 0 on error.
		* The time format is Unix UTC.
		* \see maTime()
		*/
		int maFileDate(in MAHandle file);

		/**
		* Renames a file.
		*
		* If \a newName does not contain a slash,
		* the file stays in its original directory.
		*
		* If \a newName does contain a slash, it must be a complete pathname,
		* and the file is moved to that path. The new path must be on the same file system
		* as the original path. If it is not, this function fails with #MA_FERR_RENAME_FILESYSTEM.
		* Moving a file to another directory is not supported on Java ME. If it is attempted,
		* this function fails with #MA_FERR_RENAME_DIRECTORY.
		*
		* \returns 0 on success, or \< 0 on error.
		*/
		int maFileRename(in MAHandle file, in MAString newName);

		/**
		* Truncates the file.
		*
		* If \a offset is less than the file's current size,
		* the file's new size is equal to the offset. All data after the offset is discarded.
		*
		* If \a offset is equal to the file's current size, this function does nothing.
		*
		* If \a offset is greater than the file's current size,
		* this function MAY increase the size of the file.
		* You can determine if it did so by calling maFileSeek() with #MA_SEEK_END.
		*
		* If the file's current position is greater than \a offset, it is reset
		* to be equal to \a offset.
		*
		* The file must exist prior to calling this function.
		* Returns 0 on success, or \< 0 on error.
		*/
		int maFileTruncate(in MAHandle file, in int offset);

		/**
		* Writes from memory to file.
		* \param file Target file.
		* \param src Source memory address.
		* \param len Length, in bytes, of the data to be written.
		* \returns 0 on success, or \< 0 on error.
		*/
		int maFileWrite(in MAHandle file, in MAAddress src, in int len);
		/**
		* Writes from a data object to file.
		* \param file Target file.
		* \param data Source data object.
		* \param offset Offset from the start of the data object.
		* \param len Length, in bytes, of the data to be written.
		* \returns 0 on success, or \< 0 on error.
		*/
		int maFileWriteFromData(in MAHandle file, in MAHandle data, in int offset, in int len);
		/**
		* Reads exactly \a len bytes from file to memory.
		* \param file Source file.
		* \param src Target memory address.
		* \param len Length, in bytes, of the data to be read.
		* \returns 0 on success, or \< 0 on error. If \a len bytes is not available, #MA_FERR_GENERIC is returned.
		*/
		int maFileRead(in MAHandle file, out MAAddress dst, in int len);
		/**
		* Reads exactly \a len bytes from file to a data object.
		* \param file Source file.
		* \param data Target data object.
		* \param offset Offset from the start of the data object.
		* \param len Length, in bytes, of the data to be read.
		* \returns 0 on success, or \< 0 on error. If \a len bytes is not available, #MA_FERR_GENERIC is returned.
		*/
		int maFileReadToData(in MAHandle file, in MAHandle data, in int offset, in int len);

		/**
		* Returns the file's current position, or \< 0 on error.
		* \param file A file handle. The file must exist and must not be a directory.
		*/
		int maFileTell(in MAHandle file);

		/**
		* Sets the file's position.
		* \param file A file handle. The file must exist and must not be a directory.
		* \param offset The offset of the new position,
		* relative to the position specified by \a whence.
		* \param whence One of the \link #MA_SEEK_SET MA_SEEK \endlink constants.
		* \returns The new position, or \< 0 on error.
		*/
		int maFileSeek(in MAHandle file, in int offset, in int whence);

		constset int MA_SEEK_ {
			/// Beginning of file.
			SET = 0;
			/// Current position.
			CUR = 1;
			/// End of file.
			END = 2;
		}

		constset int MA_FL_SORT_ {
			/// Don't sort the files.
			NONE = 0;
			/// Sort the files by date. See maFileDate().
			DATE = 1;
			/// Sort the files by name. Case-sensitive?
			NAME = 2;
			/// Sort the files by size. See maFileSize().
			SIZE = 3;
		}

		constset int MA_FL_ORDER_ {
			/// Oldest / smallest / A first.
			ASCENDING = 0x10000;
			/// Newest / biggest / Z first.
			DESCENDING = 0x20000;
		}

		/**
		* Creates a listing of names of files and directories, or file systems.
		* Call maFileListNext() repeatedly to retrieve the names. Call maFileListClose() to
		* free the resources used.
		*
		* It is often useful to begin by listing the file systems.
		*
		* \param path The full path to a directory, or the empty string,
		* which specifies that the root file systems should be listed.
		* Which root file systems are listed vary between platforms.
		* \param filter A string to match names with. May include an asterisk ('*') wildcard
		* to represent 0 or more characters. Ignored if \a path is empty.
		* \param sorting One of the \link #MA_FL_SORT_DATE MA_FL_SORT \endlink flags,
		* OR'd with one of the \link #MA_FL_ORDER_ASCENDING MA_FL_ORDER \endlink flags.
		* #MA_FL_SORT_NONE must not be combined with an
		* \link #MA_FL_ORDER_ASCENDING MA_FL_ORDER \endlink flag.
		* \note Sorting is not supported on JavaME. If it is attempted,
		* this function will fail with #MA_FERR_SORTING_UNSUPPORTED.
		*
		* \returns A File Listing handle, or \< 0 on error.
		*/
		MAHandle maFileListStart(in MAString path, in MAString filter, in int sorting);

		/**
		* Writes the name of the next file in the list to the specified buffer.
		*
		* The buffer may be too small to contain the name and the terminating zero;
		* in that case, the internal list pointer remains unchanged,
		* the buffer will not be filled,
		* and you should allocate a bigger buffer and call this function again.
		* You may call this function with NULL and 0 to simply retrieve the length of the name.
		*
		* If the name ends with a slash('/'), it is a directory.
		*
		* \returns The length of the name, excluding the terminating zero,
		* or 0 if there are no more files, or \< 0 on error.
		*/
		int maFileListNext(in MAHandle list, out MAString nameBuf range("bufSize"), in int bufSize);

		/**
		* Closes a file listing, freeing its resources.
		*
		* \returns 0.
		*/
		int maFileListClose(in MAHandle list);

		/**
		* Sets the properties of a file
		*
		*/
		int maFileSetProperty(in MAString path, in int property, in int value);

		/**
		 * Saves an images in the photo gallery of the device.
		 *
		 * Notifications of this operation are available via
		 * #MAUtil::MediaExportListener.
		 *
		 * \param imageHandle handle of the image that needs to be exported to the
		 * device.
		 * \param imageName the name that the image will have after is saved.
		 * Note: This argument is ignored on iOS.
		 *
		 * \return #MA_MEDIA_RES_OK if the input was correct and the operation started
		 * or #MA_MEDIA_RES_IMAGE_EXPORT_FAILED otherwise.
		 */
		int maSaveImageToDeviceGallery(in MAHandle imageHandle, in MAString imageName);

		constset int MA_MEDIA_TYPE_ {
			/**
			 * @brief Indicatest an unknown multimedia type.
			 */
			UNKNOWN = -1;

			/**
			 * @brief Indicates an image type. This is used in multimedia operations.
			 */
			IMAGE = 0;
		}

		constset int MA_MEDIA_RES_ {
			/**
			 * @brief Indicates that the multimedia operation was successful.
			 */
			OK = 0;

			/**
			 * @brief Indicatest that the operation of exporting an image failed.
			 */
			IMAGE_EXPORT_FAILED = -2;
		}

		constset int MA_FPROP_ {
			IS_BACKED_UP = 1;
		}

		constset int MA_FERR_ {
			GENERIC = -2;
			NOTFOUND = -3;
			FORBIDDEN = -4;
			RENAME_FILESYSTEM = -5;
			RENAME_DIRECTORY = -6;
			WRONG_TYPE = -7;
			/// The sorting method requested is unsupported on the current platform.
			SORTING_UNSUPPORTED = -8;
			NO_SUCH_PROPERTY = -9;
		}


		//maybe add support for "hidden" files

		//possible C++ library functions
		//getURL()
		//isDir()
		//getName()
		//getPath()

		/**
		* Sends a text SMS. Since this may cost money for the user,
		* some platforms ask the user for permission,
		* by displaying a modal Yes/No message box.
		*
		* \param dst The phone number to send the message to.
		* \param msg The message to send. Only printable 7-bit ASCII characters are guaranteed
		* to arrive unaltered. 8-bit Latin-1 characters should work in most cases.
		*
		* \returns 0 on success. A \link #CONNERR_GENERIC CONNERR \endlink code \< 0 on error.
		* #CONNERR_FORBIDDEN if the user denied permission, and CONNERR_UNAVAILABLE if the
		* device cannot send SMS messages.
		*
		* \note Will create a text file on PC platforms, instead of sending anything.
		*/
		int maSendTextSMS(in MAString dst, in MAString msg);
		//int maSendBinarySMS(in MAString dst, in Address msg, in int len);

		/**
		* Values for the status field in the #EVENT_TYPE_SMS event.
		* This event is sent on Android and iOS.
		* Note: On iOS platforms the MA_SMS_RESULT_DELIVERED message corresponds
		* To the SMS being successfully queued by the system. There is no way to
		* know if it was actually delivered.
		*/
		constset int MA_SMS_RESULT_ {
			/// The SMS was sent.
			SENT = 1;
			/// The SMS was NOT sent.
			NOT_SENT = 2;
			/// The SMS was delivered.
			DELIVERED = 3;
			/// The SMS was NOT delivered.
			NOT_DELIVERED = 4;
		}

#if IX_RECORD
		//These functions are all synchronous,
		//although the handles can be used with asynchronous maConnRead().

		//returns a read-only connection handle. use it with maConnRead(), maRecordStart(), maRecordPause() and maConnClose().
		int maRecordSetup();

		//extension proposal:
		//in int type (audio, video, a/v, photo),
		//in int format (type-dependant. PCM, AMR, MP3, AAC; H.263; JPEG)

		//Note: since the size of data generated is usually unknown,
		//if one wants to write the data to a binary resource,
		//segmented binaries are required if any semblance of performance is to be upheld.
		//See wiki/MoSyncTodo for info on segmented binaries.


		//creates an image, using data from the phone's camera.
		//move this to a camera api?
		//int maRecordSnap(in MAHandle placeholder);	//in ? config (size, zoom, et al)


		//causes the connection to fill with data over time.
		//if it's not read quickly enough, data will be lost or the system will crash.
		int maRecordStart(in MAHandle rec);

		int maRecordPause(in MAHandle rec);
#endif	//IX_RECORD_AUDIO

#if IX_CELLID
		/**
		* \brief Information about the current cell, including country,
		* network and area code and the cell ID.
		*/
		struct MACellInfo {
			/**
			* Mobile Country Code. Identifies the country whose cellular network the phone
			* is connected to.
			*/
			char mcc[4];
			/**
			* Mobile Network Code. Identifies the network operator
			* in the country specified by the MCC.
			*/
			char mnc[8];
			/**
			* Location Area Code. Identifies a geographic area within the cellular network
			* specified by the MCC and MNC.
			*/
			int lac;
			/**
			* Cell ID. Identifies the base station the phone is connected to,
			* within the cellular network specified by the MCC and MNC.
			* \note While a phone may be in range of several base stations at any time,
			* only one of those base stations controls the connection between the phone and
			* the network. That is the base station reported here.
			*/
			int cellId;
		}

		/**
		* Retrieves the current cellular network information.
		* If the phone is offline or otherwise has no signal, this function will fail.
		* \param pInfo A pointer to a struct which will receive the information.
		* \returns 0 if successful. \< 0 otherwise.
		*/
		int maGetCellInfo(out MACellInfo pInfo);
#endif	//IX_CELLID

#if IX_CALL
		//TODO: document these states.
		constset int CALLSTATE_ {
			UNKNOWN = 0;
			IDLE = 1;
			DIALLING = 2;
			RINGING = 3;
			ANSWERING = 4;
			CONNECTING = 5;
			CONNECTED = 6;
			RECONNECTPENDING = 7;
			DISCONNECTING = 8;
			HOLD = 9;
			TRANSFERRING = 10;
			TRANSFERALERTING = 11;
		}

		/**
		* Starts dialing a voice call.
		* Returns 0 on successful beginning of dial, or \< 0 on error,
		* like a call already in progress.
		* Causes CALL events.
		* \param phoneNumber Max length: 100.
		*/
		int maCallDial(in MAString phoneNumber);

		/**
		* Starts answering a voice call. The call state must be #CALLSTATE_RINGING.
		* Returns 0 on successful initialization of the answering process,
		* or \< 0 on error, like if the line is not ringing.
		* Causes CALL events.
		* \note The line state may change while this function is being called. Therefore,
		* it may fail even if you haven't received a new CALL event.
		*/
		int maCallAnswer();

		/**
		* Starts hanging up a voice call, if a call is in progress.
		* Returns 0 if no call is in progress, or on successful beginning of hangup.
		* Returns \< 0 on error.
		* Can cause CALL events.
		*/
		int maCallHangup();
#endif	//IX_CALL

#if IX_STREAMING
		/**
		* Starts playing sound streamed from the specified connection.
		* The connection is made inaccessible for ordinary operations.
		* Causes STREAM events when the state of the streaming changes.
		* The connection is closed when the sound stops.
		* \returns \> 0 on successful start, \< 0 on error.
		* \param conn A readable connection, opened with maConnect() or maHttpCreate().
		* HTTP connections must be Finished to be readable.
		* \param mimeType The MIME type of the sound stream.
		* It can sometimes be retrieved from the HTTP "Content-Type" header.
		*/
		int maSoundPlayConn(in MAHandle conn, in MAString mimeType);

		//TODO: when streaming goes public, make this part of the union instead of custom.
		/**
		* \brief Event data associated with an audio stream.
		*/
		struct MAStreamEventData {
			/// One of the \link #STREAMEVENT_OPEN_COMPLETE STREAMEVENT \endlink constants.
			int event;
			/// The stream associated with the event.
			MAHandle stream;

			/**
			* Positive values denote progress. Negative values denote errors. Zero is not used.
			* \todo Define all possible values. They're currently platform-specific.
			*/
			int result;
		}

		//TODO: equalize over all platforms
		constset int STREAMEVENT_ {
			/// A connection to the streaming server has been established.
			OPEN_COMPLETE = 1;
			/// After this event, you can retrieve information about the stream.
			PREPARE_COMPLETE = 2;
			/// The stream reached its end.
			PLAY_COMPLETE = 3;
			/// Also known as buffering.
			LOADING_STARTED = 4;
			/// After this event, the stream is actually playing.
			LOADING_COMPLETE = 5;
			UNKNOWN_EVENT = 6;
		}

		/**
		* Top-left corner, auto-starts playing.
		* Causes \link #EVENT_TYPE_STREAM STREAM \endlink events.
		* Only one stream is allowed at a time.
		* \param url An RTSP url.
		* \returns A Stream MAHandle \>0, if successful in starting the operation.
		* #IOCTL_UNAVAILABLE if the function is unavailable. \<= -2 on other errors.
		* \todo Define error codes.
		*/
		MAHandle maStreamVideoStart(in MAString url);

		/**
		* Returns the size, in pixels, of the video stream. \<0 if the length cannot be determined.
		*
		* Will only work after #STREAMEVENT_PREPARE_COMPLETE has been received for the stream.
		*/
		MAExtent maStreamVideoSize(in MAHandle stream);

		/**
		* Sets the screen rectangle that the video stream should be shown in.
		* The default rectangle is in the top-left corner of the screen,
		* and has the same size as the source video.
		*
		* Will only work after #STREAMEVENT_PREPARE_COMPLETE has been received for the stream.
		*
		* If the video is playing when you call this function, the picture frame may go black
		* for a second while the system reorders itself.
		*
		* Whether the video is stretched or clipped to fit in the specified rectangle
		* depends on the combination platform/codec.
		* There should be a list; we don't have one yet.
		* Symbian always stretches.
		* I suspect most Java platforms stretches too, but I'm not sure.
		*
		* \returns #IOCTL_UNAVAILABLE if the function is unavailable. \<= -2 on other errors.
		*/
		int maStreamVideoSetFrame(in MAHandle stream, in MARect rect);

		/**
		* Returns the length of the stream, in milliseconds. \<0 if the length cannot be determined.
		*
		* Will only work after #STREAMEVENT_PREPARE_COMPLETE has been received for the stream.
		*/
		int maStreamLength(in MAHandle stream);

		/**
		* Returns the current playing time position of the stream, in milliseconds.
		* Returns \<0 if the position cannot be determined.
		*
		* Will only work after #STREAMEVENT_PREPARE_COMPLETE has been received for the stream.
		*/
		int maStreamPos(in MAHandle stream);

		/**
		* Sets the playing time position in the stream.
		* The provided position is clamped to the length of the stream.
		* For some platform/media combinations, setting the position is not very accurate.
		* The return value will indicate the actual position set.
		*
		* Will only work after #STREAMEVENT_PREPARE_COMPLETE has been received for the stream.
		*
		* \param stream A valid stream handle.
		* \param pos A position, in milliseconds.
		* \returns \<0 on error.
		*/
		int maStreamSetPos(in MAHandle stream, in int pos);

		/**
		* Pauses the stream. Does nothing if the stream is already paused.
		*/
		int maStreamPause(in MAHandle stream);

		/**
		* Resumes the stream. Does nothing if the stream is already playing.
		*/
		int maStreamResume(in MAHandle stream);

		/**
		* Closes the stream, releasing resources and rendering the handle invalid.
		*/
		int maStreamClose(in MAHandle stream);
#endif	//IX_STREAMING

		/**
		* \brief A structure containing information about the native framebuffer, including color format and resolution.
		*
		* The 'sizeInBytes' field is the amount of bytes that should be used to allocate the offscreen framebuffer (a backbuffer).
		*/
		struct MAFrameBufferInfo {
			int sizeInBytes;         // The size in bytes of the frame buffer, is calculated as width*pitch.
			int bytesPerPixel;       // The amount of bytes per pixel.
			int bitsPerPixel;        // The amount of bits per pixel.
			int redMask;             // The mask representing the bits occupied of the red color component in a pixel.
			int redShift;            // The index of the lowest significant bit of the red color component.
			int redBits;             // The amount of bits for the red color component.
			int greenMask;           // The mask representing the bits occupied of the green color component in a pixel.
			int greenShift;          // The index of the lowest significant bit of the green color component.
			int greenBits;           // The amount of bits for the green color component.
			int blueMask;            // The mask representing the bits occupied of the blue color component in a pixel.
			int blueShift;           // The index of the lowest significant bit of the blue color component.
			int blueBits;            // The amount of bits for the blue color component.
			int width;               // The width of the screen in pixels.
			int height;              // The height of the screen in pixels.
			int pitch;               // The pitch of the screen in byes, i.e. the amount of bytes to offset in order to step one scanline.
			int supportsGfxSyscalls; // If 1, standard graphic syscalls can by used to draw to the custom framebuffer, otherwise not.
		}

		/**
		 * Get frame buffer info. Use info.sizeInBytes to allocate memory for framebuffer.
		 * \param info A pointer to an MAFrameBufferInfo structure, which the information will be written to.
		 * \returns \<=0 on error.
		 */
		int maFrameBufferGetInfo(out MAFrameBufferInfo info);

		/**
		 * Pass a pointer to your framebuffer here. Each time an maUpdateScreen is performed,
		 * this piece of memory will be copied to the actual screen memory.
		 * \param data A pointer to the custom framebuffer.
		 * \returns \<=0 on error.
		 */
		int maFrameBufferInit(in MAAddress data);

		/**
		 * Close the framebuffer. The graphics sub-system will be set to use the standard framebuffer.
		 * \returns \<=0 on error.
		 */
		int maFrameBufferClose();

#if IX_AUDIOBUFFER
		constset int AUDIO_FMT_ {
			S8 = 1;
			S16 = 2;
			U8 = 3;
			U16 = 4;
		}

		/**
		* \brief Information about an audio buffer, including format, sample rate, channels, and size.
		*/
		struct MAAudioBufferInfo {
			int fmt;	//one of the AUDIO_FMT constants
			int sampleRate;	//in hertz
			int numChannels;
			int bufferSize;	//in bytes?
			MAAddress buffer;	//should be const void*
		}

		// returns 1.
		// should cause #EVENT_TYPE_AUDIOBUFFER_FILL when the system is ready to accept sound data.
		// Check MAEvent::state to see if the system failed.
		int maAudioBufferInit(in MAAudioBufferInfo info);

		/*
		* Call these functions in series after you have got the #EVENT_TYPE_AUDIOBUFFER_FILL event and filled your buffer.
		* Note: eventhough you aren't going to fill the buffer
		*/
		// returns 1.
		int maAudioBufferReady();

		// returns 1.
		int maAudioBufferClose();
#endif

		/**
		* Asynchronously accepts and opens a remote connection to a service.
		*
		* When a connection is accepted, a CONN event with #CONNOP_ACCEPT will be generated.
		* If the accept was successful, MAConnEventData::result will be a handle to the new,
		* normal connection. MAConnEventData::handle will be the server connection specified
		* in the call to this function.
		*
		* To accept another connection after such an event, call this function again.
		*
		* \param serv A server connection, opened with maConnect.
		* \returns \< 0 on error, \> 0 on success.
		* \see maConnect
		* \see maGetEvent
		*/
		int maAccept(in MAHandle serv);

		/**
		* Sends the application to the background, unless it's already there.
		* Generates a \link #EVENT_TYPE_FOCUS_LOST FOCUS_LOST \endlink event.
		* \note Only available on multi-tasking operating systems.
		*/
		int maSendToBackground();

		/**
		* Brings the application to the foreground, unless it's already there.
		* Generates a \link #EVENT_TYPE_FOCUS_LOST FOCUS_GAINED \endlink event.
		* \note Only available on multi-tasking operating systems.
		*/
		int maBringToForeground();

#if IX_SEGMENTED_DATA
		/**
		* Increases the size of a data object.
		* \note There is no way to decrease the size of a data object.
		* However, you can still destroy it.
		* \returns #RES_OK if succeded and #RES_OUT_OF_MEMORY if failed.
		* \see maDestroyObject()
		* \see maCreateData()
		* \see maGetDataSize()
		*/
		int maAddDataSize(in MAHandle data, in int size);
#endif	//IX_SEGMENTED_DATA

		/**
		* Retrieves the value of a Java System Property, or a MoSync System Property.
		*
		* There are a few MoSync System Properties. They are unavailable on some devices.
		* "mosync.imei" and "mosync.imsi" is the device's IMEI and IMSI number, respectively.
		* The format of these numbers is not specified. It varies from device to device.
		*
		* "mosync.iso-639-1" and "mosync.iso-639-2" is the current language used by the system's UI.
		* Multi-language applications should use this to determine which language to use.
		*
		* "mosync.winmobile.locale.SABBREVLANGNAME" is a windows mobile specific property.
		* See http://msdn.microsoft.com/en-us/library/dd373831%28VS.85%29.aspx.
		*
		* See http://www.loc.gov/standards/iso639-2/php/code_list.php -
		* The official list of valid ISO-639 codes (online).
		*
		* "mosync.device" is a description of the device. May include vendor, model name
		* and firmware version.
		* The format of this description is not specified. It varies from device to device.
		*
		* "mosync.device.name" is the name of the device. Usually set by the user.
		*
		* "mosync.device.UUID" is the Unique identifier of the device. Not available on iOS platform.
		*
		* "mosync.device.OS" is the operating system or platform that the device is using.
		* It might contain version detail as well.
		*
		* "mosync.device.OS.version" is the the version of the operating system that is running on the device.
		* It might contain minor revision information, e.g. 2.1Update-1.
		*
		* "mosync.network.type" it the type of the current active network connection.
		* It can one of the following four values: "none", "wifi", "mobile", or "unknown".
		*
		* "mosync.path.local" is the absolute path to the local file system,
		* on devices that have a local file system. The returned path has a
		* trailing slash character ('/').
		*
		* \param key The property's key.
		* \param buf A buffer where the value should be written.
		* \param size The size of the buffer, in bytes.
		* \returns The length of the value, including the terminating zero.
		* If this is greater than \a size, the value will not have been copied to be buffer.
		* In that case, you can make a bigger buffer and try again.
		* If the property did not exist (System.getProperty() returned null),
		* -2 will be returned.
		*/
		int maGetSystemProperty(in MAString key, out MAString buf range("size"), in int size);

		/**
		* Normally, when the first Internet connection is made in a Symbian application,
		* the user must choose an Internet Access Point.
		*
		* This function saves the ID of the active IAP for this application.
		* It will be used automatically the next time the application is started.
		*
		* \returns 1 if the ID was successfully saved. 0 if there is no active IAP. \< 0 on error.
		* \note Implemented only on Symbian.
		*/
		int maIapSave();

		/**
		* Removes any saved IAP ID for this application.
		* The next time the application is started,
		* or the next time an Internet connection is made after a call to maIapShutdown(),
		* the user will have to select a new IAP.
		* \returns 1 if the ID was successfully removed. 0 if there was no saved ID. \< 0 on error.
		* \note Implemented only on Symbian.
		* \see maIapSave()
		*/
		int maIapReset();

		/**
		* Shuts down the active IAP.
		* This has the effect of calling maConnClose() on all existing connections.
		* \returns 1 if the IAP was successfully shut down. 0 if there was no active IAP. \< 0 on error.
		* \note Implemented only on Symbian.
		* \see maIapSave()
		*/
		int maIapShutdown();

		/**
		* Returns the current telephone network status.
		* This is one of the \link #MA_NETWORK_UNKNOWN MA_NETWORK \endlink constants.
		* #MA_NETWORK_HOME and #MA_NETWORK_ROAMING are the most interesting ones;
		* all the others are variants of "not connected".
		* Returns \< 0 on error.
		* \see #EVENT_TYPE_NETWORK
		* \note Implemented only on Symbian, 3rd edition and later.
		*/
		int maNetworkStatus();

		constset int MA_NETWORK_ {
			UNKNOWN = 0;
			NO_SERVICE = 1;
			EMERGENCY_ONLY = 2;
			SEARCHING = 3;
			BUSY = 4;

			/**
			* Your operator's home network. Data connections are possible here.
			*/
			HOME = 5;
			DENIED = 6;

			/**
			* You're abroad. Data connections are possible here, but usually, extremely expensive.
			* Avoid making any connections unless you have WLAN access,
			* or the user is very sure of the cost.
			*/
			ROAMING = 7;
		}

		/**
		* Decides how IAP connection attempts should work.
		*
		* IAP connection attempts are made asynchronously by maConnect(),
		* if there is no active IAP.
		*
		* This setting is reset to default when the application starts.
		* \param type One of the \link #MA_IAP_METHOD_STANDARD MA_IAP_METHOD \endlink constants.
		* \returns \< 0 on error.
		* \note Implemented only on Symbian, 3rd edition and later.
		*/
		int maIapSetMethod(in int type);

		constset int MA_IAP_METHOD_ {
			/** The default. Connects to the IAP saved by maIapSave(), or,
			* if there is no saved IAP, opens the IAP selection dialog.
			*/
			STANDARD = 1;
			/**
			* Connects to the WLAN IAP with the highest signal strength.
			*/
			WLAN = 2;
		}

		/**
		* Decides which IAPs are visible in the IAP selection dialog.
		* This setting is reset to default when the application starts.
		* \param filter One of the \link #MA_IAP_FILTER_NOT_WLAN MA_IAP_FILTER \endlink constants.
		* \returns \< 0 on error.
		* \note Implemented only on Symbian, 3rd edition and later.
		*/
		int maIapSetFilter(in int filter);

		constset int MA_IAP_FILTER_ {
			/// All IAPs except WLAN.
			NOT_WLAN = 1;
			/// Only WLAN IAPs.
			WLAN = 2;
			/// All IAPs. This is the default.
			ALL = 3;
		}

#if IX_PIM
group PIMAPI "PIM API" {
#include "Modules/pim/PimConstants.idl"
#include "Modules/pim/PimFunctions.idl"
}
#endif	//IX_PIM

#if IX_WIDGET
#include "native_ui_intro_doc.idl"
group WidgetAPI "Widget API" {

#include "Modules/NativeUI/ActivityIndicator.idl"
#include "Modules/NativeUI/Button.idl"
#include "Modules/NativeUI/CheckBox.idl"
#include "Modules/NativeUI/CustomPicker.idl"
#include "Modules/NativeUI/DatePicker.idl"
#include "Modules/NativeUI/EditBox.idl"
#include "Modules/NativeUI/GLView.idl"
#include "Modules/NativeUI/HorizontalLayout.idl"
#include "Modules/NativeUI/Image.idl"
#include "Modules/NativeUI/ImageButton.idl"
#include "Modules/NativeUI/Label.idl"
#include "Modules/NativeUI/ListView.idl"
#include "Modules/NativeUI/ListViewItem.idl"
#include "Modules/NativeUI/ListViewSection.idl"
#include "Modules/NativeUI/Map.idl"
#include "Modules/NativeUI/MapPin.idl"
#include "Modules/NativeUI/ModalDialog.idl"
#include "Modules/NativeUI/NavBar.idl"
#include "Modules/NativeUI/NumberPicker.idl"
#include "Modules/NativeUI/OptionsMenu.idl"
#include "Modules/NativeUI/PanoramaView.idl"
#include "Modules/NativeUI/ProgressBar.idl"
#include "Modules/NativeUI/RadioButton.idl"
#include "Modules/NativeUI/RadioGroup.idl"
#include "Modules/NativeUI/RatingBar.idl"
#include "Modules/NativeUI/RelativeLayout.idl"
#include "Modules/NativeUI/Screen.idl"
#include "Modules/NativeUI/ScreenTransition.idl"
#include "Modules/NativeUI/SearchBar.idl"
#include "Modules/NativeUI/Slider.idl"
#include "Modules/NativeUI/StackScreen.idl"
#include "Modules/NativeUI/TabScreen.idl"
#include "Modules/NativeUI/TimePicker.idl"
#include "Modules/NativeUI/ToggleButton.idl"
#include "Modules/NativeUI/VerticalLayout.idl"
#include "Modules/NativeUI/VideoView.idl"
#include "Modules/NativeUI/WebView.idl"
#include "Modules/NativeUI/WidgetAlignment.idl"
#include "Modules/NativeUI/WidgetConstants.idl"
#include "Modules/NativeUI/WidgetEvent.idl"
#include "Modules/NativeUI/WidgetFunctions.idl"
#include "Modules/NativeUI/WidgetProperties.idl"
#include "Modules/NativeUI/WidgetResultCodes.idl"
#include "Modules/NativeUI/WidgetTypes.idl"
//#include "Modules/NativeUI/ActionBarConstants.idl"
//#include "Modules/NativeUI/ActionBarFunctions.idl"

} // end of group WidgetAPI
#endif //IX_WIDGET

#include "Modules/Camera.idl"

		/**
		* Shows the virtual keyboard.
		*/
		int maShowVirtualKeyboard();

		/**
		* Displays a NativeUI text box, with
		* "OK" and "Cancel" buttons (or equivalent command items
		* if the OS uses other input methods).
		* The user can enter text using the native input system.
		*
		* This function returns immediately, leaving the text box on-screen.
		* While the text box is active, it will consume all key events.
		* Other events, like networking, will still be handled normally.
		*
		* When the user activates one of the command items ("OK" or "Cancel"),
		* a number of things will happen in order:
		*
		* The box's text will be copied to the buffer specified by \a outText.
		* The text box will disappear.
		* An event (#EVENT_TYPE_TEXTBOX) will be posted.
		*
		* The text box will allow input of up to (\a maxSize - 1) characters, but no more.
		* Additional keypresses at that point may be ignored, or may cause an error message,
		* at the discretion of the underlying implementation.
		*
		* \returns \>= 0 on success, \< 0 on error.
		*
		* \param title The box's title.
		* \param inText When the text box is created, it is populated with this string.
		* \param outText Pointer to a buffer. When the text box closes, the contents
		* are copied to this buffer.
		* \param maxSize The size of the buffer, in characters. Includes the terminating zero.
		* \param constraints Rules for how text is entered into the box.
		* Must be exactly one of the \link #MA_TB_TYPE_ANY MA_TB_TYPE \endlink constants, or'd with zero or more of the
		* \link #MA_TB_FLAG_PASSWORD MA_TB_FLAG \endlink constants.
		* \note Some combinations of constraint types and flags are useless or invalid.
		*/
		int maTextBox(in MAWString title, in MAWString inText,
			out MAWString outText range("maxSize * sizeof(wchar)"),
			in int maxSize, in int constraints);

		constset int MA_TB_TYPE_ {
			/// The user is allowed to enter any text, including line breaks.
			ANY = 0;
			/// The user is allowed to enter an e-mail address.
			EMAILADDR = 1;
			/// The user is allowed to enter an integer value.
			NUMERIC = 2;
			/// The user is allowed to enter a phone number.
			PHONENUMBER = 3;
			/// The user is allowed to enter a URL.
			URL = 4;
			/// The user is allowed to enter a real number value.
			/// This extends #MA_TB_TYPE_NUMERIC by allowing a decimal point.
			DECIMAL = 5;
			/** \brief The user is allowed to enter any text, except for line breaks.
			* Unavailable on some platforms.
			* In that case, maTextBox() will return #MA_TB_RES_TYPE_UNAVAILABLE.
			* You can use #MA_TB_TYPE_ANY instead.
			*/
			SINGLE_LINE = 100;

			/** Use this to separate types from flags in the \a constraints parameter.
			* This is not a valid type value.
			*/
			MASK = 0xFFFF;
		}
		constset int MA_TB_RES_ {
			/// The user chose OK.
			OK = 1;
			/// The user chose Cancel.
			CANCEL = 2;
			/// The specified type is unavailable on this platform.
			TYPE_UNAVAILABLE = -3;
		}
		constset int MA_TB_FLAG_ {
			/// Indicates that the text entered is confidential data that should be
			/// obscured whenever possible.
			/// This implies #MA_TB_FLAG_SENSITIVE.
			PASSWORD = 0x10000;
			/// Indicates that editing is disallowed.
			UNEDITABLE = 0x20000;
			/// Indicates that the text entered is sensitive data that the implementation
			/// must never store into a dictionary or table for use in predictive, auto-completing,
			/// or other accelerated input schemes. A credit card number is an example of sensitive data.
			SENSITIVE = 0x40000;
			/// Indicates that the text entered does not consist of words that are likely
			/// to be found in dictionaries typically used by predictive input schemes.
			NON_PREDICTIVE = 0x80000;
			/// This flag is a hint to the implementation that during text editing,
			/// the initial letter of each word should be capitalized.
			INITIAL_CAPS_WORD = 0x100000;
			/// This flag is a hint to the implementation that during text editing,
			/// the initial letter of each sentence should be capitalized.
			INITIAL_CAPS_SENTENCE = 0x200000;
		}

		/**
		* Make MoSync send key-events for the specified key, even when
		* the application does not have focus.
		* Can only capture one key at a time.
		* @param keyCode The \link #MAK_UNKNOWN MAK \endlink code for the key to capture.
		* @return \< 0 on error.
		* \see maKeyCaptureStop()
		*/
		int maKeyCaptureStart(in int keyCode);

		/**
		* Stops any key capture in progress.
		* @returns \< 0 on error.
		* \see maKeyCaptureStart()
		*/
		int maKeyCaptureStop();

		/**
		 * Turn on sending of HomeScreen events. Off by default.
		 * @return \< 0 on error.
		 * \see #EVENT_TYPE_HOMESCREEN_SHOWN
		 * \see #EVENT_TYPE_HOMESCREEN_HIDDEN
		 * \see maHomeScreenEventsOff()
		 */
		int maHomeScreenEventsOn();

		/**
		 * Turn off sending of HomeScreen events. Off by default.
		 * @return \< 0 on error.
		 */
		int maHomeScreenEventsOff();

		/**
		* Add shortcut icon to the device home screen.
		* Available on Android only.
		* @param name The name (label) of the shortcut to add.
		* @return \< 0 on error.
		*/
		int maHomeScreenShortcutAdd(in MAString name);

		/**
		* Remove shortcut icon from the device home screen.
		* Available on Android only.
		* @param name The name (label) of the shortcut to remove.
		* @return \< 0 on error.
		*/
		int maHomeScreenShortcutRemove(in MAString name);

		/**
		 * Add a notification item.
		 * @deprecated use #maNotificationLocalCreate instead.
		 * Note that there can only be one notification of type
		 * #NOTIFICATION_TYPE_APPLICATION_LAUNCHER. Additional notification
		 * types may be added in the future. This syscall is available
		 * on Android only.
		 *
		 * @param type The #NOTIFICATION_TYPE_APPLICATION_LAUNCHER constant.
		 * @param id The id of the notification. The id must be unique within
		 * the application.
		 * @param title Title of the notification.
		 * @param text String to be displayed as part of the notification.
		 * @return \< 0 on error or if the syscall is not available on the
		 * current platform.
		 */
		int maNotificationAdd(
			in int type,
			in int id,
			in MAString title,
			in MAString text);

		/**
		 * Remove a notification item.
		 * @deprecated use maNotificationDestroy instead.
		 * Currently implemented only on Android.
		 * @param id The id of the notification.
		 * @return \< 0 on error.
		 */
		int maNotificationRemove(in int id);

		constset int NOTIFICATION_TYPE_ {
			/// A persistent notification that will launch the
			/// application when selected.
			APPLICATION_LAUNCHER = 1;
		}

		/**
		 * Enable/disable fullscreen mode.
		 * Currently implemented only on Android.
		 * @param fullscreen 1 for fullscreen on, 0 for fullscreen off.
		 * @return \< 0 on error.
		 */
		int maScreenSetFullscreen(in int fullscreen);

		/**
		* Registers this application for autostart on device reboot.
		* Applications started this way start in the background;
		* invisible to the user, unless they check the list of running applications.
		* \returns 1 on success, 0 if already registered, \< 0 on error.
		*/
		int maAutostartOn();

		/**
		* Removes autostart registration for this application.
		* \returns 1 on success, 0 if already unregistered, \< 0 on error.
		*/
		int maAutostartOff();

		/**
		 * Turn on sending of screen state events. Off by default.
		 * Currently implemented only on Android.
		 * @return \< 0 on error.
		 * \see #EVENT_TYPE_SCREEN_STATE_ON
		 * \see #EVENT_TYPE_SCREEN_STATE_OFF
		 * \see maHomeScreenEventsOff()
		 */
		int maScreenStateEventsOn();

		/**
		 * Turn off sending of screen state events. Off by default.
		 * Currently implemented only on Android.
		 * @return \< 0 on error.
		 */
		int maScreenStateEventsOff();

		/**
		 * Lock device to be "awake". This means that the device
		 * won't go to sleep while the app is running.
		 * @param flag MA_WAKE_LOCK_ON or MA_WAKE_LOCK_OFF
		 * @return \>0 on success, \< 0 on error (-1 if not available).
		 */
		int maWakeLock(in int flag);

		constset int MA_WAKE_LOCK_ {
			/// Application will run with screen on (consumes power).
			ON = 1;
			/// Turn off the wake lock.
			OFF = 2;
		}

group OpenGLES "OpenGLES" {
#include "Modules/OpenGL/opengl_non_generated.idl"
#include "Modules/OpenGL/opengl_generated.idl"
}

		/**
		 * Logs information about the state of all current resources.
		 */
		void maReportResourceInformation();

		/**
		 * @deprecated use #maAlert instead.
		 * Displays a message to the user.
		 * \param title The title of the message box shown
		 * \param message The message should be short, not more than 40 characters,
		 * to ensure its visibility on all screen sizes.
		 */
		void maMessageBox(in MAString title, in MAString message);

		/**
		* Displays a message to the user.
		* It contains optional title, message and 3 buttons for selection.
		* On Android the buttons point to a positive, negative or neutral action.
		* When one of the buttons are clicked the alert is automatically dismissed.
		* When a selection is made a #EVENT_TYPE_ALERT event is sent with the button index.
		* \param title The title of the message box shown.
		* \param message The message should be short, not more than 40 characters,
		* to ensure its visibility on all screen sizes.
		* \param button1 The text on the first button. On Android it indicates a positive selection.
		* \param button2 The text on the second button. On Android it indicates a neutral selection.
		* \param button3 The text on the third button. On Android it indicates that a negative selection.
		*/
		void maAlert(in MAString title, in MAString message, in MAString button1, in MAString button2, in MAString button3);

		/**
		* \brief The toast timeout. Toasts can be displayed using #maToast.
		*/
		constset int MA_TOAST_DURATION_ {
			SHORT = 0; // aprox 2sec
			LONG = 1; // aprox 3.5sec
		}

		/**
		* \brief A toast is a view containing a quick little message for the user.
		* A toast provides simple feedback about an operation in a small popup.
		* It only fills the amount of space required for the message and the current
		* activity remains visible and interactive.
		* For example, navigating away from an email before you send it triggers a
		* "Draft saved" toast to let you know that you can continue editing later.
		* Toasts automatically disappear after a timeout, and do not handle any user interaction.
		* Toast are available only on Android.
		*
		* \param message The message in the toast.
		* \param duration One of the next constants:
		* - #MA_TOAST_DURATION_SHORT
		* - #MA_TOAST_DURATION_LONG
		*/
		int maToast(in MAString message, in int duration);

		/**
		* Together with the image picker event (\link EVENT_TYPE_IMAGE_PICKER IMAGE_PICKER \endlink),
		* this specifies the type of encoding used for the image data returned.
		*/
		constset int MA_IMAGE_PICKER_ITEM_ENCODING_ {
			PNG = 1;
			JPEG = 2;
		}

		/**
		* Determines what kind of event do we need from the image picker.
		*/
		constset int MA_IMAGE_PICKER_EVENT_RETURN_TYPE_ {
			// the image picker will return a handle to the bitmap image resource
			IMAGE_HANDLE = 1;
			// the image picker will return a handle to the jpeg encoded image resource
			// in binary format
			IMAGE_DATA = 2;
		}

		/**
		* Displays an image picker to the user.
		* It's display depends on the platform.
		* Note: when a selection is made a #EVENT_TYPE_IMAGE_PICKER event is sent.
		*/
		void maImagePickerOpen();

		/**
		* Displays an image picker to the user and sets the event return type.
		* It's display depends on the platform.
		* Note: when a selection is made a #EVENT_TYPE_IMAGE_PICKER event is sent.
		* \param eventType One of the next constants:
		* - #MA_IMAGE_PICKER_EVENT_RETURN_TYPE_IMAGE_HANDLE
		* - #MA_IMAGE_PICKER_EVENT_RETURN_TYPE_IMAGE_DATA
		*/
		void maImagePickerOpenWithEventReturnType(in int eventReturnType);

		/**
		* Displays a special kind of dialog that has a list of possible choices.
		* The list of options is displayed as buttons on iOS, and as text views on Android.
		* By clicking any option the dialog gets dismissed and a #EVENT_TYPE_OPTIONS_BOX_BUTTON_CLICKED event is sent back.
		*
		* \param title The dialog title.
		* \param destructiveButtonTitle The destructive button text. This is an iOS specific feature: it has different color than the other options,
		* and it indicates that it's action has destructive behaviour. On Android it is treated and it looks like a normal option.
		* \param cancelButtonTitle The dialog's Cancel button text. If left empty, the dialog is not cancelable.
		* \param otherButtonTitles The address to the buffer that stores the list of options.
		* \param otherButtonTitlesSize The size of the buffer, in bytes.
		*/
		void maOptionsBox(in MAWString title,in MAWString destructiveButtonTitle, in MAWString cancelButtonTitle,
								 in MAAddress otherButtonTitles, in int otherButtonTitlesSize);

group SensorAPI "Sensor API" {
		group SensorTypes "Sensor Types" {
		constset int SENSOR_TYPE_ {
			// A constant describing an accelerometer sensor type.
			ACCELEROMETER = 1;
			// A constant describing a magnetic field sensor type.
			MAGNETIC_FIELD = 2;
			// A constant describing an orientation sensor type.
			ORIENTATION = 3;
			// A constant describing a gyroscope sensor type.
			GYROSCOPE = 4;
			// A constant describing a proximity sensor type.
			PROXIMITY = 5;
			// A constant describing a compass sensor type.
			COMPASS = 6;
		}

		} // end of sensor types

		group SensorConsts "Sensor Constants" {
		constset int SENSOR_RATE_ {
			// Get sensor data as fast as possible.
			FASTEST = 0;
			// A rate suitable for games.
			GAME = -1;
			// The default rate. Suitable for screen orientation changes.
			NORMAL = -2;
			// A rate suitable for the user interface.
			UI = -3;
		}

		constset int SENSOR_ERROR_ {
			NONE = 0;
			// Errors for maSensorStart
			NOT_AVAILABLE = -1;
			INTERVAL_NOT_SET = -2;
			ALREADY_ENABLED = -3;
			// Errors for maSensorStop
			NOT_ENABLED = -4;
			CANNOT_DISABLE = -5;
		}

		constset int UIDEVICE_ORIENTATION_ {
		    // The orientation of the device cannot be determined.
			UNKNOWN = 0;
			// The device is in portrait mode, with the device held upright and the home button at the bottom.
			PORTRAIT = 1;
			// The device is in portrait mode but upside down, with the device held upright and the home button at the top.
			PORTRAIT_UPSIDE_DOWN = 2;
			// The device is in landscape mode, with the device held upright and the home button on the right side.
			LANDSCAPE_LEFT = 3;
			// The device is in landscape mode, with the device held upright and the home button on the left side.
			LANDSCAPE_RIGHT = 4;
			// The device is held parallel to the ground with the screen facing upwards.
			FACE_UP = 5;
			// The device is held parallel to the ground with the screen facing downwards.
			FACE_DOWN = 6;
		}

		constset int SENSOR_PROXIMITY_VALUE_ {
			// the device is not close to the user
			FAR = 0;
			// the device is close to the user
			NEAR = 1;
		}

		} //end of sensor constants

	group SensorFunctions "Sensor Functions" {
		/**
		* \brief Enables a sensor and starts sending events if the sensor is available.
		* If the sensor is already enabled this call will have no effect.
		* \param sensor       The sensor which should be enabled.
		* One of the \link #SENSOR_TYPE_ACCELEROMETER SENSOR_TYPE \endlink constants.
		* \param interval     Time interval in which a sensor update shall be triggered.
		* Can be one of the \link #SENSOR_RATE_FASTEST SENSOR_RATE \endlink constants or a time interval in milliseconds.
		* \return    #SENSOR_ERROR_NONE  on success.
		*            #SENSOR_ERROR_NOT_AVAILABLE if this sensor wasn't available.
		*            #SENSOR_ERROR_INTERVAL_NOT_SET if the interval wasn't set, could be due to platform limitations.
		*            #SENSOR_ERROR_ALREADY_ENABLED if the sensor already was enabled.
		* \see #EVENT_TYPE_SENSOR
		*/
		int maSensorStart(in int sensor, in int interval);

		/**
		* \brief Disables a sensor so that it doesn't send any further events.
		* \param sensor    The sensor which should be disabled.
		* One of the \link #SENSOR_TYPE_ACCELEROMETER SENSOR_TYPE \endlink constants.
		* \return    #SENSOR_ERROR_NONE on success.
		*            #SENSOR_ERROR_NOT_ENABLED if this sensor wasn't enabled.
		*            #SENSOR_ERROR_CANNOT_DISABLE if there was a problem disabling the sensor.
		* \see #EVENT_TYPE_SENSOR
		*/
		int maSensorStop(in int sensor);

	}//End of Sensor Functions
} //End of Sensor API group

group NFCAPI "NFC API" {
		/**
		* Start listening to NFC events.
		* \return MA_NFC_NOT_ENABLED if NFC is not enabled on this device,
		* MA_NFC_NOT_AVAILABLE if NFC is not at all available, or
		* 0 otherwise.
		*/
		int maNFCStart();

		/**
		* Stop listening to NFC events.
		*/
		void maNFCStop();

		/**
		* Reads the next available tag.
		* @return A zero handle if no tag currently available
		*/
		MAHandle maNFCReadTag(in MAHandle nfcContext);

		/**
		* Destroys the tag. Clients are responsible for calling
		* this function for every corresponding maNFCReadTag.
		*/
		void maNFCDestroyTag(in MAHandle tagHandle);

		/**
		* Connects to a tag, enabling further I/O operations to be
		* performed on it.
		*/
		void maNFCConnectTag(in MAHandle tagHandle);

		/**
		* Closes I/O operations for a tag, disabling further I/O operations to be
		* performed on it.
		*/
		void maNFCCloseTag(in MAHandle tagHandle);

		/**
		* Determines whether a tag is of a certain type.
		* Use the constants prefixed with MA_NFC_TAG_TYPE_ to
		* see the available tag types.
		* \return > 0 if the tag is a the specified type, 0 if it is not,
		* and MA_NFC_INVALID_TAG_TYPE if the tag type is not supported
		* by this platform.
		*/
		int maNFCIsType(in MAHandle tagHandle, in int type);

		/**
		* To be able to call functions tag require the tag to be of
		* a certain type (see maNFCIsType), the tag received
		* must be converted to the proper type (see MA_NFC_TAG_TYPE_*
		* constants).
		* All typed tags returned by this function will be destroyed
		* when the tag used to produce them is destroyed. Ie no
		* explicit destruction of typed tags is necessary (but allowed).
		* \return A handle if the type was convertable to the specified
		* type.
		*/
		MAHandle maNFCGetTypedTag(in MAHandle tagHandle, in int type);

		/**
		* Starts a batch operation. No NFC I/O operations will be performed
		* until maBatchCommit has been called.
		* Note that only one active batch per tag is allowed.
		* \param The tag on which to perform the batch operation.
		* \return A non-zero value if a batch is already started for this tag or if a batch
		* could not be started, 0 otherwise.
		*/
		int maNFCBatchStart(in MAHandle tagHandle);

		/**
		* Asynchronously performs all operations since the last call to maNFCBatchStart. The event
		* delivered will be of the EVENT_TYPE_NFC_BATCH_OP type and
		* with an MANFCEventData containing the tag's handle.
		* \param The handle to the tag that is in batch mode.
		*/
		void maNFCBatchCommit(in MAHandle tagHandle);

		/**
		* Cancels all operations of the current batch.
		* \param The handle to the tag that is in batch mode.
		*/
		void maNFCBatchRollback(in MAHandle tagHandle);

		/**
		* Sends a message to a tag. The response will come as
		* an EVENT_TYPE_NFC_TAG_DATA_READ event, with the
		* handle set to the handle passed into this method
		* and the result field set to the number of bytes
		* actually read.
		* \param tag The tag to communicate with.
		* \param src The data to send.
		* \param len The length of the data to send.
		* \return 0 if the tag can be transceived to, < 0 otherwise.
		*/
		int maNFCTransceive(in MAHandle tag, in MAAddress src, in int srcLen, out MAAddress dst, out int dstLen);

		/**
		* Makes a tag read-only (this operation cannot be reverted).
		* The response will come as an EVENT_TYPE_NFC_TAG_READ_ONLY event, with the
		* handle set to the handle passed into this method.
		* \param tag The tag to make read only.
		* \return MA_NFC_INVALID_TAG_TYPE if the handle given as argument
		* cannot be made read-only.
		*/
		int maNFCSetReadOnly(in MAHandle tag);

		/**
		* Checks whether a tag is read-only.
		* \param tag The tag to check for read/write permissions.
		* \return MA_NFC_INVALID_TAG_TYPE if this operation is
		* not applicable, a value > 0 if it is read-only, or
		* 0 if it is read-only.
		*/
		int maNFCIsReadOnly(in MAHandle tag);

		/**
		* Returns the capacity/size of a tag.
		* \param tag The tag to get the size from.
		* \return The size of the tag, or -1 if unknown.
		*/
		int maNFCGetSize(in MAHandle tag);

		/**
		* Returns the (serial) id a tag. This id may or may
		* not be unique depending on the underlying technology.
		* The serial id may also be empty.
		* \param tag The tag to read from.
                * \param dst Where the result should be written to.
                * \param len The maximum length to write.
		* \return The number of bytes of the id.
		*/
		int maNFCGetId(in MAHandle tag, out MAAddress dst, in int len);

		/**
		* Reads an NDEF message from the given tag, which must
		* be of the MA_NFC_TAG_TYPE_NDEF type.
		* The response will come a an EVENT_TYPE_NFC_TAG_DATA_READ
		* event with the handle set to the handle passed into this method
		* and the result field set to 0 on success and a value < 0 on error.
		* After receiving the event, clients may call
		* maNFCGetNDEFMessage() to get the actual message.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCReadNDEFMessage(in MAHandle tag);

		/**
		* Writes an NDEF message to the given tag, which must
		* be of the MA_NFC_TAG_TYPE_NDEF or MA_NFC_TAG_TYPE_NDEF_FORMATTABLE type.
		* The response will come a an EVENT_TYPE_NFC_TAG_DATA_WRITE
		* event with the handle set to the handle passed into this method,
		* the result field set to 0 on success and a value < 0 on error,
		* and the dstId field set to the ndefMessage written.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		* \param tag The tag handle to write to
		* \param ndefMessage The message to write
		*/
		int maNFCWriteNDEFMessage(in MAHandle tag, in MAHandle ndefMessage);

		/**
		* Creates a new NDEF message, to be used primarily by
		* \code maNFCWriteDefMessage. \endcode
		* \param recordCount The number of records in the created message
		* \return The handle to the created NDEF message; clients are
		* responsible for destroying the message.
		*/
		MAHandle maNFCCreateNDEFMessage(in int recordCount);

		/**
		* Gets the NDEF message from a tag, which must
		* be of the MA_NFC_TAG_TYPE_NDEF type.
		* If the handle is not an NDEF tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		* (Please note the difference between an NDEF \b tag and an NDEF \b message.)
		* \return The handle to the NDEF message, which
		* may be subsequently used in NDEF specfic functions,
		* or the zero handle if the tag has no NDEF message
		* associated with it (in which case, clients may call
		* maNFCReadNDEFMessage).
		* IMPORTANT: Once the tag has been destroyed OR if
		* maNFCReadNDEFMessage is called, any NDEF messages
		* previously returned by this function
		* will be destroyed with it and cannot
		* be used.
		*/
		int maNFCGetNDEFMessage(in MAHandle tag);

		/**
		* \return A handle to the ith NDEF record of an NDEF message.
		* If the handle is not an NDEF message, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		MAHandle maNFCGetNDEFRecord(in MAHandle ndefMessage, in int ix);

		/**
		* \return The number of NDEF records in an NDEF message.
		* If the handle is not an NDEF message, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCGetNDEFRecordCount(in MAHandle ndefMessage);

		/**
		* Reads the variable length id of an NDEF record.
		* \param ndefRecord the handle to the record to read from.
		* \param dst Where the result should be written to.
		* \param len The maximum length to write.
		* \return The number of bytes written.
		* If the handle is not an NDEF message record, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCGetNDEFId(in MAHandle ndefRecord, out MAAddress dst, in int len);

		/**
		* Reads the variable length payload of an NDEF record.
		* \param ndefRecord the handle to the record to read from.
		* \param dst Where the result should be written to.
		* \param len The maximum length to write.
		* \return The number of bytes written.
		* If the handle is not an NDEF message record, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCGetNDEFPayload(in MAHandle ndefRecord, out MAAddress dst, in int len);

		/**
		* Returns the 3-bit TNF of an NDEF record.
		* If the handle is not an NDEF message record, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCGetNDEFTnf(in MAHandle ndefRecord);

		/**
		* Returns the variable length type field of an NDEF record.
		* \param ndefRecord the handle to the record to read from.
		* \param dst Where the result should be written to.
		* \param len The maximum length to write.
		* \return The number of bytes written.
		* If the handle is not an NDEF message record, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCGetNDEFType(in MAHandle ndefRecord, out MAAddress dst, in int len);

		/**
		* Sets the variable length id of an NDEF record.
		* If the handle is not an NDEF message record, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCSetNDEFId(in MAHandle ndefRecord, in MAAddress dst, in int len);

		/**
		* Sets the variable length payload of an NDEF record.
		* If the handle is not NDEF message record, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCSetNDEFPayload(in MAHandle ndefRecord, in MAAddress dst, in int len);

		/**
		* Sets the 3-bit TNF of an NDEF record,
		* If the handle is not NDEF message record, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCSetNDEFTnf(in MAHandle ndefRecord, in int tnf);

		/**
		* Returns the variable length type field of an NDEF record.
		* If the handle is not NDEF message record, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCSetNDEFType(in MAHandle ndefRecord, in MAAddress dst, in int len);

		/**
		* Authenticates a MIFARE Classic tag using the A or B key. Authentication must take place
		* before reading/writing to a certain sector.
		* The operation is asyncronous and will result in an EVENT_TYPE_NFC_TAG_AUTH_COMPLETE
		* event, unless part of a batch operation.
		* \param tagHandle The tag to authenticate
		* \param keyType Either MA_NFC_MIFARE_KEY_A or MA_NFC_MIFARE_KEY_B.
		* \param sectorIndex The sector to authenticate
		* \param keySrc The address to the key to authenticate with
		* \param keyLen The length of the key to authenticate with
		* If the handle is not a Mifare Classic tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCAuthenticateMifareSector(in MAHandle tagHandle, in int keyType, in int sectorIndex, in MAAddress keySrc, in int keyLen);

		/**
		* \return The number of sectors of a MIFARE Classic tag.
		* If the handle is not a Mifare Classic tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCGetMifareSectorCount(in MAHandle tagHandle);

		/**
		* Returns the number of blocks in a sector of a MIFARE Classic tag.
		* \param sector The sector to get the number of blocks in.
		* \return The number of blocks in a given sector.
		* If the handle is not a Mifare Classic tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCGetMifareBlockCountInSector(in MAHandle tagHandle, in int sector);

		/**
		* Returns the first block of a sector of a MIFARE Classic tag.
		* \param sector The sector of which to get the first block.
		* \return The index of the first block of the sector is returned.
		* If the handle is not a Mifare Classic tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCMifareSectorToBlock(in MAHandle tagHandle, in int sector);

		/**
		* Reads a number of blocks of a MIFARE Classic tag.
		* The operation is asyncronous and will result in an EVENT_TYPE_NFC_TAG_READ
		* event, unless part of a batch operation.
		* \param firstBlock The first block to read from.
		* \param dst The memory address to write to.
		* \param len The number of bytes to read. Several blocks may be read, depending
		* on len (A block is 16 bytes).
		* If the handle is not a Mifare Classic tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCReadMifareBlocks(in MAHandle tagHandle, in int firstBlock, out MAAddress dst, in int len);

		/**
		* Writes a number of blocks to a MIFARE Classic tag.
		* The operation is asyncronous and will result in an EVENT_TYPE_NFC_TAG_WRITE
		* event, unless part of a batch operation.
		* \param firstBlock The first block to write to.
		* \param dst The memory address to read from.
		* \param len The number of bytes to write. Several blocks may be written, depending
		* on len (A block is 16 bytes).
		* If the handle is not a Mifare Classic tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCWriteMifareBlocks(in MAHandle tagHandle, in int firstBlock, in MAAddress dst, in int len);

		/**
		* Reads a number of blocks of a MIFARE Ultralight tag.
		* The operation is asyncronous and will result in an EVENT_TYPE_NFC_TAG_READ
		* event, unless part of a batch operation.
		* \param firstBlock The first block to read from.
		* \param dst The memory address to write to.
		* \param len The number of bytes to read. Several pages may be read, depending
		* on len (A page is 16 bytes).
		* If the handle is not a Mifare Ultralight tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCReadMifarePages(in MAHandle tagHandle, in int firstPage, out MAAddress dst, in int len);

		/**
		* Writes a number of blocks of a MIFARE Ultralight tag.
		* The operation is asyncronous and will result in an EVENT_TYPE_NFC_TAG_WRITE
		* event, unless part of a batch operation.
		* \param firstBlock The first block to write to.
		* \param dst The memory address to read from.
		* \param len The number of bytes to write. Several pages may be written, depending
		* on len (A page is 16 bytes).
		* If the handle is not a Mifare Ultralight tag, MA_NFC_INVALID_TAG_TYPE will be returned.
		*/
		int maNFCWriteMifarePages(in MAHandle tagHandle, in int firstPage, in MAAddress dst, in int len);

		constset int MA_NFC_ {
			/**
			* A constant indicating there is no NFC support on the device.
			*/
			NOT_AVAILABLE = -1;

			/**
			* A constant indicating NFC is not enabled on the device. (But there is hardware support).
			*/
			NOT_ENABLED = -2;

			/**
			* A constant indicating an invalid tag type.
			*/
			INVALID_TAG_TYPE = -2;

			/**
			* An error code if tag connection is lost.
			*/
			TAG_CONNECTION_LOST = -3;

			/**
			* An error code if trying to perform I/O on an unconnected
			* tag.
			*/
			TAG_NOT_CONNECTED = -4;

			/**
			* An error code used by maNFCWriteNDEF if maNFCWriteNDEF was
			* performed on an NDEF_FORMATTABLE tag and failed.
			*/
			FORMAT_FAILED = -5;

			/**
			* An error code if some general I/O error occurred,
			* other than the special case of tag connection being lost.
			*/
			TAG_IO_ERROR = -127;

		}

		constset int MA_NFC_TAG_TYPE_ {

			/**
			* Represents an NDEF (NFC Data Exchange Format) tag.
			*/
			NDEF = 1;

			/**
			* Represents a Mifare Classic tag.
			*/
			MIFARE_CL = 2;

			/**
			* Represents a Mifare Ultralight tag.
			*/
			MIFARE_UL = 3;

			/**
			* Represents an NfcA tag (ISO 14443-3A).
			*/
			NFC_A = 4;

			/**
			* Represents an NfcB tag (ISO 14443-3B).
			*/
			NFC_B = 5;

			/**
			* Represents an ISO-DEP tag (ISO 14443-4).
			*/
			ISO_DEP = 6;

			/**
			* Represents an 'abstract' tag that can
			* accept requests for formatting it into
			* an NDEF tag.
			*/
			NDEF_FORMATTABLE = 128;
		}

		constset int MA_NFC_NDEF_TNF_ {

			/**
			* Indicates the NDEF message is empty.
			*/
			EMPTY = 0;

			/**
			* Indicates the NDEF message is of a 'well-known' type;
			* it may be further identified using the MA_NFC_NDEF_RTD_*
			* constants.
			*/
			WELL_KNOWN = 1;

			/**
			* Indicates the NDEF message contains mime media;
			* use maNFCGetType() to get the mime type.
			*/
			MIME_MEDIA = 2;

			/**
			* Indicates the NDEF message contains an absolute URI,
			* the type conforming to RFC 3986.
			*/
			ABSOLUTE_URI = 3;

			/**
			* Indicates the type of the NDEF message being 'external'.
			*/
			EXTERNAL_TYPE = 4;

			/**
			* Indicates the contents of the NDEF message to be of
			* an unknown type. The type of the NDEF message should
			* be empty.
			*/
			UNKNOWN = 5;

			/**
			* Constant for chunked NDEF messages.
			*/
			UNCHANGED = 6;

			/**
			* Reserved constant.
			*/
			RESERVED = 7;
		}

		constset int MA_NFC_MIFARE_ {

			/**
			* The A key for MiFare Classic authentication
			*/
			KEY_A = 1;

			/**
			* The B key for MiFare Classic authentication
			*/
			KEY_B = 2;

		}
	}//end of NFC API

	group DBAPI "Database API" {
		struct MADBBlob {
			MAAddress data;
			int size;
		}
		struct MADBText {
			MAString addr;
			/// Length in bytes of the string pointed to by \a addr.
			/// May be \< 0, in which case the string is null-terminated.
			int length;
		}

		constset int MA_DB_TYPE_ {
			NULL = 1;
			INT = 2;
			INT64 = 3;
			DOUBLE = 4;
			BLOB = 5;
			DATA = 6;
			TEXT = 7;
		}

		/// Input value for maDBExecSQLParams().
		struct MADBValue {
			union {
				int i;
				double d;
				MADBBlob blob;
				MAHandle dataHandle;
				MADBText text;
				longlong i64;
			}
			// has to be last. otherwise this struct would get an alignment mismatch
			// due to the double union member, which has to be 8-byte-aligned on x86 platforms.
			/// One of the MA_DB_TYPE_ constants.
			int type;
		}

		/**
		 * Open a database file. The database is created if it does not exist.
		 * \note The application needs file read/write permissions to
		 * access database files.
		 * @param path Absolute path to the database file.
		 * @return Handle to the database >0 on success, #MA_DB_ERROR on error.
		 */
		MAHandle maDBOpen(in MAString path);

		/**
		 * Close a database.
		 * @param databaseHandle Handle to the database.
		 * @return #MA_DB_OK on success, #MA_DB_ERROR on error.
		 */
		int maDBClose(in MAHandle databaseHandle);

		/**
		 * Executes an SQL statement. If the statement returns a
		 * query result, a cursor handle is returned.
		 * If a query result is empty, #MA_DB_OK is returned.
		 * @param databaseHandle Handle to the database.
		 * @param sql The SQL statement.
		 * @return #MA_DB_ERROR on error, #MA_DB_OK on success,
		 * > 0 if there is a cursor to a query result, in this
		 * case the return value is the cursor handle.
		 */
		MAHandle maDBExecSQL(in MAHandle databaseHandle, in MAString sql);

		/**
		 * @copydoc maDBExecSQL()
		 *
		 * @param params Array of values to bind to parameters.
		 * Parameters are specified by question marks (?) in the SQL statement.
		 *
		 * If this function returns a cursor, any text or blob values being
		 * pointed to by elements of the array must remain valid until the
		 * cursor has been destroyed by maDBCursorDestroy().
		 *
		 * The array itself does not need to remain valid after this
		 * function returns.
		 *
		 * @param paramCount Number of elements in the array pointed to
		 * by \a params.
		 *
		 * This function is available on iOS, Android, and in MoRE.
		 */
		MAHandle maDBExecSQLParams(in MAHandle databaseHandle, in MAString sql,
			in MADBValue params, in int paramCount);

		/**
		 * Destroys a cursor. You must call this function
		 * when you are done with the cursor to release
		 * its resources.
		 * @param cursorHandle Handle to the cursor.
		 * @return #MA_DB_OK on success, #MA_DB_ERROR on error.
		 */
		int maDBCursorDestroy(in MAHandle cursorHandle);

		/**
		 * Move the cursor to the next row in the result set.
		 * Note that you must call this function before retrieving
		 * column data. The initial position of the cursor is
		 * before the first row in the result set. If the result
		 * set is empty, this function will return #MA_DB_NO_ROW.
		 * @param cursorHandle Handle to the cursor.
		 * @return #MA_DB_OK if successfully moved to next row,
		 * #MA_DB_NO_ROW if there are no more rows in the result set,
		 * #MA_DB_ERROR on error.
		 */
		int maDBCursorNext(in MAHandle cursorHandle);

		/**
		 * Get the column value at the current row pointed to
		 * by the cursor as a data object. Use this function for
		 * blob data or text data.
		 * @param cursorHandle Handle to the cursor.
		 * @param columnIndex Index of the column to retrieve value from.
		 * First column has index zero.
		 * @param placeholder Handle created with maCreatePlaceholder.
		 * A data object will be created with the column data, and the handle
		 * will refer to that data.
		 * @return #MA_DB_OK on success, #MA_DB_NULL if the column value
		 * is NULL, #MA_#MA_DB_ERROR on error.
		 */
		int maDBCursorGetColumnData(
			in MAHandle cursorHandle,
			in int columnIndex,
			in MAHandle placeholder);

		/**
		 * Get the column value at the current row pointed to
		 * by the cursor as a text data buffer. Use this function for
		 * text data.
		 * @param cursorHandle Handle to the cursor.
		 * @param columnIndex Index of the column to retrieve value from.
		 * First column has index zero.
		 * @param buffer Pointer to buffer to receive the data.
		 * The result is NOT zero terminated.
		 * @param bufferSize Max size of the buffer.
		 * @return The actual length of the data, if the actual length
		 * returned is > bufferSize, data was not copied (buffer too small),
		 * returns #MA_DB_ERROR on other errors, returns #MA_DB_NULL if the
		 * column value is NULL.
		 */
		int maDBCursorGetColumnText(
			in MAHandle cursorHandle,
			in int columnIndex,
			out MAAddress buffer,
			in int bufferSize);

		/**
		 * Get the column value at the current row pointed to
		 * by the cursor as an int value.
		 * @param cursorHandle Handle to the cursor.
		 * @param columnIndex Index of the column to retrieve value from.
		 * First column has index zero.
		 * @param value Pointer to int to receive the value.
		 * @return #MA_DB_OK on success, #MA_DB_NULL if the column value
		 * is NULL, #MA_#MA_DB_ERROR on error.
		 */
		int maDBCursorGetColumnInt(
			in MAHandle cursorHandle,
			in int columnIndex,
			out int value);

		// todo: maDBCursorGetColumnInt64

		/**
		 * Get the column value at the current row pointed to
		 * by the cursor as a double value.
		 * @param cursorHandle Handle to the cursor.
		 * @param columnIndex Index of the column to retrieve value from.
		 * First column has index zero.
		 * @param value Pointer to double to receive the value.
		 * @return #MA_DB_OK on success, #MA_DB_NULL if the column value
		 * is NULL, #MA_#MA_DB_ERROR on error.
		 */
		int maDBCursorGetColumnDouble(
			in MAHandle cursorHandle,
			in int columnIndex,
			out double value);

		/**
		 * Status codes returned by the maDB functions.
		 */
		constset int MA_DB_ {
			/**
			 * Success return value.
			 */
			OK = 0;

			/**
			 * Error return value (-1 reserved for IOCtl not implemented).
			 */
			ERROR = -2;

			/**
			 * The cursor is beyond the last row
			 * when calling #maDBCursorNext.
			 */
			NO_ROW = -3;

			/**
			 * A database field value was NULL when calling
			 * the maDBCursorGetColumn* functions.
			 */
			NULL = -4;
		}
	} // End of Database API

	group AudioAPI "Audio API" {
		typedef int MAAudioData;
		typedef int MAAudioInstance;

		group AudioAPIConsts "Audio API Constants" {
			constset int MA_AUDIO_DATA_ {
				// Bit in maAudioDataCreate flags to specify if the sound should be streamed instead of fully decoded to memory.
				STREAM = 1;
			}

			constset int MA_AUDIO_ERR_ {
				OK = 0;
				// Invalid instance, the given MAAudioInstance can't do this
				INVALID_INSTANCE = -2;
				INVALID_DATA = -3;
				INVALID_FILENAME = -4;
				INVALID_FILE = -5;
				STREAMING_NOT_SUPPORTED = -6;
				VOLUME_OUT_OF_RANGE = -7;
				POSITION_OUT_OF_RANGE = -8;
				INVALID_SOUND_FORMAT = -9;
				OUT_OF_MEMORY = -10;
				ALREADY_PREPARED = -11;
				PREPARE_FAILED = -12;
				IS_PLAYING = -13;
				GENERIC = -14;
			}
		} // end of Audio API constants

		/**
		* The Audio API gives the developer more control over playing music and
		* and sound effects in MoSync applications.
		* The Audio API uses streaming and non-streaming audio sources.
		* The streaming could be songs for playing in the background in games.
		* The non-streaming sounds should instead be used as sound effects.
		* Please consider using short, as in a couple of seconds, samples in MP3
		* format instead of WAV due to differences between platforms and WAV
		* playback problems on Android.
		* @attention The Audio API is only available on Android and iOS!
		*/
		group AudioAPIFunctions "Audio API Functions" {

			/**
			* @brief Creates a MAAudioData handle from a MoSync resource.
			* @param mime 	The mime string for the resource. Can be NULL
			* @param data 	The binary resource
			* @param offset The offset in the binary file to where the data starts
			* @param length The length of the data to use
			* @param flags 	MA_AUDIO_DATA_STREAM means that the audio should be streamed
			*				either from disk or over HTTP. This is only for music playback,
			*				sound effects should have the flag set to 0.
			* @attention 	Windows Phone only supports wave-files (see remarks here: http://msdn.microsoft.com/en-us/library/microsoft.xna.framework.audio.soundeffect.fromstream.aspx).
			* @return A MAAudioData handle or <0 on error.
			*/
			MAAudioData maAudioDataCreateFromResource(in MAString mime, in MAHandle data, in int offset, in int length, in int flags);

			/**
			* @brief Creates a MAAudioData handle from an URL or file path.
			* @param mime 	The mime string for the resource. Can be NULL
			* @param url 	The URL to the resource file. Accepts 'http://' or 'http://' for
			*				streaming from internet. Without protcol file is assumed.
			* @param flags 	MA_AUDIO_DATA_STREAM means that the audio should be streamed
			*				either from disk or over HTTP. This is only for music playback,
			*				sound effects should have this flag set to 0.
			* @return 		A MAAudioData handle or <0 on error.
			* @attention 	iOS Only supports loading local files.
			*/
			MAAudioData maAudioDataCreateFromURL(in MAString mime, in MAString url, in int flags);

			/**
			* @brief Destroys a MAAudioData handle and releases used memory
			*
			* @param audioData 	The MAAudioData handle.
			* @return 			MA_AUDIO_ERR_OK on success or <0 on fail.
			*/
			int maAudioDataDestroy(in MAAudioData audioData);

			/**
			* @brief Creates a MAAudioInstance handle from a MAAudioData handle.
			*
			* @param audioData 	The MAAudioData handle
			*
			* @return 			A MAAudioInstance handle or <0 on error.
			*
			*/
			MAAudioInstance maAudioInstanceCreate(in MAAudioData audioData);

			/**
			* @brief Creates an MAAudioInstance that can be fed samples dynamically.
			*
			* @param sampleRate  The samplerate of the audio instance.
			* @param numChannels Number of channels for the audio instance (1 means mono, 2 means stereo).
			* @param bufferSize  The size of the underlying sample buffer (in samples).
			*
			* @return 			A MAAudioInstance handle or <0 on error.
			*
			*/
			MAAudioInstance maAudioInstanceCreateDynamic(in int sampleRate, in int numChannels, in int bufferSize);

			/**
			* @brief Submits a buffer of samples to a dynamic MAAudioInstance
			*
			* @param instance	The handle to the MAAudioInstance
			* @param buffer		A pointer to the samples that should be submitted. Each sample must be a signed 16-bit short. When using more than one channel, the samples should be interleaved.
			* @param numBytes	The number of bytes to read.
			* @return 			<0 on error.
			*
			*/
			int maAudioSubmitBuffer(in MAAudioInstance instance, in MAAddress buffer, in int numBytes);

			/**
			* @brief Gets the pending buffer count for the dynamic MAAudioInstance
			*
			* @param instance	The handle to the MAAudioInstance
			* @return 			<0 on error, otherwise the pending buffer count.
			*
			*/
			int maAudioGetPendingBufferCount(in MAAudioInstance instance);

			/**
			* @brief Destroys a MAAudioInstance handle releases used memory
			* @param audioInstance 	The MAAudioInstance handle
			* @return 				MA_AUDIO_ERR_OK on success,
			*						<0 on error.
			*/
			int maAudioInstanceDestroy(in MAAudioInstance audioInstance);

			/**
			* @brief Returns the lenght in milliseconds for this instance.
			* @param audio 	The MAAudioInstance handle
			* @return 		The lenght in milliseconds,
			*				<0 on error.
			*/
			int maAudioGetLength(in MAAudioInstance audio);

			/**
			* @brief Sets the number of loops this instance will play
			*
			* @param audio 	The MAAudioInstance handle
			* @param loops 	0 means play once,
			*				>0 means loop 'loops' times,
			* 				-1 means loop forever.
			* @return 		MA_AUDIO_ERR_OK on success, <0 on error.
			*/
			int maAudioSetNumberOfLoops(in MAAudioInstance audio, in int loops);

			/**
			* @brief Prepares an MAAudioInstance before playback.
			* If prepared asynchronous the call will return directly, but the
			* MAAudioInstance will not be ready for playback until
			* an EVENT_TYPE_AUDIO_PREPARED event has been sent.
			* If synchronous the call will block execution until finished
			* and the MAAudioInstance will be ready directly.
			* @attention 	If a streaming audio is already playing and a new one is being prepared,
			* 				on some platforms the playing audio will stop.
			*
			* @param audio The MAAudioInstance handle
			* @param async 0 if synchronus, 1 if asynchronous
			* @return 	MA_AUDIO_ERR_OK on success
			*		MA_AUDIO_ERR_INVALID_INSTANCE on invalid audio instance
			*		MA_AUDIO_ERR_ALREADY_PREPARED on already prepared audio instance
			*/
			int maAudioPrepare(in MAAudioInstance audio, in int async);

			/**
			* @brief Plays the current MAAudioInstance.
			* @attention 	If the audio hasn't been prepared, on Android, it will be synchrounous
			*				prepared before playing, this means that there might be a delay before
			*				this call returns. Always make sure that your audio has been properly
			*				prepared before playing.
			* @param audio The MAAudioInstance handle.
			* @return MA_AUDIO_ERR_OK on success, <0 on error.
			*/
			int maAudioPlay(in MAAudioInstance audio);

			/**
			* @brief Sets the current position in milliseconds.
			* @param audio 			The MAAudioInstance handle.
			* @param milliseconds 	The number of milliseconds from the start.
			* @return 				MA_AUDIO_ERR_OK on success,
			*						<0 on error.
			*/
			int maAudioSetPosition(in MAAudioInstance audio, in int milliseconds);

			/**
			* @brief Gets the current position in milliseconds.
			* @param audio 	The MAAudioInstance handle.
			* @return 		The current playing position in milliseconds,
			*				<0 on error.
			*/
			int maAudioGetPosition(in MAAudioInstance audio);

			/**
			* @brief Sets the volume for this MAAudioInstance.
			* @param audio 		The MAAudioInstance handle.
			* @return 			MA_AUDIO_ERR_OK on success,
			*					<0 on error
			*/
			int maAudioSetVolume(in MAAudioInstance audio, in float volume);

			/**
			* @brief Pauses the MAAudioInstance if it's playing.
			* It will stay prepared, so the sound can be resumed at any time using maAudioPlay.
			* @param audio The MAAudioInstance handle.
			* @return MA_AUDIO_ERR_OK on success, <0 on error.
			*/
			int maAudioPause(in MAAudioInstance audio);

			/**
			* @brief Stops the the audio instance and sets the position to the beginning.
			* The audio instance might be unprepared, meaning all it's prepared buffers might
			* be released.
			* @param audio The MAAudioInstance handle.
			* @return MA_AUDIO_ERR_OK on success, <0 on error.
			*/
			int maAudioStop(in MAAudioInstance audio);
		}// End of Audio API Functions
	} // End of Audio API group

	/**
	* Enable panics for programmer errors.
	* Such panics are enabled by default, but can be disabled by maSyscallPanicsDisable().
	* If a panic is raised a message will be displayed to the user and the program will be shut down.
	* \return #RES_OK.
	*/
	int maSyscallPanicsEnable();

	/**
	* Disable panics for programmer errors.
	* Some errors, such as feeding invalid parameters to certain syscalls,
	* can be prevented by the programmer. By default, these errors cause a MoSync Panic.
	* After this function is called,
	* if such an error occurs in a syscall, an error code will be returned by the syscall and the
	* program will continue running.
	* Panics can be re-enabled by maSyscallPanicsEnable().
	* \return #RES_OK.
	*/
	int maSyscallPanicsDisable();

group AdsAPI "Advertising API" {
	group AdsResultCodes "Ads result codes" {
		constset int MA_ADS_RES_ {
			/**
			* @brief Indicates that the call was successful.
			*/
			OK = 0;

			/**
			* @brief Indicates that the call to a maAdsAddBannerToScreen or maAdsRemoveBannerFromScreen received
			* an invalid layout handle.
			*/
			INVALID_LAYOUT_HANDLE = -1;

			/**
			* @brief Indicates that the call to a banner function received an invalid banner handle.
			*/
			INVALID_BANNER_HANDLE = -2;

			/**
			* @brief Indicates that the call to maAdsBannerSetProperty or maAdsBannerGetProperty received
			* an invalid property name.
			*/
			INVALID_PROPERTY_NAME = -3;

			/**
			* @brief Indicates that the call to maAdsBannerSetProperty or maAdsBannerGetProperty received
			* an invalid property value.
			*/
			INVALID_PROPERTY_VALUE = -4;

			/**
			* @brief Indicates that the call to maAdsBannerSetProperty needs a larger buffer.
			*/
			INVALID_STRING_BUFFER_SIZE = -5;

			/**
			* @brief Indicates that the call to an Ad syscall was unsuccessful.
			*/
			ERROR = -6;

			/**
			* @brief Indicates that ads are not supported on current platform.
			*/
			UNSUPPORTED = -7;
		}
	} // end of Ads Result Codes

	group AdsErrorCodes "Advertising error codes" {
		constset int MA_ADS_ERROR_ {
			/**
			* @brief Indicates that something happened internally: for instance, the Activity may have been destroyed mid-refresh.
			* Platform: Android.
			*/
			INTERNAL = -1;

			/**
			* @brief Indicates that the ad request is invalid.
			* Platform: Android.
			*/
			INVALID_REQUEST = -2;

			/**
			* @brief Indicates that the connection to the advertisements server failed.
			* Platform: Android, iOS and Windows Phone 7.1.
			*/
			NETWORK = -3;

			/**
			* @brief Indicates that no ad was returned due to lack of ad inventory.
			* Platform: Android, iOS and Windows Phone 7.1.
			*/
			NO_FILL = -4;

			/**
			* @brief Indicates that your application has not been configured to receive advertisements.
			* Platform: iOS.
			*/
			CONFIGURATION = -5;

			/**
			* @brief Indicates that the banner is visible, but no advertisement is shown.
			* Your application must always hide the banner when it does not have an advertisement to display.
			* Platform: iOS.
			*/
			NO_CONTENT = -6;

			/**
			* @brief Indicates that ad content is not available because the application is not currently active.
			* Platform: iOS.
			*/
			APPLICATION_INACTIVE = -7;
		}
	} // end of Ads Error Codes

	group AdsProperties "Advertising Properties" {
		constset MAString MA_ADS_ {
			/**
			* @brief Gets the height of the ads banner.
			* The view will have no size until the ad is loaded.
			*
			* @validvalue an int.
			*
			* @getonly
			*
			* @par Example
			* \code
			*   char buf[256];
			*	maAdsBannerGetProperty(MA_ADS_HEIGHT, buf);
			* \endcode
			*/
			HEIGHT = "height";

			/**
			* @brief Gets the width of the ads banner.
			* The view will have no size until the ad is loaded.
			*
			* @validvalue an int.
			*
			* @getonly
			*
			* @par Example
			* \code
			*    char buf[256];
			*	maAdsBannerGetProperty(MA_ADS_WIDTH, buf);
			* \endcode
			*/
			WIDTH = "width";

			/**
			* @brief Sets whether the banner is visible or not. Layouts ignore invisible widgets.
			* The banner is visible by default.
			*
			* @validvalue A boolean string 'true' or 'false', where true is visible and false is invisible.
			*
			* @setandget
			*
			* @par Example
			* \code
			*	maAdsBannerSetProperty(bannerHandle, MA_ADS_VISIBLE, "false");
			* \endcode
			*/
			VISIBLE = "visible";

			/**
			* @brief Sets whether the banner is enabled or not. If disabled, the user cannot interact with it.
			* Ads are enabled by default.
			*
			* @validvalue A boolean string 'true' or 'false', where true is enabled and false is disabled.
			*
			* @setandget
			*
			* @par Example
			* \code
			*	maAdsBannerSetProperty(bannerHandle, MA_ADS_ENABLED, "false");
			* \endcode
			*/
			ENABLED = "enabled";

			/**
			* @brief Sets the devices that are going to receive test ads only.
			* You should utilize this property during development to avoid generating false impressions.
			* Available only on Android.
			*
			* @validvalue String that holds the device ID.
			*
			* @setonly
			*
			* @par Example
			* \code
			*   char buf[256];
			*	maAdsBannerSetProperty(bannerHandle, MA_ADS_TEST_DEVICE, "E83D20734F72FB3108F104ABC0FFC738"); // My T-Mobile G1 test phone
			* \endcode
			*/
			TEST_DEVICE = "testDevice";

			/**
			* @brief Sets the request state of the ads.
			* If set to true ads are starting to be requested, if set to false the request for ads is stopped.
			* After requesting for content no other property setter will be taken into account.
			* @validvalue A boolean string 'true' or 'false'.
			* Available only on Android.
			*
			* @setonly
			*
			* @par Example
			* \code
			*	maAdsBannerSetProperty(bannerHandle, MA_ADS_REQUEST_CONTENT, "true");
			* \endcode
			*/
			REQUEST_CONTENT = "requestContent";

			/**
			* @brief Returns true if the ad is successfully loaded and is ready to be shown.
			* Available only on Android.
			*
			* @validvalue A boolean string 'true' or 'false'.
			*
			* @getonly
			*
			* @par Example
			* \code
			*   char buf[256];
			*	maAdsBannerGetProperty(bannerHandle, MA_ADS_IS_READY, buf);
			* \endcode
			*/
			IS_READY = "isReady";

			/**
			* @brief Sets the coloration of test ads, specifically the background color.
			*
			* @validvalue A hexadecimal value 0xRRGGBB, where R, G and B are the red, green and blue components respectively.
			*
			* @setonly
			*
			* @par Example
			* \code
			*	maAdsBannerSetProperty(bannerHandle, MA_ADS_COLOR_BG, "0xAAAAFF");
			* \endcode
			*/
			COLOR_BG = "colorBg";

			/**
			* @brief Sets the coloration of test ads,specifically the gradient background color at top.
			*
			* @validvalue A hexadecimal value 0xRRGGBB, where R, G and B are the red, green and blue components respectively.
			*
			* @setonly
			*
			* @par Example
			* \code
			*	maAdsBannerSetProperty(bannerHandle, MA_ADS_COLOR_BG_TOP, "0xFFFFFF");
			* \endcode
			*/
			COLOR_BG_TOP = "colorBgTop";

			/**
			* @brief Sets the coloration of test ads, specfiically the border color.
			*
			* @validvalue A hexadecimal value 0xRRGGBB, where R, G and B are the red, green and blue components respectively.
			*
			* @setonly
			*
			* @par Example
			* \code
			*   char buf[256];
			*	maAdsBannerSetProperty(bannerHandle, MA_ADS_COLOR_BORDER, "0xFFFFFF");
			* \endcode
			*/
			COLOR_BORDER = "colorBorder";

			/**
			* @brief Sets the coloration of test ads, specfiically the link text color.
			*
			* @validvalue A hexadecimal value 0xRRGGBB, where R, G and B are the red, green and blue components respectively.
			*
			* @setonly
			*
			* @par Example
			* \code
			*   char buf[256];
			*	maAdsBannerSetProperty(bannerHandle, MA_ADS_COLOR_LINK, "0xFFFFFF");
			* \endcode
			*/
			COLOR_LINK = "colorLink";

			/**
			* @brief Sets the coloration of test ads, specfiically the text color.
			*
			* @validvalue A hexadecimal value 0xRRGGBB, where R, G and B are the red, green and blue components respectively.
			*
			* @setonly
			*
			* @par Example
			* \code
			*   char buf[256];
			*	maAdsBannerSetProperty(bannerHandle, MA_ADS_COLOR_TEXT, "0xFFFFFF");
			* \endcode
			*/
			COLOR_TEXT = "colorText";

			/**
			* @brief Sets the coloration of test ads, specfiically the url color.
			*
			* @validvalue A hexadecimal value 0xRRGGBB, where R, G and B are the red, green and blue components respectively.
			*
			* @setonly
			*
			* @par Example
			* \code
			*   char buf[256];
			*	maAdsBannerSetProperty(bannerHandle, MA_ADS_COLOR_URL, "0xFFFFFF");
			* \endcode
			*/
			COLOR_URL = "colorUrl";
		}
	} // end of Ads properties

	group AdsConstants "Advertising Constants" {
		constset int MA_ADS_SIZE_ {
			// An Ad can be created ony with those predefined sizes.
			// This is the default banner of size 320*50.
			BANNER = 0;
			// Standard medium rectange of size 300*250.
			// Availabe only on Android.
			RECT = 1;
			// Full size banner of size 468*60.
			// Availabe only on Android.
			IAB_BANNER = 2;
			// Of size 728*90.
			// Availabe only on Android.
			LEADERBOARD = 3;
			// Of size 300*50 - X-Large Banner
			// Available only on Windows Phone 7.1.
			WP7_XLARGE = 4;
			// Of size 480*80 - XX-Large Banner
			// Available only on Windows Phone 7.1
			WP7_XXLARGE = 5;

		}
	} // end of Ads Constants

	group AdsEventTypes "Advertising Event Types" {
		constset int MA_ADS_EVENT_ {
			// This event is send when a banner view fails to load a new advertisement.
			FAILED = 0;
			// This event is send when a new banner advertisement is loaded.
			LOADED = 1;
			// This event is send after a banner view finishes executing an action that
			// covered your application's user interface.
			// Event not available on windows phone 7.1 on the AdControl
			ON_DISMISS = 2;
			// This event is send when the user taps the banner view.
			// The application is moved to background after this event is send.
			ON_LEAVE_APPLICATION = 3;
		}
	} // end of Ads Constants

	group AdsFunctions "Advertising Functions" {
		/**
		* \brief Creates a new banner.
		* \param bannerSize One of the MA_ADS_SIZE_ constants. Only for Android and WP7.1 platforms.
		* \param publisherID Only for Android and WP 7.1 platforms.
		* This param is ignored on iOS platform.
		*
		* \note A banner is a widget type object.
		* For more info see Widget API.
		*
		* \returns
		*  - #MA_ADS_RES_UNSUPPORTED if ads are not supported on current system.
		*  - #MA_ADS_RES_ERROR if a error occurred while creating the banner widget.
		*  - a handle to a new banner widget(the handle value is >= 0).
		*/
		int maAdsBannerCreate(in int bannerSize, in MAString publisherID);

		/**
		* \brief Destroy a banner.
		*
		* \param bannerHandle Handle to a banner.
		*
		* \returns One of the next constants:
		* - #MA_ADS_RES_OK if no error occurred.
		* - #MA_ADS_RES_INVALID_BANNER_HANDLE if the banner handle is invalid.
		*/
		int maAdsBannerDestroy(in MAHandle bannerHandle);

		/**
		* \brief Add a banner to a layout widget.
		*
		* \param bannerHandle Handle to a banner.
		* \param layoutHandle Handle to a layout.
		*
		* \returns One of the next constants:
		* - #MA_ADS_RES_OK if no error occurred.
		* - #MA_ADS_RES_INVALID_BANNER_HANDLE if the banner handle is invalid.
		* - #MA_ADS_RES_INVALID_LAYOUT_HANDLE if the layout handle is invalid.
		*/
		int maAdsAddBannerToLayout(in MAHandle bannerHandle, in MAHandle layoutHandle);

		/**
		* \brief Remove a banner from a layout widget.
		*
		* \param bannerHandle Handle to a banner.
		* \param layoutHandle Handle to a layout.
		*
		* \returns One of the next constants:
		* - #MA_ADS_RES_OK if no error occurred.
		* - #MA_ADS_RES_INVALID_BANNER_HANDLE if the banner handle is invalid.
		* - #MA_ADS_RES_INVALID_LAYOUT_HANDLE if the layout handle is invalid.
		*/
		int maAdsRemoveBannerFromLayout(in MAHandle bannerHandle, in MAHandle layoutHandle);

		/**
		* \brief Set a banner property.
		*
		* \param bannerHandle Handle to the banner.
		* \param property A string representing which property to set.
		* \param value The value that will be assigned to the property.
		*
		* \returns One of the next result codes:
		* - #MA_ADS_RES_OK if no error occurred.
		* - #MA_ADS_RES_INVALID_BANNER_HANDLE if the banner handle is invalid.
		* - #MA_ADS_RES_INVALID_PROPERTY_NAME if the property name is not valid.
		* - #MA_ADS_RES_INVALID_PROPERTY_VALUE if the property value is not valid.
		*/
		int maAdsBannerSetProperty(in MAHandle bannerHandle, in MAString property, in MAString value);

		/**
		* \brief Retrieves a specified property from the given banner.
		*
		* \param bannerHandle Handle to the banner.
		* \param property A string representing for which property to get the value.
		* \param value A buffer that will hold the value of the property, represented as a string.
		* \param bufSize Size of the buffer.
		*
		* \returns One of the next result codes:
		* - #MA_ADS_RES_OK if no error occurred.
		* - #MA_ADS_RES_INVALID_BANNER_HANDLE if the banner handle is invalid.
		* - #MA_ADS_RES_INVALID_PROPERTY_NAME if the property name is not valid.
		* - #MA_ADS_RES_INVALID_STRING_BUFFER_SIZE if the buffer size was to small.
		*/
		int maAdsBannerGetProperty(in MAHandle bannerHandle, in MAString property, out MAString value range("bufSize"), in int bufSize);
	}//End of Ads Functions
} // End of Ads API

group NotificationAPI "Notification API" {
	group NotificationResultCodes "Notification result codes" {
		constset int MA_NOTIFICATION_RES_ {
			/**
			* @brief Indicates that the call was successful.
			*/
			OK = 0;

			/**
			* @brief Indicates that the syscall received an invalid local notification handle.
			*/
			INVALID_HANDLE = -1;

			/**
			* @brief Indicates that the call to maNotificationLocalSetProperty or maNotificationLocalGetProperty received
			* an invalid property name.
			*/
			INVALID_PROPERTY_NAME = -3;

			/**
			* @brief Indicates that the call to maNotificationLocalSetProperty or maNotificationLocalGetProperty received
			* an invalid property value.
			*/
			INVALID_PROPERTY_VALUE = -4;

			/**
			* @brief Indicates that the call to maNotificationLocalGetProperty or maNotificationPushGetData needs a larger buffer.
			*/
			INVALID_STRING_BUFFER_SIZE = -5;

			/**
			* @brief Indicates that notifications are not supported on current platform.
			*/
			UNSUPPORTED = -6;

			/**
			* @brief Indicates that maNotficationLocalSetProperty cannot be called after scheduling via
			* maNotificationLocalSchedule, or that the call to maNotificationLocalSchedule failed because
			* the notification was already scheduled.
			*/
			ALREADY_SCHEDULED = -7;

			/**
			* @brief Indicates that the call to maNotificationLocalUnschedule failed because the notification
			* was not scheduled.
			*/
			CANNOT_UNSCHEDULE = -8;

			/**
			* @brief Indicates that the call to maNotificationPushRegister was unsuccessful because
			* the application is already registered for receiving push notification.
			*/
			ALREADY_REGISTERED = -9;

			/**
			* @brief Indicates that the call to maNotificationPushUnregister was unsuccessful because
			* the application is not registered for receiving push notification.
			*/
			NOT_REGISTERED = -10;

			/**
			* @brief Indicates that the call to maNotificationPushRegister was unsuccessful because
			* the application did not finish processing a previous registration request.
			*/
			REGISTRATION_IN_PROGRESS = -11;

			/**
			* @brief Indicates that the call to maNotificationPushRegister was unsuccesfull because the
			* device can't read the response, or there was a 500/503 from the server that can be retried later.
			* The application should use exponential back off and retry.
			* Platform: Android only.
			*/
			REGISTRATION_SERVICE_NOT_AVAILABLE = -12;

			/**
			* @brief Indicates that the call to maNotificationPushRegister was unsuccesfull because there is no
			* Google account on the phone.
			* The application should ask the user to open the account manager and add a Google account.
			* Platform: Android only.
			*/
			REGISTRATION_ACCOUNT_MISSING = -13;

			/**
			* @brief Indicates that the call to maNotificationPushRegister was unsuccesfull because the password was bad.
			* The application should ask the user to enter his/her password, and let user retry manually later.
			* Platform: Android only.
			*/
			REGISTRATION_AUTHENTICATION_FAILED = -14;

			/**
			* @brief Indicates that the call to maNotificationPushRegister was unsuccesfull because the user has too many
			* applications registered.
			* The application should tell the user to uninstall some other applications, let user retry manually.
			* Platform: Android only.
			*/
			REGISTRATION_TOO_MANY_REGISTRATIONS = -15;

			/**
			* @brief Indicates that the call to maNotificationPushRegister was unsuccesfull because the sender account
			* is not recognized.
			* Platform: Android only.
			*/
			REGISTRATION_INVALID_SENDER = -16;

			/**
			* @brief  Indicates that the call to maNotificationPushRegister was unsuccesfull because of incorrect
			* phone registration with Google. This phone doesn't currently support GCM/C2DM.
			* Platform: Android only.
			*/
			REGISTRATION_PHONE_REGISTRATION_ERROR = -17;

			/**
			* @brief Indicates that the call to maNotificationPushGetRegistration needs a larger buffer.
			*/
			REGISTRATION_MESSAGE_BUF_TOO_SMALL = -18;

			/**
			* @brief Indicates that the call to maNotificationPushGetRegistration occured before trying to register.
			*/
			REGISTRATION_NOT_CALLED = -19;

			/**
			* @brief Indicates that the call to an notification syscall was unsuccessful.
			*/
			ERROR = -20;
		}
	} // end of Notification Result Codes

	group NotificationFlags "Notification Flags" {
		constset int MA_NOTIFICATION_FLAG_ {
			/**
			* If set, the audio will be repeated until the notification is canceled or the
			* notification window is opened.
			* Platform: Android only.
			*/
			INSISTENT = 4;

			/**
			* Should be set if the notification should not be canceled when the user clicks the
			* Clear all button.
			* Platform: Android only.
			*/
			NO_CLEAR = 32;

			/**
			* Should be set if this notification represents a high-priority event that may be shown to
			* the user even if notifications are otherwise unavailable (that is, when the status bar is hidden).
			* Platform: Android only.
			*/
			HIGH_PRIORITY = 128;

			/**
			* Should be set if the notification should be canceled when it is clicked by the user.
			* Platform: Android only.
			*/
			AUTO_CANCEL = 16;
		}
	} // end of Notification Flags

		group NotificationDisplayFlags "Notification Display Flags" {
		constset int MA_NOTIFICATION_DISPLAY_FLAG_ {
			/**
			* For local notifications: if set, the incoming notifications will be displayed to
			* the user only if the application is in background.
			* @deprecated for local notifications.
			* For push notifications: if set, the incoming notifications will be displayed to
			* the user only if the application is not in use.
			* Note that the received push notification event will always be received regardless
			* of this flag.
			* This setting is enabled by default.
			* Platform: Android only.
			*/
			DEFAULT = 0;

			/**
			* If set, all the incoming notification will be displayed to the user regardless of
			* it's focus state.
			* For local notifications: this means that the user will get the notifications when the
			* application is in background, but also in foreground.
			* For push notifications: this means that the user will get the notifications when the
			* application is closed, but also when it's in use.
			* Note that the  event will always be received regardless of this flag.
			* Platform: Android only.
			*/
			ANYTIME = 1;
		}
	} // end of Notification Display Flags

	group NotificationPushTypes "Notification Push Types" {
		constset int MA_NOTIFICATION_PUSH_TYPE_ {
			/**
			* @brief The application accepts notifications that badge the application icon.
			* Platform: iOS only.
			*/
			BADGE = 1;

			/**
			* @brief The application accepts alert sounds as notifications.
			* Platform: iOS only.
			*/
			SOUND = 2;

			/**
			* @brief The application accepts alert messages as notifications.
			* This is the only push notification type that is supported by
			* both Android and iOS.
			*/
			ALERT = 4;
		}
	} // end of Notification Push Types

	group LocalNotificationProperties "Local Notification Properties" {
		constset MAString MA_NOTIFICATION_LOCAL_ {
			/**
			* @brief Set the number displayed on the application's icon badge.
			* Platform: iOS.
			*
			* @validvalue an int.
			*
			* @setandget
			*
			* @par Example
			* \code
			*   char buf[256];
			*	maNotificationLocalGetProperty(notificationHandle, MA_NOTIFICATION_LOCAL_BADGE_NUMBER, buf);
			* \endcode
			*/
			BADGE_NUMBER = "badge_number";

			/**
			* @brief Set the date and time when the system should deliver the notification.
			* The notification will be fired when the system time is equal to the
			* given param time value.
			*
			* @validvalue an int.
			* The date is in seconds(UNIX time - seconds elapsed since January 1, 1970).
			* The value should be given according to device system time.
			*
			* @setandget
			*
			* @par Example
			* \code
			*   char buf[256];
			*	maNotificationLocalGetProperty(notificationHandle, MA_NOTIFICATION_LOCAL_FIRE_DATE, buf);
			* \endcode
			*/
			FIRE_DATE = "fire_date";

			/**
			* @brief Set the message displayed in the notification alert.
			* Platform: Android and iOS.
			*
			* @validvalue an string.
			*
			* @setandget
			*
			* @par Example
			* \code
			*	maNotificationLocalSetProperty(notificationHandle, MA_NOTIFICATION_LOCAL_CONTENT_BODY, "Did you forget something?");
			* \endcode
			*/
			CONTENT_BODY = "content_body";

			/**
			* @brief Set the title of the action button or slider.
			* Platform: iOS.
			*
			* @validvalue a string.
			*
			* @setandget
			*
			* @par Example
			* \code
			*	maNotificationLocalSetProperty(notificationHandle, MA_NOTIFICATION_LOCAL_ALERT_ACTION, "Show");
			* \endcode
			*/
			ALERT_ACTION = "alert_action";

			/**
			* @brief Enable/disable the sound played when an alert is displayed.
			* Platform: iOS and Android.
			* If set to true, it will play the default sound.
			*
			* @validvalue "true" or "false" strings.
			*
			* @setandget
			*
			* @par Example
			* \code
			*	maNotificationLocalSetProperty(notificationHandle, MA_NOTIFICATION_LOCAL_PLAY_SOUND, "true");
			* \endcode
			*/
			PLAY_SOUND = "play_sound";

			/**
			* @brief Set the sound to play when an alert is displayed.
			* The sound file should be saved in a notifications folder under sdcard storage.
			* Note that some devices can only play notification sounds stored in the internal storage,
			* in the \system\media\audio\notifications folder.
			* Platform: Android.
			*
			* @validvalue a valid path to an audio file.
			*
			* @setandget
			*
			* @par Example
			* \code
			*	maNotificationLocalSetProperty(notificationHandle, MA_NOTIFICATION_LOCAL_SOUND_PATH, "....");
			* \endcode
			*/
			SOUND_PATH = "soundPath";

			/**
			* @brief Set the title that goes in the expanded entry of the notification.
			* Platform: Android.
			*
			* @validvalue a string.
			*
			* @setandget
			*
			* @par Example
			* \code
			*     maNotificationLocalSetProperty(notificationHandle, MA_NOTIFICATION_LOCAL_CONTENT_TITLE, "My message");
			* \endcode
			*/
			CONTENT_TITLE = "contentTitle";

			/**
			* @brief The text that flows by in the status bar when the notification first activates.
			* Platform: Android.
			*
			* @validvalue a string.
			*
			* @setandget
			*
			* @par Example
			* \code
			*     maNotificationLocalSetProperty(notificationHandle, MA_NOTIFICATION_LOCAL_TICKER_TEXT, "You got new message");
			* \endcode
			*/
			TICKER_TEXT = "tickerText";

			/**
			* @brief Set the flags applied to the local notification.
			* Platform: Android.
			*
			* @validvalue One of the constants:
			* - #MA_NOTIFICATION_FLAG_INSISTENT
			* - #MA_NOTIFICATION_FLAG_AUTO_CANCEL
			* - #MA_NOTIFICATION_FLAG_HIGH_PRIORITY
			* - #MA_NOTIFICATION_FLAG_NO_CLEAR.
			*
			* @setonly
			*
			* @par Example
			* \code
			*     maNotificationLocalSetProperty(notificationHandle, MA_NOTIFICATION_LOCAL_FLAG, MA_NOTIFICATION_FLAG_AUTO_CANCEL);
			* \endcode
			*/
			FLAG = "flag";

			/**
			* @brief Set the display flag applied to the local notification.
			* @deprecated. Not required anymore, since the local notification is received regardless of the applications's state.
			* Note the regardless of this flag, the #EVENT_TYPE_LOCAL_NOTIFICATION event will be received.
			* Platform: Android.
			*
			* @validvalue One of the constants:
			* - #MA_NOTIFICATION_DISPLAY_FLAG_DEFAULT Which is enabled by default.
			* - #MA_NOTIFICATION_DISPLAY_FLAG_ANYTIME.
			*
			* @setonly
			*
			* @par Example
			* \code
			*    // Display the notification even when the application is in foreground.
			*    maNotificationLocalSetProperty(notificationHandle, MA_NOTIFICATION_LOCAL_DISPLAY_FLAG, MA_NOTIFICATION_DISPLAY_FLAG_ANYTIME);
			* \endcode
			*/
			DISPLAY_FLAG = "displayFlag";

			/**
			* @brief Enable/disable the the default vibration when an alert is displayed.
			* Platform: Android only.
			* If set to true, it will use the default notification vibrate. This will ignore any given vibrate.
			* Using phone vibration requires the VIBRATE permission.
			*
			* @validvalue "true" or "false" strings.
			*
			* @setandget
			*
			* @par Example
			* \code
			*	maNotificationLocalSetProperty(notificationHandle, MA_NOTIFICATION_LOCAL_VIBRATE, "true");
			* \endcode
			*/
			VIBRATE = "vibrate";

			/**
			* @brief Set the vibration duration when an alert is displayed.
			* Platform: Android only.
			* Using phone vibration requires the VIBRATE permission.
			*
			* @validvalue an int The number of milliseconds to vibrate.
			*
			* @setonly
			*
			* @par Example
			* \code
			*   // Vibrate for 3 seconds.
			*	maNotificationLocalSetProperty(notificationHandle, MA_NOTIFICATION_LOCAL_VIBRATE_DURATION, "3000");
			* \endcode
			*/
			VIBRATE_DURATION = "vibrateDuration";

			/**
			* @brief Enable/Disable the default notification lights.
			* This will ignore the #MA_NOTIFICATION_LOCAL_FLASH_LIGHTS_PATTERN.
			* Not every color in the spectrum is supported by the device LEDs, and not every device supports the same
			* colors, so the hardware estimates to the best of its ability. Green is the most common notification color.
			* Platform: Android only.
			*
			* @validvalue "true" or "false" strings.
			*
			* @setandget
			*
			* @par Example
			* \code
			*	maNotificationLocalSetProperty(notificationHandle, MA_NOTIFICATION_LOCAL_FLASH_LIGHTS, "true");
			* \endcode
			*/
			FLASH_LIGHTS = "flashLights";

			/**
			* @brief Define your own color and pattern for the lights.
			* Not every color in the spectrum is supported by the device LEDs, and not every device supports the same
			* colors, so the hardware estimates to the best of its ability. Green is the most common notification color.
			* Also, not all Android devices support this feature.
			* Platform: Android only.
			*
			* @validvalue An int array containing 3 values:
			* - a value for the ledARGB field (for the color),
			* - the ledOffMS field (length of time, in milliseconds, to keep the light off),
			* - the ledOnMS (length of time, in milliseconds, to keep the light on).
			*  returns #MA_NOTIFICATION_RES_ERROR if the current device doesn't support flashing LED.
			* @setonly
			*
			* @par Example
			* \code
			* 	// In this example, the green light repeatedly flashes on for 300 milliseconds and turns off for one second.
			*	maNotificationLocalSetProperty(notificationHandle, MA_NOTIFICATION_LOCAL_FLASH_LIGHTS_PATTERN, "0xff00ff00,300,1000");
			* \endcode
			*/
			FLASH_LIGHTS_PATTERN = "flashLightsPattern";
		}
	} // end of Notification Properties

	group NotificationPushStruct "Push Notification Struct" {
		/**
		* \brief An push notification event.
		*/
		struct MAPushNotificationData {
			/// A bit mask specifying the types of notifications.
			/// The bit mask is created using \link #MA_NOTIFICATION_PUSH_TYPE_BADGE
			/// MA_NOTIFICATION_PUSH_TYPE \endlink type values.
			/// Specific to iOS. On Android it will be #MA_NOTIFICATION_PUSH_TYPE_ALERT.
			int type;

			/// The  buffer that will contain the message displayed in the notification alert,
			/// or the notification content on Android.
			/// This buffer will be filled only if the type is MA_NOTIFICATION_PUSH_TYPE_ALERT.
			/// Platform: iOS and Android.
			MAString alertMessage;

			/// The size of the buffer that will contain the notification alert message.
			int alertMessageSize;

			/// The address to a buffer that will contain the name of the file containing
			/// the sound to play when an alert is displayed.
			/// This buffer will be filled only if the type is MA_NOTIFICATION_PUSH_TYPE_SOUND.
			/// Platform: iOS only.
			MAString soundFileName;

			/// The size of the buffer that will contain the sound filename.
			int soundFileNameSize;

			/// Will contain the number to display as the applications icon badge.
			/// This value will be set only if the type is MA_NOTIFICATION_PUSH_TYPE_BADGE.
			/// Platform: iOS only.
			int badgeIcon;
		}
	} // end of Push Notification Struct

	group NotificationFunctions "Notification Functions" {
		/**
		* \brief Creates a new local notification object.
		*
		* \returns
		*  - #MA_NOTIFICATION_RES_UNSUPPORTED if the notifications are not supported on current system.
		*  - #MA_NOTIFICATION_RES_ERROR if a error occurred while creating the notification object.
		*  - a handle to a new local notification object(the handle value is >= 0).
		*/
		MAHandle maNotificationLocalCreate();

		/**
		* \brief Destroy a local notification object.
		*
		* \param notificationHandle Handle to a local notification object.
		*
		* \returns One of the next constants:
		* - #MA_NOTIFICATION_RES_OK if no error occurred.
		* - #MA_NOTIFICATION_RES_INVALID_HANDLE if the notificationHandle is invalid.
		*/
		int maNotificationLocalDestroy(in MAHandle notificationHandle);

		/**
		* \brief Set a local notification property.
		*
		* \param notificationHandle Handle to the local notification object.
		* \param property A string representing which property to set.
		* \param value The value that will be assigned to the property.
		*
		* \returns One of the next result codes:
		* - #MA_NOTIFICATION_RES_OK if no error occurred.
		* - #MA_NOTIFICATION_RES_INVALID_HANDLE if the notificationHandle is invalid.
		* - #MA_NOTIFICATION_RES_INVALID_PROPERTY_NAME if the property name is not valid.
		* - #MA_NOTIFICATION_RES_INVALID_PROPERTY_VALUE if the property value is not valid.
		* - #MA_NOTIFICATION_RES_ALREADY_SCHEDULED if the notification is scheduled.
		*/
		int maNotificationLocalSetProperty(in MAHandle notificationHandle, in MAString property, in MAString value);

		/**
		* \brief Retrieves a specified property from the given notification object.
		*
		* \param notificationHandle Handle to the notification object.
		* \param property A string representing for which property to get the value.
		* \param value A buffer that will hold the value of the property, represented as a string.
		* \param bufSize Size of the buffer.
		*
		* \returns One of the next result codes:
		* - #MA_NOTIFICATION_RES_OK if no error occurred.
		* - #MA_NOTIFICATION_RES_INVALID_HANDLE if the notificationHandle is invalid.
		* - #MA_NOTIFICATION_RES_INVALID_PROPERTY_NAME if the property name is not valid.
		* - #MA_NOTIFICATION_RES_INVALID_STRING_BUFFER_SIZE if the buffer size was to small.
		*/
		int maNotificationLocalGetProperty(in MAHandle notificationHandle, in MAString property,
								   out MAString value range("bufSize"), in int bufSize);

		/**
		* \brief Schedules a local notification for delivery at its encapsulated date and time.
		* The local notification is displayed regardless of the applications's state.
		* By default, the notifications are displayed to the user only if the application is
		* in background. But on Android you can configure this by setting the
		* #MA_NOTIFICATION_LOCAL_DISPLAY_FLAG property.
		*
		* \param notificationHandle Handle to a local notification object.
		*
		* \returns One of the next constants:
		* - #MA_NOTIFICATION_RES_OK if no error occurred.
		* - #MA_NOTIFICATION_RES_INVALID_HANDLE if the notificationHandle is invalid.
		* - #MA_NOTIFICATION_RES_ALREADY_SCHEDULED if the notification was already scheduled.
		*/
		int maNotificationLocalSchedule(in MAHandle notificationHandle);

		/**
		* \brief Cancels the delivery of the specified scheduled local notification.
		* Calling this method also programmatically dismisses the notification if
		* it is currently displaying an alert.
		*
		* \param notificationHandle Handle to a local notification object.
		*
		* \returns One of the next constants:
		* - #MA_NOTIFICATION_RES_OK if no error occurred.
		* - #MA_NOTIFICATION_RES_INVALID_HANDLE if the notificationHandle is invalid.
		* - #MA_NOTIFICATION_RES_CANNOT_UNSCHEDULE if the notification was not scheduled.
		*/
		int maNotificationLocalUnschedule(in MAHandle notificationHandle);

		/**
		* \brief Registers the current application for receiving push notifications.
		* Note that on Android you might want to store the registrationID that you receive,
		* and call this again only if it expires at some point.
		* On Android: if the registration is succesfful, the application receives a registration ID.
		* The application should store this ID for later use. Note that Google may periodically refresh
		* the registration ID, so you should design your application with the understanding that this
		* syscall  may be called multiple times.
		* \param pushNotificationTypes A bit mask specifying the types of notifications
		* the application accepts.
		* See \link #MA_NOTIFICATION_PUSH_TYPE_BADGE MA_NOTIFICATION_PUSH_TYPE_ \endlink
		* for valid bit-mask values.
		* On Android platform this param is ignored.
		* \param senderId Your projectId obtained from here:
		* http://developer.android.com/guide/google/gcm/gs.html#create-proj
		* For old applications, this param was set as the ID of the account
		* authorized to send messages to the application, typically the email
		* address of an account set up by the application's developer.
		* Even though setting the senderId as the accountID was deprecated, old
		* Android applications still support it.
		* On iOS platform this param is ignored.
		*
		* Example: maNotificationPushRegister(
		* PUSH_NOTIFICATION_TYPE_BADGE | PUSH_NOTIFICATION_TYPE_ALERT, "yoursenderId_here");
		*
		* \returns One of the next constants:
		* - #MA_NOTIFICATION_RES_OK if no error occurred.
		* - #MA_NOTIFICATION_RES_ALREADY_REGISTERED if the application is already registered for
		* receiving push notifications.
		* - #MA_NOTIFICATION_RES_UNSUPPORTED if notifications are not supported on current platform.
		*/
		int maNotificationPushRegister(in MAHandle pushNotificationTypes, in MAString senderId);

		/**
		* \brief Unregister application for push notifications.
		*
		* \returns One of the next constants:
		* - #MA_NOTIFICATION_RES_OK if no error occurred.
		* - #MA_NOTIFICATION_RES_NOT_REGISTERED if the application was not registered for receiving
		* push notification.
		*/
		int maNotificationPushUnregister();

		/**
		* \brief Gets the latest push notification registration response.
		* \param registrationMesssage The registrationID if the registration was successfull, or the error messsage otherwise.
		* \param registrationMessageSize Size of the buffer.
		* \returns  One of the next constants:
		* - #MA_NOTIFICATION_RES_OK if the application registered successfully.
		* - #MA_NOTIFICATION_RES_REGISTRATION_NOT_CALLED if maNotificationPushRegister was not called.
		* - #MA_NOTIFICATION_RES_REGISTRATION_MESSAGE_BUF_TOO_SMALL if the buffer is too small.
		* - #MA_NOTIFICATION_RES_ERROR if registration has failed.
		*/
		int maNotificationPushGetRegistration(out MAString registrationMesssage range("registrationMessageSize"),
											 in int registrationMessageSize);

		/**
		* \brief Fills pushNotificationData struct with the values for a given push notification.
		* Note: Call maNotificationPushDestroy() in order to destroy the push notification object.
		*
		* \param pushNotificationHandle Handle to a given push notification.
		* \param pushNotificationData A struct that will contain the values for a given push notification.
		*
		* \return One of the next contants:
		* - #MA_NOTIFICATION_RES_OK if no error occurred.
		* - #MA_NOTIFICATION_RES_INVALID_HANDLE if the pushNotificationHandle is invalid.
		* - #MA_NOTIFICATION_RES_INVALID_STRING_BUFFER_SIZE if at least one of the buffers from
		* pushNotificationData are too small.
		*/
		int maNotificationPushGetData(in MAHandle pushNotificationHandle,
									  out MAPushNotificationData pushNotificationData);

		/**
		* \brief Destroy a push notification object.
		*
		* \param notificationHandle Handle to a push notification object.
		*
		* \returns One of the next constants:
		* - #MA_NOTIFICATION_RES_OK if no error occurred.
		* - #MA_NOTIFICATION_RES_INVALID_HANDLE if the notificationHandle is invalid.
		*/
		int maNotificationPushDestroy(in MAHandle notificationHandle);

		/**
		* \brief Set the number currently set as the badge of the application icon in Springboard.
		* Platform: iOS only.
		*
		*\param applicationIconBadgeNumber Set to zero to hide the badge number. The default is zero.
		* If this value is negative the syscall will do nothing.
		*/
		void maNotificationSetIconBadge(in int applicationIconBadgeNumber);

		/**
		* \brief Get the number currently set as the badge of the application icon in Springboard.
		* Platform: iOS only.
		*
		*\return The number displayed as the badge of the application.
		*/
		int maNotificationGetIconBadge();

		/**
		* \brief Set the ticker text in the notification status bar for incoming push notifications.
		* This call does not alter already received notifications.
		* Platform: Android only.
		*
		* \param tickerText The text that flows by in the status bar when the notification first activates.
		* \return One of the next constants:
		* - #MA_NOTIFICATION_RES_OK if no error occurred.
		* - #MA_NOTIFICATION_RES_ERROR.
		*/
		int maNotificationPushSetTickerText(in MAString tickerText);

		/**
		* \brief Set the  message title in the notification area for incoming push notifications.
		* This call does not alter already received notifications.
		* Platform: Android only.
		*
		* \param messageTitle The title that goes in the expanded entry of the notification.
		* \return One of the next constants:
		* - #MA_NOTIFICATION_RES_OK if no error occurred.
		* - #MA_NOTIFICATION_RES_ERROR.
		*/
		int maNotificationPushSetMessageTitle(in MAString messageTitle);

		/**
		* \brief Set the display flags applied to the incoming push notifications.
		* Note that regardless of this setting, the #EVENT_TYPE_PUSH_NOTIFICATION event
		* will be received for each incoming notification.
		* #MA_NOTIFICATION_DISPLAY_FLAG_DEFAULT is enabled by default.
		* Platform: Android only.
		* \param displayFlag One of the constants:
		* - #MA_NOTIFICATION_DISPLAY_FLAG_DEFAULT Which is enabled by default.
		* - #MA_NOTIFICATION_DISPLAY_FLAG_ANYTIME.
		* \return One of the next constants:
		* - #MA_NOTIFICATION_RES_OK if no error occurred.
		* - #MA_NOTIFICATION_RES_ERROR if push notifications are not supported,
		* or the input value is not valid.
		*/
		int maNotificationPushSetDisplayFlag(in int displayFlag);
	}//End of Notification Functions
} // End of Notification API

group CaptureAPI "Capture API" {
	group CaptureResultCodes "Capture result codes" {
		constset int MA_CAPTURE_RES_ {
			/**
			* @brief Indicates that the call was successful.
			* Platform: Android and iOS.
			*/
			OK = 0;

			/**
			* @brief The given file name is invalid.
			* Platform: iOS.
			*/
			FILE_INVALID_NAME = -1;

			/**
			* @brief The file already exists.
			* Platform: iOS.
			*/
			FILE_ALREADY_EXISTS = -2;

			/**
			* @brief Indicates that the call to maCaptureSetProperty or maCaptureGetProperty received
			* an invalid property name.
			* Platform: iOS and Android.
			*/
			INVALID_PROPERTY = -3;

			/**
			* @brief Indicates that the call to maCaptureSetProperty or maCaptureGetProperty received
			* an invalid property value.
			* Platform: iOS and Android.
			*/
			INVALID_PROPERTY_VALUE = -4;

			/**
			* @brief Indicates that the call to maCaptureGetProperty needs a larger buffer.
			* Platform: iOS and Android.
			*/
			INVALID_STRING_BUFFER_SIZE = -5;

			/**
			* @brief Indicates that the call to maCaptureAction received an invalid action type.
			* Platform: iOS and Android.
			*/
			INVALID_ACTION = -6;

			/**
			* @brief Indicates that the call to maCaptureDestroyData received an invalid handle.
			* Platform: iOS and Android.
			*/
			INVALID_HANDLE = -7;

			/**
			* @brief Indicates that capture is not supported on current platform.
			* Platform: iOS.
			*/
			UNSUPPORTED = -8;

			/**
			* @brief Indicates that camera is not available at the moment.
			* Platform: iOS.
			*/
			CAMERA_NOT_AVAILABLE = -9;

			/**
			* @brief Indicates that video recording is not supported.
			* Platform: iOS.
			*/
			VIDEO_NOT_SUPPORTED = -10;

			/**
			* @brief Indicates that camera picture mode is not supported.
			* Platform: iOS.
			*/
			PICTURE_NOT_SUPPORTED = -11;

			/**
			* @brief Indicates that flash mode is not supported.
			* Platform: iOS.
			*/
			FLASH_NOT_SUPPORTED = -12;

			/**
			* @brief Indicates that the recording max duration is not supported.
			* Platform: Android.
			*/
			MAX_DURATION_NOT_SUPPORTED = -13;

			/**
			* @brief Indicates that a call to maCaptureGetProperty was unsuccessfull
			* because the property was not previously set.
			* Platform: Android.
			*/
			PROPERTY_VALUE_UNDEFINED = -14;
		}
	} // end of Capture Result Codes

	group CaptureProperties "Capture Properties" {
		constset MAString MA_CAPTURE_ {
			/**
			* @brief Maximum duration video that should be recorded, in seconds.
			* Platform: Android and iOS.
			*
			* @validvalue Positive integer value.
			* Default value is platform specific.
			*
			* On iOS the maximum duration is by defualt set to 600 seconds.
			*
			* On Android devices with API level lower than 8
			* it returns #MA_CAPTURE_RES_MAX_DURATION_NOT_SUPPORTED.
			*
			* @setandget
			*
			* @par Example
			* \code
			*   char buf[256];
			*   sprintf(buf, "%d", 100);
			*	maCaptureSetProperty(MA_CAPTURE_MAX_DURATION, buf);
			* \endcode
			*/
			MAX_DURATION = "maxDuration";

			/**
			* @brief Set the video recording quality.
			* Platform: Android and iOS.
			* Android: Note that some devices the default camera either does not support low-res video capture,
			* or it doesn't understand/process the MediaStore.EXTRA_SIZE_LIMIT correctly.
			*
			* @validvalue One of the \link #MA_CAPTURE_VIDEO_QUALITY_LOW MA_CAPTURE_VIDEO_QUALITY \endlink constants.
			* iOS: Default value is MA_CAPTURE_VIDEO_QUALITY_MEDIUM.
			* Android: Default value is MA_CAPTURE_VIDEO_QUALITY_HIGH.
			*
			* @setandget
			*
			* @par Example
			* \code
			*   char buf[256];
			*   sprintf(buf, "%d", MA_CAPTURE_VIDEO_QUALITY_HIGH);
			*	maCaptureSetProperty(MA_CAPTURE_VIDEO_QUALITY, buf);
			* \endcode
			*/
			VIDEO_QUALITY = "videoQuality";

			/**
			* @brief Store the recorded movie/taken photo to the users Camera Roll album.
			* Platform: iOS.
			*
			* @validvalue "false" or "true".
			* Default value: "true".
			*
			* @setandget
			*
			* @par Example
			* \code
			*   char buf[256];
			*   sprintf(buf, "%s", "true");
			*	maCaptureSetProperty(MA_CAPTURE_CAMERA_ROLL, buf);
			* \endcode
			*/
			CAMERA_ROLL = "cameraRoll";

			/**
			* @brief Set the flash mode used by the active camera.
			* Platform: iOS.
			*
			* @validvalue One of the \link #MA_CAPTURE_FLASH_AUTO MA_CAPTURE_FLASH \endlink constants.
			* Default value: #MA_CAPTURE_FLASH_AUTO.
			*
			* @setandget
			*
			* @par Example
			* \code
			*   char buf[256];
			*   sprintf(buf, "%d", MA_CAPTURE_FLASH_OFF);
			*	maCaptureSetProperty(MA_CAPTURE_FLASH, buf);
			* \endcode
			*/
			FLASH = "flash";

			/**
			* @brief Show/hide default camera controls.
			* @brief Show/hide default camera controls.
			* Platform: iOS.
			*
			* @validvalue "true" or "false".
			* Default value: "true".
			*
			* @setandget
			*
			* @par Example
			* \code
			*   char buf[256];
			*   sprintf(buf, "%s", "false");
			*	maCaptureSetProperty(MA_CAPTURE_CAMERA_CONTROLS, buf);
			* \endcode
			*/
			CAMERA_CONTROLS = "cameraControls";
		}
	} // end of Capture properties

	group CaptureVideoQuality "Capture Video Quality" {
		constset int MA_CAPTURE_VIDEO_QUALITY_ {
			/// Use low-quality video recording.
			/// Platform: iOS and Android.
			LOW = 0;
			/// The highest-quality video recording supported for the active camera on the device.
			/// Platform: iOS and Android.
			HIGH = 1;
			/// Use medium-quality video recording.
			/// Platform: iOS only.
			MEDIUM = 2;
		}
	} // end of Capture Media Types

	group CaptureAction "Capture Action" {
		constset int MA_CAPTURE_ACTION_ {
			/// Starts video capture.
			/// Platform: Android and iOS.
			RECORD_VIDEO = 0;
			/// Stops recording.
			/// Platform: iOS only.
			STOP_RECORDING = 1;
			/// Starts image capture (takes photo).
			/// Platform: Android and iOS.
			TAKE_PICTURE = 2;
		}
	} // end of Capture Action

	group CaptureEventType "Capture Event type" {
		constset int MA_CAPTURE_EVENT_TYPE_ {
			/// Sent after a image has been taken.
			/// Platform: Android and iOS.
			IMAGE = 0;
			/// Sent after a video has been taken.
			/// Platform: Android and iOS.
			VIDEO = 1;
			/// Sent if the user cancels taking image/video.
			/// Platform: iOS and Android.
			CANCEL = 2;
		}
	} // end of Capture Event type

	group CaptureFlashMode "Capture flash mode" {
		constset int MA_CAPTURE_FLASH_ {
			/// Specifies that the device should consider ambient light conditions to automatically
			/// determine whether or not to use flash illumination.
			/// Platform: iOS.
			AUTO = 0;
			/// Specifies that flash illumination is always on, no matter what the ambient light conditions are.
			/// Platform: iOS.
			ON = 1;
			/// Specifies that flash illumination is always off, no matter what the ambient light conditions are.
			/// Platform: iOS.
			OFF = 2;
		}
	} // end of Capture flash mode

	group CaptureFunctions "Capture Functions" {
		/**
		* \brief Sets the properties to the Native Image Picker.
		* \param property A string representing which property to set.
		*  One of the \link #MA_CAPTURE_VIDEO_QUALITY MA_CAPTURE \endlink constants.
		* \param value The value that will be assigned to the property.
		*
		* \returns One of the next constants:
		*  - #MA_CAPTURE_RES_OK if no error occurred.
		*  - #MA_CAPTURE_RES_INVALID_PROPERTY if the property name is not valid.
		*  - #MA_CAPTURE_RES_INVALID_PROPERTY_VALUE if the property value is not valid.
		*  - #MA_CAPTURE_RES_MAX_DURATION_NOT_SUPPORTED if the duration limit is not supported ( Android only).
		*/
		int maCaptureSetProperty(in MAString property, in MAString value);

		/**
		* \brief Retrieves the properties from the Native Image Picker.
		*
		* \param property A string representing which property to get.
		*  One of the \link #MA_CAPTURE_VIDEO_QUALITY MA_CAPTURE \endlink constants.
		* \param value A buffer that will hold the value of the property, represented as a string.
		* \param bufSize Size of the buffer.
		*
		* \returns One of the next constants:
		* - #MA_CAPTURE_RES_OK if no error occurred.
		* - #MA_CAPTURE_RES_INVALID_PROPERTY if the property name is not valid.
		* - #MA_CAPTURE_RES_INVALID_STRING_BUFFER_SIZE if the buffer size was to small.
		* - #MA_CAPTURE_RES_PROPERTY_VALUE_UNDEFINED if the property was not previously set ( Android only).
		* - #MA_CAPTURE_RES_MAX_DURATION_NOT_SUPPORTED if the duration limit is not supported ( Android only).
		*/
		int maCaptureGetProperty(in MAString property, out MAString value range("bufSize"), in int bufSize);

		/**
		* \brief Performs a capture action.
		*
		* The specified action is performed and the result is delivered
		* asynchronously in an \link #EVENT_TYPE_CAPTURE event. The content
		* of the event is an #MACaptureEventData data structure. The type
		* field contains the type of capture event (#MA_CAPTURE_EVENT_TYPE_IMAGE,
		* #MA_CAPTURE_EVENT_TYPE_VIDEO, #MA_CAPTURE_EVENT_TYPE_CANCEL), and the
		* handle field contains a handle to the capture object. Save a
		* captured image using function #maCaptureWriteImage. Access a
		* captured video using function #maCaptureGetVideoPath. Free the capture
		* object using function #maCaptureDestroyData.
		*
		* Note: The image format for #MA_CAPTURE_EVENT_TYPE_IMAGE is JPEG on Android
		* and PNG on iOS.
		*
		* Platforms: Android an iOS.
		*
		* \param action One of the \link #MA_CAPTURE_ACTION_TAKE_PICTURE MA_CAPTURE_ACTION \endlink constants.
		*
		* \returns One of the next constants:
		*  - #MA_CAPTURE_RES_OK if no error occurred.
		*  - #MA_CAPTURE_RES_INVALID_ACTION if the given action is invalid.
		*  - #MA_CAPTURE_RES_CAMERA_NOT_AVAILABLE if camera is not available at the moment.
		*  - #MA_CAPTURE_RES_VIDEO_NOT_SUPPORTED if video recording is not supported.
		*  - #MA_CAPTURE_RES_PICTURE_NOT_SUPPORTED if camera picture mode is not supported.
		*/
		int maCaptureAction(in int action);

		/**
		* \brief Save a image data object to a file.
		* \param handle Handle to an image data object.
		* \param fullPath A buffer containing the a full path where the file will be created.
		* \param fullPathBufSize The size of the fullPath buffer.
		*
		* \returns One of the next constants:
		*  - #MA_CAPTURE_RES_OK if no error occurred.
		*  - #MA_CAPTURE_RES_INVALID_HANDLE if the given handle was invalid.
		*  - #MA_CAPTURE_RES_FILE_INVALID_NAME if the fullPath param is invalid.
		*  - #MA_CAPTURE_RES_FILE_ALREADY_EXISTS if the file already exists.
		*/
		int maCaptureWriteImage(in MAHandle handle, in MAString fullPath, in int fullPathBufSize);

		/**
		* \brief Get full path to a taken picture.
		* Available on Android only.
		* \param handle Handle to an image data object.
		* \param buffer Will contain the full path of the image file.
		* \param bufferSize Maximum size of the buffer.
		*
		* \returns One of the next constants:
		*  - #MA_CAPTURE_RES_OK if no error occurred.
		*  - #MA_CAPTURE_RES_INVALID_HANDLE if the given handle was invalid.
		*  - #MA_CAPTURE_RES_INVALID_STRING_BUFFER_SIZE if the buffer size was to small.
		*/
		int maCaptureGetImagePath(in MAHandle handle, out MAString buffer range("bufferSize"), in int bufferSize);

		/**
		* \brief Get full path to a recorded video.
		* \param handle Handle to a video data object.
		* \param buffer Will contain the full path to the video file.
		* \param bufferSize Maximum size of the buffer.
		*
		* \returns One of the next constants:
		*  - #MA_CAPTURE_RES_OK if no error occurred.
		*  - #MA_CAPTURE_RES_INVALID_HANDLE if the given handle was invalid.
		*  - #MA_CAPTURE_RES_INVALID_STRING_BUFFER_SIZE if the buffer size was to small.
		*/
		int maCaptureGetVideoPath(in MAHandle handle, out MAString buffer range("bufferSize"), in int bufferSize);

		/**
		* \brief Destroys a image/video data object.
		* \param handle Handle to a image/video data object.
		*
		* \returns One of the next constants:
		*  - #MA_CAPTURE_RES_OK if no error occurred.
		*  - #MA_CAPTURE_RES_INVALID_HANDLE if the given handle was invalid.
		*/
		int maCaptureDestroyData(in MAHandle handle);
	}//End of Capture Functions

} // End of Capture API

group PurchaseAPI "Purchase API" {
#include "Modules/purchase.idl"
} // End of Purchase API

group OrientationAPI "Orientation API" {
#include "Modules/orientation.idl"
} // End of Orientation API

}
	constset int IOCTL_ {
		UNAVAILABLE = -1;
	}

}
