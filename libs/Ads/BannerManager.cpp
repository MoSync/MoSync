/*
Copyright (C) 2011 MoSync AB

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License,
version 2, as published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
MA 02110-1301, USA.
*/

/**
 * @file BannerManager.cpp
 * @author Bogdan Iusco
 *
 * \brief The BannnerManager manages banner events and dispatches
 * them to the target banners.
 */

#include "BannerManager.h"
#include "Banner.h"

namespace Ads
{
	/**
	 * Initialize the singleton variable to NULL.
	 */
	BannerManager* BannerManager::sInstance = NULL;

	/**
	 * Constructor is protected since this is a singleton.
	 * (subclasses can still create instances).
	 */
	BannerManager::BannerManager()
	{
        // Add me as a custom event listener.
        MAUtil::Environment::getEnvironment().addCustomEventListener(this);
	}

	/**
	 * Destructor.
	 */
	BannerManager::~BannerManager()
	{
        // Remove me as a custom event listener.
        MAUtil::Environment::getEnvironment().removeCustomEventListener(this);
	}

	/**
	 * Return the single instance of this class.
	 */
	BannerManager* BannerManager::getInstance()
	{
        if (NULL == BannerManager::sInstance)
        {
            BannerManager::sInstance = new BannerManager();
        }

        return sInstance;
	}

	/**
	 * Destroy the single instance of this class.
	 * Call this method only when the application will exit.
	 */
	void BannerManager::destroyInstance()
	{
        delete BannerManager::sInstance;
	}

	/**
	 * Implementation of CustomEventListener interface.
	 * This method will get called whenever there is a
	 * widget event generated by the system.
	 * @param event The new received event.
	 */
	void BannerManager::customEvent(const MAEvent& event)
	{
        // Check if this is a widget event.
        if (EVENT_TYPE_ADS_BANNER == event.type)
        {
            // Check if the banner exists in the map.
            if (mBannerMap.end() != mBannerMap.find(event.adsData.bannerHandle))
            {
                // Get the banner object that wraps the banner handle.
                Banner* banner = mBannerMap[event.adsData.bannerHandle];

                // Call the banner's event handling method.
                banner->handleBannerEvent(event);
            }
        }
	}

	/**
	 * Add a banner to the map that holds banners.
	 * The banner will receive custom events.
	 * @param banner The banner that needs to be registered.
	 * The ownership of the banner is not passed to this method.
	 */
	void BannerManager::registerBanner(Banner* banner)
	{
		mBannerMap[banner->getHandle()] = banner;
	}

	/**
	 * Remove a banner from the map that holds banners.
	 * The banner will not receive custom events.
	 * @param banner The banner that needs to be unregistered.
	 */
	void BannerManager::unregisterBanner(Banner* banner)
	{
		mBannerMap.erase(banner->getHandle());
	}

} // namespace Ads
