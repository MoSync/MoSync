/* Copyright (C) 2009 Mobile Sorcery AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

#include "FileConnection.h"

//***************************************************************************
//Helper Functions
//***************************************************************************
FileHandle getFileHandle(MAHandle file) {
	FileHandle fh = (FileHandle)mFileHandles.get(new Integer(file));
	DEBUG_ASSERT(fh != null);
	return fh;
}

FileHandle getFileInputStream(MAHandle file) throws IOException {
	FileHandle fh = getFileHandle(file);
	if(fh.out != null) {
		//DEBUG_TEMP("closing output stream.\n");
		// make sure everything's written to disk.
		fh.out.flush();
		fh.out.close();
		fh.out = null;
		if(fh.in != null) {
			//DEBUG_TEMP("closing input stream.\n");
			fh.in.close();
			fh.in = null;
		}
		//DEBUG_TEMP("closing file!\n");
		String url = fh.fc.getURL();
		fh.fc.close();
		fh.fc = (FileConnection)Connector.open(url);
	}
	if(fh.in == null) {
		fh.in = fh.fc.openDataInputStream();
		if(fh.position != 0)
			fh.in.skip(fh.position);
	}
	return fh;
}

FileHandle getFileOutputStream(MAHandle file) throws IOException {
	FileHandle fh = getFileHandle(file);
	if(fh.out == null) {
		//DEBUG_TEMP("openOutputStream("+fh.position+");\n");
		fh.out = fh.fc.openOutputStream(fh.position);
	}
	return fh;
}

//***************************************************************************
//File Functions
//***************************************************************************
final MAHandle maFileOpen(String path, int mode) {
	DEBUG_TEMP("maFileOpen("+path+", "+mode+"): "+mFileNextHandle+"\n");
	FileConnection fc;
	try {
		fc = (FileConnection)Connector.open("file:///" + path, mode);
		if(fc == null) {
			DEBUG_ALWAYS("maFileOpen: Connector.open(\"file:///" + path + "\", "+mode+") returned null.\n");
			return MA_FERR_GENERIC;
		}
		if(fc.exists() && (fc.isDirectory() != (path.charAt(path.length()-1) == '/'))) {
			DEBUG_ALWAYS("maFileOpen: slash/isDirectory mismatch.\n");
			fc.close();
			return MA_FERR_WRONG_TYPE;
		}
	} catch(SecurityException e) {
		PRINT_STACK_TRACE;
		return MA_FERR_FORBIDDEN;
	} catch(IOException e) {
		PRINT_STACK_TRACE;
		return MA_FERR_GENERIC;
	}
	FileHandle fh = new FileHandle();
	fh.fc = fc;
	fh.position = 0;
	fh.maxPos = 0;
	mFileHandles.put(new Integer(mFileNextHandle), fh);
	return mFileNextHandle++;
}

final int maFileExists(MAHandle file) throws Exception {
	FileHandle fh = getFileHandle(file);
	DEBUG_TEMP("maFileExists("+file+"): "+fh.fc.exists()+"\n");
	return fh.fc.exists() ? 1 : 0;
}

final int maFileClose(MAHandle file) throws Exception {
	DEBUG_TEMP("maFileClose("+file+")\n");
	Integer key = new Integer(file);
	FileHandle fh = (FileHandle)mFileHandles.get(key);
	DEBUG_ASSERT(fh != null);
	if(fh.out != null)
		fh.out.close();
	if(fh.in != null)
		fh.in.close();
	if(fh.fc != null)
		fh.fc.close();
	mFileHandles.remove(key);
	return 0;
}

final int maFileCreate(MAHandle file) {
	FileHandle fh = getFileHandle(file);
	DEBUG_TEMP("maFileCreate("+fh.fc.getURL()+")\n");
	try {
		if(fh.isDirectory()) {
			fh.fc.mkdir();
		} else {
			fh.fc.create();
		}
	} catch(IOException e) {
		PRINT_STACK_TRACE;
		return MA_FERR_GENERIC;
	}
	return 0;
}

final int maFileTell(MAHandle file) throws Exception {
	FileHandle fh = getFileHandle(file);
	MYASSERT(fh.fc.exists() && !fh.fc.isDirectory());
	return fh.position;
}

final int maFileSeek(MAHandle file, int offset, int whence) throws Exception {
	FileHandle fh = getFileHandle(file);
	MYASSERT(fh.fc.exists() && !fh.fc.isDirectory());
	int newPos;
	switch(whence) {
	case MA_SEEK_SET:
		newPos = offset;
		break;
	case MA_SEEK_CUR:
		newPos = fh.position + offset;
		break;
	case MA_SEEK_END:
		newPos = (int)fh.fc.fileSize() + offset;
		break;
	default:
		BIG_PHAT_ERROR;
	}
	//DEBUG_TEMP("maFileSeek("+file+", "+offset+", "+whence+"): "+newPos+"\n");
	if(newPos == fh.position)
		return fh.position;
	if(fh.in != null) {
		if(newPos > fh.position) {
			fh.in.skip(newPos - fh.position);
		} else {
			fh.in.close();
			fh.in = null;
		}
	}
	if(fh.out != null) {
		fh.out.close();
		fh.out = null;
	}
	return fh.position = newPos;
}

final int maFileTruncate(MAHandle file, int offset) {
	try {
		DEBUG_TEMP("maFileTruncate("+file+", "+offset+")\n");
		FileHandle fh = getFileHandle(file);
		fh.fc.truncate(offset);
		if(fh.position > offset)
			fh.position = offset;
	} catch(IOException e) {
		PRINT_STACK_TRACE;
		return MA_FERR_GENERIC;
	}
	return 0;
}

final int maFileDelete(MAHandle file) {
	try {
		FileHandle fh = getFileHandle(file);

		// Make sure file is not open.
		Enumeration e = mFileHandles.elements();
		String url = fh.fc.getURL();
		while(e.hasMoreElements()) {
			FileHandle ofh = (FileHandle)e.nextElement();
			if(ofh.fc != null && ofh != fh) if(ofh.fc.getURL().equals(url)) {
				DEBUG_ALWAYS("maFileDelete("+file+"): file is still open!\n"); 
				return MA_FERR_GENERIC;
			}
		}

		fh.fc.delete();
	} catch(IOException e) {
		PRINT_STACK_TRACE;
		return MA_FERR_GENERIC;
	}
	return 0;
}

//***************************************************************************
//Miscellaneous Functions
//***************************************************************************

#define INT_MAX 0x7FFFFFFF

final int maFileSize(MAHandle file) {
	try {
		FileHandle fh = getFileHandle(file);

		// apparently, some calls to fileSize() can reset the position of a file's
		// OutputStream.
		if(fh.out != null) {
			fh.out.close();
			fh.out = null;
		}

		long s = fh.fc.fileSize();
		if(s > INT_MAX || s < 0) {
			return MA_FERR_GENERIC;
		}
		if(fh.maxPos > s)	{	// A call to maFileWrite may cause this to be true.
			//DEBUG_TEMP("fileSize("+file+"): "+s+"\n");
			s = fh.maxPos;
		}
		//DEBUG_TEMP("maFileSize("+file+"): "+s+"\n");
		return (int)s;
	} catch(IOException e) {
		PRINT_STACK_TRACE;
		return MA_FERR_GENERIC;
	}
}

final int maFileDate(MAHandle file) {
	FileHandle fh = getFileHandle(file);
	long d = fh.fc.lastModified() / 1000;
	if(d > INT_MAX) {
		return MA_FERR_GENERIC;
	}
	return (int)d;
}

final int maFileAvailableSpace(MAHandle file) {
	FileHandle fh = getFileHandle(file);
	long s = fh.fc.availableSize();
	if(s > INT_MAX) {
		return INT_MAX;
	}
	if(s < 0) {
		return MA_FERR_GENERIC;
	}
	return (int)s;
}

final int maFileTotalSpace(MAHandle file) {
	FileHandle fh = getFileHandle(file);
	long s = fh.fc.totalSize();
	if(s > INT_MAX) {
		return INT_MAX;
	}
	if(s < 0) {
		return MA_FERR_GENERIC;
	}
	return (int)s;
}

final int maFileRename(MAHandle file, String newName) {
	if(newName.indexOf('/') >= 0) {
		return MA_FERR_RENAME_DIRECTORY;
	}
	try {
		FileHandle fh = getFileHandle(file);
		fh.fc.rename(newName);
		// rename closes all streams.
		fh.in = null;
		fh.out = null;
		return 0;
	} catch(IOException e) {
		PRINT_STACK_TRACE;
		return MA_FERR_GENERIC;
	}
}


//***************************************************************************
//Read/Write Functions
//***************************************************************************

final int maFileWrite(MAHandle file, MAAddress src, int len) {
	try {
		FileHandle fh = getFileOutputStream(file);
		//DEBUG_TEMP("maFileWrite("+file+", "+len+") pos: "+fh.position+"\n");
		readMemStream(fh.out, src, len);
		fh.position += len;
		if(fh.position > fh.maxPos)
			fh.maxPos = fh.position;
		//fh.out.flush();
		//DEBUG_TEMP("size after write & flush: "+fh.fc.fileSize()+"\n");
	} catch(IOException e) {
		PRINT_STACK_TRACE;
		return MA_FERR_GENERIC;
	}
	return 0;
}

final int maFileWriteFromData(MAHandle file, MAHandle data, int offset, int len) {
	try {
		FileHandle fh = getFileOutputStream(file);
		BinaryInterface bi = (BinaryInterface)getResource(data);
		if(bi instanceof Binary) {
			Binary bin = (Binary)bi;
		#ifdef SEGMENTED_DATA
			bin.write(fh.out, offset, len);
		#else
			fh.out.write(bin.arr, offset, len);
		#endif
		} else {
			byte[] buffer = new byte[len];
			DataInputStream dis = new DataInputStream(bi.getInputStream());
			dis.readFully(buffer);
			dis.close();
			fh.out.write(buffer);
		}
		fh.position += len;
		if(fh.position > fh.maxPos)
			fh.maxPos = fh.position;
		//fh.out.flush();
	} catch(IOException e) {
		PRINT_STACK_TRACE;
		return MA_FERR_GENERIC;
	}
	return 0;
}

final int maFileRead(MAHandle file, MAAddress dst, int len) {
	try {
		FileHandle fh = getFileInputStream(file);
		//DEBUG_TEMP("maFileRead("+file+", "+len+") pos: "+fh.position+"\n");
		byte[] bytes = new byte[len];
		fh.in.readFully(bytes);
		writeMemBytes(dst, bytes, 0, len);
		fh.position += len;
	} catch(IOException e) {
		PRINT_STACK_TRACE;
		return MA_FERR_GENERIC;
	}
	return 0;
}

final int maFileReadToData(MAHandle file, MAHandle data, int offset, int len) {
	try {
		FileHandle fh = getFileInputStream(file);
		Binary bin = (Binary)getResource(data);
	#ifdef SEGMENTED_DATA
		bin.read(fh.in, offset, len);
	#else
		fh.in.readFully(bin.arr, offset, len);
	#endif
		fh.position += len;
	} catch(IOException e) {
		PRINT_STACK_TRACE;
		return MA_FERR_GENERIC;
	}
	return 0;
}

//***************************************************************************
//FileList Functions
//***************************************************************************

final int maFileListStart(String path, String filter) {
	Enumeration en;
	FileConnection fc = null;
	if(path.length() == 0) {
		en = FileSystemRegistry.listRoots();
	} else {
		try {
			String url = "file:///" + path +
				(path.charAt(path.length() - 1) == '/' ? "" : "/");
			//DEBUG_ALWAYS("maFileListStart '" + url + "'\n");
			fc = (FileConnection)Connector.open(url, Connector.READ);
			if(!fc.exists())
				return MA_FERR_NOTFOUND;
			//DEBUG_ALWAYS("filter: '" + filter + "'\n");
			en = fc.list(filter, true);
		} catch(IOException e) {
			PRINT_STACK_TRACE;
			return MA_FERR_GENERIC;
		} catch(SecurityException e) {
			PRINT_STACK_TRACE;
			return MA_FERR_GENERIC;
		}
	}
	FileListing fl = new FileListing();
	fl.en = en;
	fl.fc = fc;
	mFileListings.put(new Integer(mFileListNextHandle), fl);
	return mFileListNextHandle++;
}

final int maFileListNext(MAHandle list, Address nameBuf, int bufSize) {
	FileListing fl = (FileListing)mFileListings.get(new Integer(list));
	DEBUG_ASSERT(fl != null);
	String s = null;
	if(fl.last != null) {
		s = fl.last;
		fl.last = null;
	} else if(fl.en.hasMoreElements()) {
		s = (String)fl.en.nextElement();
	}
	if(s != null) {
		int res = writeStringBuf(s, nameBuf, bufSize);
		if(res >= bufSize)
			fl.last = s;
		return res;
	} else {
		return 0;
	}
}

final int maFileListClose(MAHandle list) throws IOException {
	Integer key = new Integer(list);
	FileListing fl = (FileListing)mFileListings.get(key);
	if(fl.fc != null)
		fl.fc.close();
	return mFileListings.remove(key) == null ? MA_FERR_GENERIC : 0;
}
