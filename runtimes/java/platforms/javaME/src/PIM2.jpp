/* Copyright (C) 2009 Mobile Sorcery AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

// include this file in Syscall.jpp.

// subclasses
static class MyPimList {
	PIMList pl;
	Enumeration e;
}

// variables
PIM mPimInstance;
Hashtable mPimListHandles = new Hashtable();
int mPimListNextHandle = 1;
Hashtable mPimItemHandles = new Hashtable();
int mPimItemNextHandle = 1;

// helpers
MyPimList getPimList(MAHandle list) {
	MyPimList pl = (MyPimList)mPimListHandles.get(new Integer(list));
	DEBUG_ASSERT(pl != null);
	return pl;
}

PIMItem getPimItem(MAHandle item) {
	PIMItem pi = (PIMItem)mPimItemHandles.get(new Integer(item));
	DEBUG_ASSERT(pi != null);
	return pi;
}


// syscalls
MAHandle maPimListOpen(int listType) throws PIMException {
	if(mPimInstance == null) {
		mPimInstance = PIM.getInstance();
	}
	PIMList pl = mPimInstance.openPIMList(listType, PIM.READ_WRITE);
	MyPimList mpl = new MyPimList();
	mpl.pl = pl;
	mpl.e = pl.items();
	mPimListHandles.put(new Integer(mPimListNextHandle), mpl);
	return mPimListNextHandle++;
}

MAHandle maPimListNext(MAHandle list) {
	MyPimList pl = getPimList(list);
	if(!pl.e.hasMoreElements())
		return 0;
	PIMItem pi = (PIMItem)pl.e.nextElement();
	mPimItemHandles.put(new Integer(mPimItemNextHandle), pi);
	return mPimItemNextHandle++;
}

MAHandle maPimItemCreate(MAHandle list) {
	MyPimList mpl = getPimList(list);
	PIMList pl = mpl.pl;
	PIMItem pi;
	if(pl instanceof ContactList) {
		ContactList cl = (ContactList)pl;
		pi = cl.createContact();
	} else if(pl instanceof EventList) {
		EventList el = (EventList)pl;
		pi = el.createEvent();
	} else if(pl instanceof ToDoList) {
		ToDoList tl = (ToDoList)pl;
		pi = tl.createToDo();
	} else {
		BIG_PHAT_ERROR;
	}
	mPimItemHandles.put(new Integer(mPimItemNextHandle), pi);
	return mPimItemNextHandle++;
}

int maPimItemRemove(MAHandle list, MAHandle item) throws PIMException {
	MyPimList mpl = getPimList(list);
	PIMList pl = mpl.pl;
	Integer key = new Integer(item);
	PIMItem pi = (PIMItem)mPimItemHandles.get(key);
	if(pl instanceof ContactList) {
		ContactList cl = (ContactList)pl;
		cl.removeContact((Contact)pi);
	} else if(pl instanceof EventList) {
		EventList el = (EventList)pl;
		el.removeEvent((Event)pi);
	} else if(pl instanceof ToDoList) {
		ToDoList tl = (ToDoList)pl;
		tl.removeToDo((ToDo)pi);
	} else {
		BIG_PHAT_ERROR;
	}
	mPimItemHandles.remove(key);
	return 0;
}

int maPimListClose(MAHandle list) throws PIMException {
	Integer key = new Integer(list);
	MyPimList pl = (MyPimList)mPimListHandles.get(key);
	if(pl.pl != null)
		pl.pl.close();
	mPimListHandles.remove(key);
	return 0;
}

int maPimItemClose(MAHandle item) throws PIMException {
	Integer key = new Integer(item);
	PIMItem pi = (PIMItem)mPimItemHandles.get(key);
	DEBUG_ASSERT(pi != null);
	if(pi.getPIMList() != null)
		pi.commit();
	if(mPimItemHandles.remove(key) == null) {
		BIG_PHAT_ERROR;
	}
	return 0;
}

int maPimItemCount(MAHandle item) {
	PIMItem pi = getPimItem(item);
	return pi.getFields().length;
}

int maPimItemGetField(MAHandle item, int index) {
	PIMItem pi = getPimItem(item);
	return pi.getFields()[index];
}

int maPimItemFieldCount(MAHandle item, int field) {
	PIMItem pi = getPimItem(item);
	return pi.countValues(field);
}
int maPimItemGetAttributes(MAHandle item, int field, int index) {
	PIMItem pi = getPimItem(item);
	return pi.getAttributes(field, index);
}

int maPimFieldType(MAHandle list, int field) {
	MyPimList pl = getPimList(list);
	return pl.pl.getFieldDataType(field);
}

#if 0
struct MA_PIM_ARGS {
	MAHandle item;
	int field;
	MAString buf;
	int bufSize;
}
#endif

int maPimItemGetValue(MAAddress args, int index) {
	INIT_MEMDS;
	PIMItem pi = getPimItem(RINT(args));
	int field = RINT(args+4);
	int address = RINT(args+8);
	int bufSize = RINT(args+12);
	int dataType = pi.getPIMList().getFieldDataType(field);

	int i;
	switch(dataType) {
	case PIMItem.BINARY:
		{
			byte[] bin = pi.getBinary(field, index);
			int len = bin.length;
			if(len > bufSize)
				return len;
			writeMemBytes(address, bin, 0, len);
			return len;
		}
	case PIMItem.BOOLEAN:
		i = pi.getBoolean(field, index) ? 1 : 0;
		break;
	case PIMItem.DATE:
		i = (int)(pi.getDate(field, index) / 1000);
		break;
	case PIMItem.INT:
		i = pi.getInt(field, index);
		break;
	case PIMItem.STRING:
		{
			String s = pi.getString(field, index);
			return writeWideString(s, address, bufSize);
		}
	case PIMItem.STRING_ARRAY:
		{
			//collapses nulls to empty strings. hopefully it won't cause too much trouble.
			String[] arr = pi.getStringArray(field, index);
			int totLen = 4;
			for(int j=0; j<arr.length; j++) {
				if(arr[j] != null)
					totLen += arr[j].length();
				totLen += 1;
			}
			int totSize = totLen*2;
			if(totSize > bufSize)
				return totSize;
			WINT(address, arr.length);
			int adr = address + 4;
			for(int j=0; j<arr.length; j++) {
				if(arr[j] != null) {
					writeWideStringRaw(arr[j], adr);
					adr += arr[j].length()*2;
				}
				WSHORT(adr, (short)0);
				adr += 2;
			}
			return totSize;
		}
	default:
		BIG_PHAT_ERROR;
	}

	if(4 > bufSize)
		return 4;
	WINT(address, i);
	return 4;
}

private String[] readPimStringArray(Address address, int bufSize) {
	MYASSERT(bufSize >= 4);
	MYASSERT((bufSize & 1) == 0);	// alignment: 2 bytes
	INIT_MEMDS;
	int clientArraySize = RINT(address);
	DUMP(clientArraySize);
	//int systemArraySize = pi.getPIMList().stringArraySize(field);
	//collapses empty strings to nulls. hopefully it won't cause too much trouble.
	String[] arr = new String[clientArraySize];

	Address a = address + 4;
	Address end = address + bufSize;
	for(int i=0; i<clientArraySize; i++) {
		MYASSERT(a < end);
		int maxLen = ((end - a) / 2) - 1;
		arr[i] = readWideStringEx(a, new StringBuffer(), maxLen);
		a += (arr[i].length() + 1) * 2;
		if(arr[i].length() == 0)
			arr[i] = null;
		DEBUG_TEMP(i+": '"+arr[i]+"'\n");
	}
	return arr;
}

int maPimItemSetValue(MAAddress args, int index, int attributes) {
	INIT_MEMDS;
	PIMItem pi = getPimItem(RINT(args));
	int field = RINT(args+4);
	int address = RINT(args+8);
	int bufSize = RINT(args+12);
	int dataType = pi.getPIMList().getFieldDataType(field);
	DEBUG_TEMP("maPimItemSetValue("+field+", "+index+", 0x"+Hex0(address)+", "+bufSize+")\n");
	DUMP(dataType);

	switch(dataType) {
	case PIMItem.BINARY:
		{
			byte[] bin = new byte[bufSize];
			readMemBytes(bin, address, 0, bufSize);
			pi.setBinary(field, index, attributes, bin, 0, bufSize);
		}
		break;
	case PIMItem.BOOLEAN:
		MYASSERT(bufSize == 4);
		pi.setBoolean(field, index, attributes, RINT(address) != 0);
		break;
	case PIMItem.DATE:
		MYASSERT(bufSize == 4);
		pi.setDate(field, index, attributes, ((long)RINT(address)) * 1000);
		break;
	case PIMItem.INT:
		MYASSERT(bufSize == 4);
		pi.setInt(field, index, attributes, RINT(address));
		break;
	case PIMItem.STRING:
		{
			String s = readWideString(address, bufSize);
			pi.setString(field, index, attributes, s);
		}
		break;
	case PIMItem.STRING_ARRAY:
		pi.setStringArray(field, index, attributes, readPimStringArray(address, bufSize));
		break;
	default:
		BIG_PHAT_ERROR;
	}

	return 0;
}

int maPimItemAddValue(MAAddress args, int attributes) {
	INIT_MEMDS;
	PIMItem pi = getPimItem(RINT(args));
	int field = RINT(args+4);
	int address = RINT(args+8);
	int bufSize = RINT(args+12);
	int dataType = pi.getPIMList().getFieldDataType(field);
	DEBUG_TEMP("maPimItemAddValue("+field+", 0x"+Hex0(address)+", "+bufSize+")\n");
	DUMP(dataType);

	switch(dataType) {
	case PIMItem.BINARY:
		{
			byte[] bin = new byte[bufSize];
			readMemBytes(bin, address, 0, bufSize);
			pi.addBinary(field, attributes, bin, 0, bufSize);
		}
		break;
	case PIMItem.BOOLEAN:
		MYASSERT(bufSize == 4);
		pi.addBoolean(field, attributes, RINT(address) != 0);
		break;
	case PIMItem.DATE:
		MYASSERT(bufSize == 4);
		pi.addDate(field, attributes, ((long)RINT(address)) * 1000);
		break;
	case PIMItem.INT:
		MYASSERT(bufSize == 4);
		pi.addInt(field, attributes, RINT(address));
		break;
	case PIMItem.STRING:
		{
			String s = readWideString(address, bufSize);
			pi.addString(field, attributes, s);
		}
		break;
	case PIMItem.STRING_ARRAY:
		pi.addStringArray(field, attributes, readPimStringArray(address, bufSize));
		break;
	default:
		BIG_PHAT_ERROR;
	}

	return 0;
}

int maPimItemRemoveValue(MAHandle item, int field, int index) {
	PIMItem pi = getPimItem(item);
	pi.removeValue(field, index);
	return 0;
}
